#+TITLE: My Emacs configuration
#+AUTHOR: dakodeon
#+EMAIL: dakodeon@hotmail.com

#+TODO: TODO WORKING | DONE REJECTED

* INTRODUCTION

Emacs configuration managed with org-mode and use-package.

The code snippets below are loaded by =init.el=, which also loads
=use-package=.

** TODO Attempting a more concise documentation
  - Start by loading frameworks like evil and general (avoid writing eval-after-load all the time.)
  - Use :general use-package delcaration to specify leader keys and the :general keyword in all other packages. (maybe)
  - Generalise the use of use package, for consistency


* GENERAL

  General provides a universal way of binding keys, which integrates
  both define-key and evil-define-key. It also offers a way to
  immitate vim's leader key functionality, both locally and globally.
  This is great for someone who uses evil, as bindings can be a mess.

  It is supposed to provide a key for use-package (:general), which
  can be used for per-package configuration. That way I can define all
  leaders in general's declaration and then assign key chords in a
  per-package basis.

  I haven't really played around with this package, so I am not sure
  if I will keep it around.
  
   #+begin_src emacs-lisp
   (use-package general
     :ensure t
     :after evil
     :bind
     ("C-h G" . 'general-describe-keybindings)
     :config
     (general-create-definer evil-leader
       :prefix "SPC")
     (general-create-definer evil-leader-org
       :prefix "SPC o"))
   #+end_src
   
** TODO TODO list [0/2]

*** TODO General's general usage

    General is a package that can completely replace other key
    bindings' definitions. This has the plus of syntax consistency,
    but I am not convinced to use it e.g instead of the :bind key in
    use-package. For sure the create-definer function is very useful.

*** TODO Local definers

    Figure out a way to bind local definers.

* EVIL

  I tried evil-mode after being forced to stop using my arrow keys, as
  they were broken. So I got used to 'h,j,k,l'. I ended up really
  enjoying modal editing. Already using i3, it was a logical next
  step.

  So I decided to base my Emacs build on Evil mode.

  The most imortant change that I made is the replacement of insert
  state with normal emacs. That way I can have emacs bindings while
  editing text.

  I also use Evil collection. This is a package with preconfigured
  evil-bindings for many emacs packages, like mu4e and org-mode. I
  dont enable evil collection for all packages. For example, I define
  custom bindings for dired, due to some buggy behaviour (for some
  reason I was unable to rebind a key bound by evil collection).

** Evil collection

    #+begin_src emacs-lisp
    (use-package evil-collection
      :after evil
      :ensure t
      :config
      (evil-collection-init 'mu4e)
      (evil-collection-init 'image-dired)
      (evil-collection-init 'outline)
      (evil-collection-init 'help)
      (evil-collection-init 'man)
      (evil-collection-init 'package-menu)
      (evil-collection-init 'pdf)
      (evil-collection-init 'tetris)
      (evil-collection-init '2048-game))
    #+end_src

** Evil mode

    * Note: there's a bunch of bindings in normal-state beause of the
    visual-line-mode that I use. I have to get rid of that at some
    point.

    #+begin_src emacs-lisp
    (use-package evil
      :ensure t
      :init
      (setq evil-move-cursor-back nil)
      (setq evil-want-C-u-scroll t)
      (setq evil-want-fine-undo t)
      (setq evil-normal-state-cursor 'box)
      (setq evil-emacs-state-cursor 'bar)
      (setq evil-replace-state-cursor 'hbar)
      (setq evil-want-integration t)
      (setq evil-want-keybinding nil)
      (setq evil-find-skip-newlines t)
      :config
      (evil-mode 1)
      (evil-set-initial-state 'Info-mode 'emacs)
      (evil-set-initial-state 'org-capture-mode 'emacs)
      (evil-set-initial-state 'mu4e-compose-mode 'emacs)
      (evil-set-initial-state 'org-msg-mode 'emacs)
      ;; (evil-set-initial-state 'package-menu-mode 'emacs)
      (evil-set-initial-state 'special-mode 'emacs)
      ;; Use emacs state instead of insert state
      (evil-define-state emacs
	"Emacs used as insert state in evil."
	:tag " <EE> "
	:message "-- EMACS INSERT --"
	:input-method t)
      (defadvice evil-insert-state
	  (around emacs-state-instead-of-insert-state activate)
	"Emacs instead of Insert."
	(evil-emacs-state))
      :bind
      (:map evil-normal-state-map
	    ("j" . 'evil-next-visual-line)
	    ("k" . 'evil-previous-visual-line)
	    ("^" . 'evil-beginning-of-visual-line)
	    ("g^" . 'evil-first-non-blank-of-visual-line)
	    ("$" . 'evil-end-of-visual-line)
	    ;; ("g ^" . 'evil-beginning-of-line)
	    ("g$" . 'evil-end-of-line)
	    ([down] . 'evil-next-visual-line)
	    ([up] . 'evil-previous-visual-line)
	    ("C-S-o" . 'evil-jump-forward)
	    ("*" . nil) ;;prefix
	    ("*w" . 'evil-search-word-forward)
	    :map evil-emacs-state-map
	    ([escape] . 'evil-normal-state)))
     #+end_src

** TODO TODO list [0/3]

*** TODO Dired evil collection

    Figure out the bug with dired. I could use the basis of
    evil-collection's bindings and expand upon them.

*** TODO Visual line

    This is not really related to evil mode, but I put it here as it
    kinda messes with evil bindings. In general, when you switch to
    visual-line-mode, emacs reflects this switch on the related
    functions (eg beginning-of-line becomes beginning-of-visual-line
    and so forth). Evil-mode does not do that. One might argue that it
    should, but this made me think about the necessity of running such
    a mode in the first place. Recently I ended up using
    fill-paragraph more and more, so I think I should switch to using
    fill-mode.

*** TODO Better understnding of evil-ex

    There is a lack of documentation when it comes to the evil-ex
    command. It would be useful to dwelve into this so that I can
    manipulate it and customize it some more.

* AUTOCOMPLETE

  This is just a generic autocompletion framework. I haven't tweaked
  it in any way and it only works most of the time. For example,
  filename completion never worked as intended.

  Anyhow, it is still useable, but I guess I will try something like
  company soon.

   #+begin_src emacs-lisp
   (use-package auto-complete
     :ensure t
     :delight (auto-complete-mode " ⋯")
     :init
     (ac-config-default)
     (global-auto-complete-mode t)
     (setq ac-sources (append ac-sources '(ac-sources-filename)))
     (setq ac-ignore-case nil))
   #+end_src

** TODO TODO list [0/1]

*** TODO Switch to company

    After browsing the web, I found out that the autocomplete package
    is in fact unmaintained. So, it makes more and more sense to try
    company.
     
* NAVIGATION WITH IVY
** Ivy-mode
    
    Ivy is a narrowing and completion fraqmework for emacs. I switched
    to it from helm, because it was a lot easier to customize.

    Together with counsel, ivy provides alternatives to emacs
    commands, like switch-buffer, find-file, M-x etc. It also
    interfaces with some external tools, like fzf, ripgrep and wmctrl,
    which is great.

    I wrote some custom functions for Ivy to improve upon the existing
    functionality of inserting in the minibuffer text from the current
    buffer. However, these were rendered obsolete by a somewhat hidden
    feature of Ivy (ivy-next-history-element), which does exactly
    that, but better. I keep those, because of the code I wrote.

   #+begin_src emacs-lisp
   (use-package ivy
     :ensure t
     :delight
     :init
     (setq ivy-use-virtual-buffers t)
     (setq ivy-count-format "(%d/%d) ")
     :config
     ;; better word and symbol yanking in the minibuffer
     ;; UPDATE: -- I just learned that M-n calls `ivy-next-history-element', which does exactly what I want,
     ;; it yanks to the minibuffer the symbol or the word at point, or the active region, so...
     (defun l/ivy-yank-word ()
       "Pull word at point from buffer into search string."
       (interactive)
       (let (text)
	 (with-ivy-window
	   (setq text (thing-at-point 'word 'no-properties)))
	 (when text
	   (insert (replace-regexp-in-string
		    "  +" " "
		    (ivy--yank-handle-case-fold text)
		    t t)))))

     (defun l/ivy-yank-symbol ()
       "Pull symbol at point from buffer into search string."
       (interactive)
       (let (text)
	 (with-ivy-window
	   (setq text (thing-at-point 'symbol 'no-properties)))
	 (when text
	   (insert (replace-regexp-in-string
		    "  +" " "
		    (ivy--yank-handle-case-fold text)
		    t t)))))
     :bind
     (:map ivy-minibuffer-map
     ("M-w" . l/ivy-yank-word)
     ("M-s" . l/ivy-yank-symbol)))
   #+end_src
** Counsel
    
    Counsel is essentially the frontend of ivy. It packs all the
    useful ivy-enriched commands.

    Some of the functionality I use:

    - counsel-fzf: [[https://github.com/junegunn/fzf][Fzf]] is a fuzzy finder for files. Great tool! I
      added functionality from [[https://protesilaos.com/dotemacs][prot's configuration]] that enables us to
      switch root directory for a search (although I simplified it, as
      I still don't use counsel-rg). I also wrote a wrapper around the
      default function so that I can search for marked text if the
      region is active.
    - cousel-outline: Navigate an org file by searching it's headers.
      Also great! Just for customization's sake, I wrote an action to
      begin a fzf search with selected candidate, inspired by the way
      Prot handles switching from fzf to rg and vice-versa.
    - l/counsel-sufraw (to be renamed): [[https://gitlab.com/surfraw/Surfraw][Surfraw]] is a tool for
      searching the web from the command line. It provides a set of
      scripts (they are called elvi) which correspond each to a search
      engine (eg. Google, DuckDuckGo etc). Although there is already a
      package that integrates surfraw with ivy ([[https://github.com/jws85/counsel-surfraw/blob/master/counsel-surfraw.el][counsel-surfraw]]) I
      wrote my own, just for practice and for the sake of it! I ended
      up using some code from this package though. I also took an
      extra step (just for the bling!) and took the elvi's
      descriptions and passed them to ivy-rich (see next section).

    
   #+begin_src emacs-lisp
   (use-package counsel
     :ensure t
     :delight
     :config
     (defun l/counsel-fzf ()
       "Wraps around `counsel-fzf' to allow input from marked region."
       (interactive)
       (let (text)
	 (if mark-active
	     (setq text (buffer-substring-no-properties (region-beginning) (region-end))))
	 (counsel-fzf text)))

     ;; based on code by prot
     (defun l/counsel-fzf-dir (arg)
       "Specify root directory for `counsel-fzf'."
       (counsel-fzf ivy-text
		    (read-directory-name
		     (concat (car (split-string counsel-fzf-cmd))
			     " in directory: "))))

     (ivy-add-actions 'counsel-fzf
		      '(("r" l/counsel-fzf-dir "change root directory")))

   ;; from counsel-outline to fzf -- I should split these.
   (defun l/counsel-fzf-from-outline (arg)
     "Search for outline header with fzf."
     (counsel-fzf (car (last (split-string (substring-no-properties (ivy-state-current ivy-last)) "/")))))

   (ivy-add-actions 'counsel-outline
		    '(("f" l/counsel-fzf-from-outline "search with fzf")))

     ;; surfraw frontend
     (defvar l/surfraw-elvi-list
       (mapcar (lambda (x) (split-string x "\t+-- "))
	       (seq-remove
		(lambda (str) (not (string-match-p "--" str)))
		(split-string (shell-command-to-string "surfraw -elvi") "\n")))
       "An association list of elvi. Used by `l/ivy-surfraw'")

     (defun l/ivy-rich--ivy-surfraw-describe-elvi (elvi)
       (car (cdr (assoc elvi l/surfraw-elvi-list))))

     (defun l/ivy-surfraw ()
       "Search the web with surfraw. If region is active, search for that."
       (interactive)
       (let (text)
	 (if mark-active
	     (setq text (buffer-substring-no-properties (mark) (point)))
	   (setq text (read-string "What u wanna search? ")))
	 (ivy-read "Select search engine: "
		   (mapcar (lambda (entry) (car entry)) l/surfraw-elvi-list)
		   :action (lambda (x)
			     (let ((engine (replace-regexp-in-string " +.*$" "" x)))
			       (shell-command (concat "surfraw " engine " " (shell-quote-argument text)))))
		   :caller 'l/ivy-surfraw)))

     (eval-after-load "evil"
       '(progn
	  (evil-define-key 'normal org-mode-map "**" 'counsel-outline)))
     (ivy-mode 1)
     :bind
     (("M-x" . counsel-M-x)
     ("C-h f" . counsel-describe-function)
     ("C-h v" . counsel-describe-variable)
     ("C-c f" . l/counsel-fzf)
     ("C-c g" . counsel-rg)
     ("C-c b" . l/ivy-surfraw)))
   #+end_src
   
**** TODO Pack l/counsel-sufraw:
     I should keep this in a separate file and load it as a package.

** Swiper

    I should add here the configuration about swiper.

** Other functionality
 
    Here is some extra packages for ivy/counsel/swiper:

**** AMX

     AMX is a rating system for selection candidates. Most rated
     candidates are more likely to appear fisrt when using ivy.
    
    #+begin_src emacs-lisp
    (use-package amx
      :ensure t
      :after ivy
      :custom
      (amx-backend 'auto)
      (amx-save-file "~/.emacs.d/amx-items")
      :config
      (amx-mode 1))
    #+end_src

**** Ivy-rich

     Ivy-rich provides help strings to be displayed alongside ivy
     candidates. Really useful for some quick reference.

     I added functionality for my ivy-surfraw function.

    #+begin_src emacs-lisp
    (use-package ivy-rich
      :ensure t
      :config
      (plist-put ivy-rich-display-transformers-list
	       'l/ivy-surfraw '(:columns
				((ivy-rich-candidate (:width 20))
				 (l/ivy-rich--ivy-surfraw-describe-elvi)
				 )))
      (setcdr (assq t ivy-format-functions-alist) #'ivy-format-function-line)
      (ivy-rich-mode 1))
    #+end_src

**** Ivy-posframe

     Ivy-posframe provides custom positioning of the minibuffer
     depending on which function is called.

     The way I set it up is essentially copied from Prot's
     configuration. The default is for the minibuffer to be displayed
     as a box in the center of the frame, but for some functions, like
     swiper for example, it is best to be kept in the traditional
     position.

#+begin_src emacs-lisp
    (use-package ivy-posframe
      :ensure t
      :delight
      :custom
      (ivy-posframe-display-functions-alist
       '((complete-symbol . ivy-posframe-display-at-point)
	 (counsel-describe-function . nil)
	 (counsel-describe-variable . nil)
	 (swiper . nil)
	 (swiper-isearch . nil)
	 (t . ivy-posframe-display-at-frame-center)))
      :config
      (ivy-posframe-mode 1))
    #+end_src

** TODO TODO list [0/6]

*** TODO Swiper
    
    I haven't touch this yet, but I should. It is very useful.

*** TODO Pack l/ivy-surfraw

    The code revolving around this function could be separated from
    the config. I am not sure yet, but it could be it's own package.

*** TODO Configure ivy-posframe

    Posframe allows for every ivy frame to be positioned differently.
    I should standardize which frames I want to be in the classical
    position on the bottom of the frame and which I want popping up.
    Additionally, I should work out what happens with a smaller emacs
    frame (fix dimensions etc)

*** TODO Configure counsel-rg

    Counsel-rg is great for searching text in a bunch of files. I
    should configure it a bit more (check out prot's dotfiles).

*** TODO Configure counsel-wmctrl

    This is a very useful tool. It allows to focus on a different
    program by choosing it from an ivy list. I should expand on this
    functionality. Actually, this could be implemented system-wise,
    with dmenu (off-topic).

*** TODO Configure occur

    Again, check prot's dotfiles to configure what happens with the
    occur buffer from ivy candidates.

* DIRED

  Dired, the DIRectory EDitor, is the default file manager inside
  emacs. It uses ls with ls switches to generate an editable buffer of
  files lists, in which you can do whatever you would normally do in
  any file manager, and maybe more.

  I customized dired up to the point that I am very happy with the
  workflow achieved. This is a really long config, so I guess it is
  best to document it along the way.
  
** Defaults

   Here I define some defaults for dired. These include the default ls
   switches that generate the dired buffer, the use of dwim (do what I
   mean) while copying and moving (meaning that when performing a copy
   or move action the default target is the dired buffer in the other
   window, if existing), also adding hide-details-mode to the hook, to
   omit displaying all the info that the '-l' flag produces, as well
   as fixing a bug caused by a package no longer existent (something
   like the digital equivalent of a ghost limb).

   One drastic change I made to the defaults is the way dired shows up
   in the modeline. Delight does not work for dired, as its modeline
   output changes every time the ls flags change. This clutters the
   modeline as, for example, one flag that I use is
   '--group-directories-first'... I discovered the culprit: it was the
   function 'dired-sort-set-mode-line'. So, I completely redefined the
   function to output my custom names instead (note -- I know I should
   just advise the function, not completely redefine it, but at the
   time I was not familiar enough with advising. I might look into it
   soon).
  
  #+begin_src emacs-lisp
  (use-package dired
    :init
    (setq dired-dwim-target t)
    (setq dired-listing-switches "-Alh") ;; human-readable sizes, also omit . and ..
    :config
    ;; This hook seems to be added automatically to my 'custom.el' file
    ;; and breaks dired. I have to find out where it comes from. It was
    ;; a part of the `ranger' package, which I have deleted.
    (remove-hook 'dired-mode-hook 'ranger-set-dired-key)

    (add-hook 'dired-mode-hook 'dired-hide-details-mode) ;; list only filenames

    ;; modeline hack -- should replace this with advice
    (defun dired-sort-set-mode-line ()
      ;; Set mode line display according to dired-actual-switches.
      ;; Mode line display of "by name" or "by date" guarantees the user a
      ;; match with the corresponding regexps.  Non-matching switches are
      ;; shown literally.
      (when (eq major-mode 'dired-mode)
	(setq mode-name
	      (let (case-fold-search)
		(cond ((string-match-p
			(concat (regexp-quote "-Alh") "\\(\\s-\\|$\\)")
			dired-actual-switches)
		       "")
		      ((string-match-p
			(concat (regexp-quote "-Alht") "\\(\\s-\\|$\\)")
			dired-actual-switches)
		       "⇓D")
		      ((string-match-p
			(concat (regexp-quote "-AlhS") "\\(\\s-\\|$\\)")
			dired-actual-switches)
		       "⇓S")
		      ((string-match-p
			(concat (regexp-quote "-AlhX") "\\(\\s-\\|$\\)")
			dired-actual-switches)
		       "⇓X")
		      (t
		       "⇓?"))))
	(if (string-match-p
	     (regexp-quote " --group-directories-first")
	     dired-actual-switches)
	    (setq mode-name (concat mode-name "⋮"))
	  (setq mode-name (replace-regexp-in-string "⋮" "" mode-name)))
	(force-mode-line-update))))
  #+end_src

** Some basic customization

   Some tweaks of basic behaviour that I felt were missing:
   
   - The default behaviour when moving to the beginning / end of the
     buffer is to treat it like a normal buffer, instead I wanted to
     move to the first / last line in the file list. I found these
     code snippets code snippets from a file called [[https://www.emacswiki.org/emacs/dired-extension.el][dired-extension]]
     that was posted in emacswiki.
   - The default behaviour when marking a file is to mark and move
     forward. This makes it really easy to mark a bunch of consecutive
     files. But what about in reverse? Let's define a function to do
     exactly that!
   - The ability to kill lines of a dired buffer so that you can
     narrow down the files you're working on is very useful. More
     useful is to be able to do it on a selection of files.
   - After I started using emacs as my mail client, I thought it would
     be great to use dired to attach files to an email. Apparently
     someone else also thought about this in [[https://emacs.stackexchange.com/questions/14652/attach-multiple-files-from-the-same-directory-to-an-email-message][this]] question in
     stackexchange. This is the provided function, with the ability to
     attach all marked files. /NOTE: this does not always work as
     intended, and anyways I don't use it as much. It is worth
     checking out however./

   #+begin_src emacs-lisp
   (use-package emacs
     :config
     ;; go to first / last file line
     (defun dired-goto-first-file ()
	  "Move cursor to first file of dired."
	  (interactive)
	  (goto-char (point-min))
	  (while (not (dired-move-to-filename))
	    (call-interactively 'dired-next-line)))

     (defun dired-goto-last-file ()
       "Move cursor to last file of dired."
       (interactive)
       (goto-char (point-max))
       (while (not (dired-move-to-filename))
	 (call-interactively 'dired-previous-line)))

     ;; mark and move backwards
     (defun l/dired-mark-backwards ()
       "Mark file at point and move backwards."
       (interactive)
       (if (dired-move-to-filename)
	   (progn
	     (dired-mark 1)
	     (dired-previous-line 2))))

     ;; narrow to marked files
     (defun l/dired-narrow-to-marked-files ()
       "Show only marked files in dired buffer."
       (interactive)
       (let ((files (dired-get-marked-files)))
	 (unless (eq (length files) 1)
	   (dired-toggle-marks)
	   (dired-do-kill-lines))))

     ;; attach marked files to email
     (defun compose-attach-marked-files ()
       "Compose mail and attach all the marked files from a dired
   buffer."
       (interactive)
       (let ((files (dired-get-marked-files)))
	 (compose-mail nil nil nil t)
	 (dolist (file files)
	   (if (file-regular-p file)
	       (mml-attach-file file
				(mm-default-file-encoding file)
				nil "attachment")
	     (message "skipping non-regular file %s" file))))))
   #+end_src

** Sorting functions

   Although the use of ls switches can be very useful for diferent
   sorting options, dired by default does not provide this kind of
   functionality. Here I define some functions to switch between
   sorting by name, by date, by size, by extension, and grouping of
   directories first as a toggle on top of the other switches.

   #+begin_src emacs-lisp
   (use-package dired
     :config
     ;; sort by
     (defun l/dired-sort-by (sw)
       "Sort dired buffer by given switches and go to first line. If
   the switches provided are the same with the current switches, do
   nothing"
       (let ((switches dired-actual-switches))
	 (unless (string= sw switches)
	   (dired-sort-other sw)
	   (dired-goto-first-file))))
  
     ;; callable functions
     ;; by name
     (defun l/dired-sort-by-name ()
       "Sort by name. Calls `l/dired-sort-by'."
       (interactive)
       (l/dired-sort-by "-Alh"))
  
     ;; by date
     (defun l/dired-sort-by-date ()
       "Sort by date. Calls `l/dired-sort-by'."
       (interactive)
       (l/dired-sort-by "-Alht"))
  
     ;; by size
     (defun l/dired-sort-by-size ()
       "Sort by size. Calls `l/dired-sort-by'."
       (interactive)
       (l/dired-sort-by "-AlhS"))
  
     ;; by extension
     (defun l/dired-sort-by-ext ()
       "Sort by extension. Calls `l/dired-sort-by'."
       (interactive)
       (l/dired-sort-by "-AlhX"))
  
     ;; toggle directories first
     (defun l/dired-sort-dirs-first ()
       "Toggles grouping directories first."
       (interactive)
       (let ((switches dired-actual-switches))
	 (if (string-match-p (regexp-quote " --group-directories-first") switches)
	     (setq switches (replace-regexp-in-string " --group-directories-first" "" switches))
	   (setq switches (concat switches " --group-directories-first")))
	 (dired-sort-other switches))
       (dired-goto-first-file)))
   #+end_src

** External programs

  Definitions of some "external" functions. These are functions that
  act on files or lists of files using some external tool. Those
  include:

  - dired-get-size: calls du and outputs the size on the minibuffer. I
    got this from [[https://www.emacswiki.org/emacs/dired-extension.el][this]] post on emacswiki, from the same package called
    dired-extension mentioned previously. I also left the chinese text
    inside!
  - l/unmount-drive: if called on a mountpoint, it unmounts the drive
    mounted there. Really simple function, as I rarely use it, and
    only for this, quickly unmount a drive if I am already there.
  - l/atool-pack and unpack: atool is a script for managing file
    archives. I tried the existing [[https://github.com/HKey/dired-atool][dired-atool]] package from github,
    but I didn't like it, so I wrote my own functions with modified
    code from this project. I prefered something simpler and with nice
    output.
  - l/get-subtitles: uses sublime, a command-line tool to download
    subtitles written in python. Although the implementation is mine,
    I got some basic ideas from [[http://ergoemacs.org/emacs/elisp_call_shell_command.html][this post about 'start-process']] on
    ergoemacs and [[https://stackoverflow.com/questions/17075920/passing-list-to-rest-args?rq=1][this one about 'apply']] on stackoverflow.
  - l/change-desktop-background: uses feh, a minimal image viewer, to
    set the desktop background with the file at point. Provides a menu
    with different fits.
    
  #+begin_src emacs-lisp
  (use-package dired
    :config
    ;; get filesize
    (defun dired-get-size ()
      "Get total size of marked files with `du' command.
       If not marked any files, default is current file or directory."
      (interactive)
      (let ((files (dired-get-marked-files)))
	(with-temp-buffer
	  (apply 'call-process "/usr/bin/du" nil t nil "-sch" files)
	  (message "%s"
		   (progn
		     (re-search-backward "\\(^[0-9.,]+[A-Za-z]+\\).*\\(total\\|总用量\\)$")
		     (match-string 1))))))

    ;; unmount drive from mountpoint
    (defun l/unmount-drive ()
      "Unmount selected directories, if they correspond to mountpoints."
      (interactive)
      (let ((dirs (dired-get-marked-files)))
	(dired-do-shell-command "mountpoint -q ? && sudo umount ? && sudo rmdir ?" nil dirs)
	(revert-buffer)))

    ;; pack and unpack
    (defun l/atool-pack ()
      "Use the `atool' program to pack some files."
      (interactive)
      (when (eq major-mode 'dired-mode)
	(let ((files (dired-get-marked-files t))
	      (archive (expand-file-name
			(read-file-name "Pack files as:" nil nil nil)))
	      (process-connection-type nil))
	  (if (get-buffer "*atool-pack*")
	      (kill-buffer "*atool-pack*"))
	  (apply 'start-process
		 (append (list "atool-pack" "*atool-pack*" "atool" "--explain" archive "-a") files))
	  (switch-to-buffer-other-window "*atool-pack*")
	  (special-mode))))
  
    (defun l/atool-unpack ()
      "Use the `atool' program to unpack some archives."
      (interactive)
      (when (eq major-mode 'dired-mode)
	(let ((files (dired-get-marked-files t))
	      (dest (expand-file-name
		     (read-directory-name "Unpack files to:"
					  (dired-dwim-target-directory) nil nil)))
	      (process-connection-type nil))
	  (if (get-buffer "*atool-unpack*")
	      (kill-buffer "*atool-unpack*"))
	  (if (not (file-directory-p dest))
	      (make-directory dest))
	  (apply 'start-process
		 (append (list "atool-unpack" "*atool-unpack*" "atool" "--explain" "-X" dest) files))
	  (switch-to-buffer-other-window "*atool-unpack*")
	  (special-mode))))

    ;; get subtitles
    (defun l/get-subtitles ()
      "Get subtitles for marked files while in a dired buffer. Depends on subliminal, so it has to be on your system."
      (interactive)
      (when (eq major-mode 'dired-mode)
	(let* ((lang-list '("en" "gr"))
	       (lang (completing-read "Select language: " lang-list nil t))
	       (files (dired-get-marked-files))
	       (process-connection-type nil))
	  (if (get-buffer "*get-subtitles*")
	      (kill-buffer "*get-subtitles*"))
	  (apply 'start-process
		 (append (list "get-subtitles" "*get-subtitles*" "subliminal" "download" "-l" lang) files))
	  (switch-to-buffer-other-window "*get-subtitles*")
	  (special-mode))))

    ;; change desktop background
    (defun l/change-desktop-background ()
      "Change the desktop background using feh."
      (interactive)
      (let ((fit-type (completing-read "Select fit: " '("scale" "center" "fill" "max") nil t))
	    (entry (shell-quote-argument (expand-file-name (dired-file-name-at-point))))
	    (targetfile (shell-quote-argument (expand-file-name "~/.config/.wallpaper.jpg"))))
	(setq cpcmd (concat "cp " entry " " targetfile))
	(setq fehcmd (concat "feh --bg-" fit-type " " targetfile))
	(setq cmd (concat cpcmd " && " fehcmd))
	(shell-command cmd))))
  #+end_src
  
** Custom maps

   Here are declared two prefix commands with their bindings:

   - l/dired-nav-map offers ranger-like shortcuts to directories.
   - l/dired-my-ext-cmds includes keybindings for the functions that
     call external programs.

   #+begin_src emacs-lisp
   (use-package dired
     :config
     ;; navigation map
     (define-prefix-command 'l/dired-nav-map)

     (general-def l/dired-nav-map
       "h" (lambda () (interactive) (dired "~/"))
       "D" (lambda () (interactive) (dired "~/Downloads/"))
       "d" (lambda () (interactive) (dired "~/Documents/"))
       "p" (lambda () (interactive) (dired "~/Pictures/")) 
       "M" (lambda () (interactive) (dired "~/Music/"))  
       "v" (lambda () (interactive) (dired "~/Videos/"))   
       "m" (lambda () (interactive) (dired "/media"))    
       "C" (lambda () (interactive) (dired "~/.config/"))  
       "E" (lambda () (interactive) (dired "~/.emacs.d/")) 
       "!" (lambda () (interactive) (dired "~/dotfiles/"))
       "g" 'dired-goto-first-file)

     ;; my external commands
     (define-prefix-command 'l/dired-my-ext-cmds)

     (general-def l/dired-my-ext-cmds
       "s" 'l/get-subtitles
       "?" 'dired-get-size
       "B" 'l/change-desktop-background
       "u" 'l/unmount-drive
       "zz" 'l/atool-pack
       "zx" 'l/atool-unpack)
   #+end_src

** Keybindings

   In this section I define all the keybindings for dired. The list is
   long...

   #+begin_src emacs-lisp
   (use-package dired
     :config
     (general-def 'dired-mode-map
       "G" 'revert-buffer
       "g" 'l/dired-nav-map
       "C-x M-." 'compose-attach-marked-files
       "M-<" 'dired-goto-first-file
       "M->" 'dired-goto-last-file)

     (general-def 'normal dired-mode-map
       "q" 'quit-window
       ;; basic movement
       "j" 'dired-next-line
       "k" 'dired-previous-line
       "h" 'dired-up-directory
       "l" 'dired-find-file
       ">" 'dired-next-dirline
       "<" 'dired-prev-dirline
       ;; here should be "gg" 'dired-goto-first-file, but it is in the
       ;; nav-map
       "G" 'dired-goto-last-file
       ;; basic functions
       "A" 'dired-do-find-regexp
       "B" 'dired-do-byte-compile
       "C" 'dired-do-copy
       "D" 'dired-do-delete
       ;; dired-do-chgrp
       "H" 'dired-do-hardlink
       "L" 'dired-do-load
       "M" 'dired-do-chmod
       "O" 'dired-do-chown
       "P" 'dired-do-print
       "Q" 'dired-do-find-regexp-and-replace
       "R" 'dired-do-rename
       "S" 'dired-do-symlink
       "T" 'dired-do-touch
       "Z" 'dired-do-compress
       "c" 'dired-do-compress-to
       "!" 'dired-do-shell-command
       "&" 'dired-do-async-shell-command
       "=" 'dired-diff
       ;; regexp operations
       "%" nil ;; prefix
       "%u" 'dired-upcase
       "%l" 'dired-downcase
       "%d" 'dired-flag-files-regexp
       "%g" 'dired-mark-files-containing-regexp
       "%m" 'dired-mark-files-regexp
       "%C" 'dired-do-copy-regexp
       "%H" 'dired-do-hardlink-regexp
       "%R" 'dired-do-rename-regexp
       "%S" 'dired-do-symlink-regexp
       "%&" 'dired-flag-garbage-files
       ;; marks & flags
       "U" 'dired-unmark-all-marks
       "u" 'dired-unmark
       "m" 'dired-mark
       (kbd "<SPC>") 'dired-mark
       (kbd "C-<SPC>") 'l/dired-mark-backwards
       "t" 'dired-toggle-marks
       "d" 'dired-flag-file-deletion
       "x" 'dired-do-flagged-delete
       (kbd "* <delete>") 'dired-unmark-backward
       (kbd "<delete>") 'dired-unmark-backward
       "*" nil ;; prefix
       "**" 'dired-mark-executables
       "*/" 'dired-mark-directories
       "*@" 'dired-mark-symlinks
       "*%" 'dired-mark-files-regexp
       "*(" 'dired-mark-sexp
       "*." 'dired-mark-extension
       "*O" 'dired-mark-omitted
       "*c" 'dired-change-marks
       "*s" 'dired-mark-subdir-files
       "*?" 'dired-unmark-all-files
       "*!" 'dired-unmark-all-marks
       "*f" 'l/dired-narrow-to-marked-files
       ;; encryption-decryption (epa-dired)
       ";d" 'epa-dired-do-decrypt
       ";v" 'epa-dired-do-verify
       ";s" 'epa-dired-do-sign
       ";e" 'epa-dired-do-encrypt
       ;; unsorted
       "X" 'l/dired-my-ext-cmds
       "z" 'dired-omit-mode
       "g" 'l/dired-nav-map
       "gr" 'revert-buffer
       "gR" 'dired-do-redisplay
       "I" 'dired-maybe-insert-subdir
       "i" 'dired-toggle-read-only
       "J" 'dired-goto-file
       "K" 'dired-do-kill-lines
       "a" 'dired-find-alternate-file
       "gy" 'dired-show-file-type
       "Y" 'dired-copy-filename-as-kill
       "+" 'dired-create-directory
       (kbd "S-<return>") 'dired-find-file-other-window
       (kbd "RET") 'dired-find-file
       (kbd "M-<return>") 'browse-url-of-dired-file
       ;; sorting
       "o" nil ;; prefix -- was dired-sort-toggle-or-edit
       "oo" 'l/dired-sort-by-name
       "od" 'l/dired-sort-by-date
       "os" 'l/dired-sort-by-size
       "ox" 'l/dired-sort-by-ext
       "o=" 'l/dired-sort-dirs-first
       "(" 'dired-hide-details-mode
       "?" 'dired-summary))

   (add-hook 'dired-mode-hook 'evil-normalize-keymaps))

   #+end_src

** Dired-x

   Dired-X provides some extra functionality for dired.

   For now, I use it only for the omit-mode that it offers, which
   hides non-interesting files by regexp or by extension.

   However, there are other useful features which I should check, like
   shell command guessing.

   #+begin_src emacs-lisp
   (use-package dired-x
     :delight dired-omit-mode
     :after dired
     :bind
     (:map dired-mode-map
	   ("z" . 'dired-omit-mode))
     :init
     (setq dired-omit-verbose nil)
     :config
     ;; files to be ommited: beginning with one or more dots, beginning with $ (some files that come from Windows), ending with xmp (eg darktable data files), ending with srt, sub (I don't want to see subtitle files)
     (setq dired-omit-files (concat dired-omit-files "\\|^\\..+$\\|^\\$"))
     (setq dired-omit-extensions
	   (append dired-omit-extensions '("xmp" "srt" "sub")))

     (add-hook 'dired-mode-hook 'dired-omit-mode))
   #+end_src

** Wdired

   Wdired (Writable dired) is a way to manipulate the file listing
   like a text file. This means super-easy renaming.

   #+begin_src emacs-lisp
   (use-package wdired
     :after dired)
   #+end_src

** Image dired

   Image dired provides functionality to view images in emacs. Nothing too fancy, just some sane defaults.

   #+begin_src emacs-lisp
   (use-package image-dired
     :after dired
     :init
     (setq image-dired-thumb-width 250)
     (setq image-dired-thumbs-per-row 4)
     (setq image-dired-external-viewer "sxiv"))
   #+end_src

** Peep dired

   Peep dired is a minor mode for dired which offers a preview of the file at point on another window. Very useful. It provides an experience similar to file managers like Ranger.

   However, some features where missing imho, also some functions
   caused abnormal behaviour. So, I cloned the project from the
   [[https://github.com/asok/peep-dired][original repo]], tweaked it, added some extra functions and run it...
   It still needs maintenance, some stuff should be reimplemented, but
   it will do for now. My fork can be found [[https://github.com/dakodeon/peep-dired][here]].

   #+begin_src emacs-lisp
   (use-package peep-dired
     :load-path "~/.source/peep-dired"
     :delight (peep-dired " ")
     :after dired
     :init
     (setq peep-dired-cleanup-eagerly t)
     (setq peep-dired-ignored-extensions '("mkv" "mp4" "avi" "mov" "mp3" "wav" "iso"))
     :config
     ;; custom dired functions customized further for peep. Maybe use advice?
     (defun l/peep-dired-goto-first-file ()
       "Go to first file line and peep there. Uses `dired-goto-first-file'"
       (interactive)
       (dired-goto-first-file)
       (peep-dired-display-file-other-window))
  
     (defun l/peep-dired-goto-last-file ()
       "Go to last file line and peep there. Uses `dired-goto-last-file'"
       (interactive)
       (dired-goto-last-file)
       (peep-dired-display-file-other-window))
  
     (defun l/peep-dired-mark-backwards ()
       "Mark and peep backwards."
       (interactive)
       (l/dired-mark-backwards)
       (peep-dired-display-file-other-window))
  
     ;; evil bindings
     (general-def 'normal peep-dired-mode-map
       "C-j" 'peep-dired-scroll-page-down
       "C-k" 'peep-dired-scroll-page-up
       "j" 'peep-dired-next-file
       "<down>" 'peep-dired-next-file
       "k" 'peep-dired-prev-file
       "<up>" 'peep-dired-prev-file
       "h" 'peep-dired-up-directory
       "<left>" 'peep-dired-up-directory
       "l" 'peep-dired-find-file
       "<right>" 'peep-dired-find-file
       ">" 'peep-dired-next-dirline
       "<" 'peep-dired-prev-dirline
       "g g" 'l/peep-dired-goto-first-file
       "G" 'l/peep-dired-goto-last-file
       "C-SPC" 'l/peep-dired-mark-backwards)
     (general-def 'normal dired-mode-map
       "p" 'peep-dired)

     (add-hook 'peep-dired-hook 'evil-normalize-keymaps)
     :bind
     (:map dired-mode-map
	   ("p" . 'peep-dired)))

   #+end_src

** Some extra pieces of functionality

   Here are some packages that offer a little bit of extra
   functionality. Small things really, but they make a better
   experience.

*** Dired subtree

    This package makes directories open in the same buffer like
    subtrees.

    #+begin_src emacs-lisp
    (use-package dired-subtree
      :ensure t
      :after dired
      :config
      (general-def 'normal dired-mode-map
	"TAB" 'dired-subtree-toggle))
    #+end_src

*** Dired narrow

    Narrows down what is shown in the dired buffer by filtering
    filenames. Really useful for quickly finding something.

    #+begin_src emacs-lisp
    (use-package dired-narrow
      :ensure t
      :delight (dired-narrow-mode " >⋅<")
      :after dired
      :init
      (setq dired-narrow-exit-when-one-left t)
      :config
      (general-def 'normal dired-mode-map
	"f" 'dired-narrow)
      :bind
      (:map dired-mode-map
	    ("f" . 'dired-narrow)))
    #+end_src

*** Dired ranger

    Dired-ranger ports some of the functionality from the ranger file
    manager. Specifically it implements the copying/moving mechanism
    and the bookmark mechanism.

    The way it handles copying and moving can be useful from time to
    time. Instead of knowing beforehand where you want to put the
    file, you can perform the 'yank' and then paste it in whichever
    directory you want.

    Bookmarks is also a useful feature for quick navigation. You can
    quickly set and visit a bookmark, while a custom function that I
    wrote, handles moving to the last visited place. Note that these
    bookmarks are not persistent, they will be lost upon exiting
    emacs.

    #+begin_src emacs-lisp
    (use-package dired-ranger
      :ensure t
      :after dired
      :init
      (setq dired-ranger-bookmark-reopen 'always)
      :config
      ;; function to visit previous directory
      (defun l/dired-ranger-bookmark-visit-LRU ()
	"Go to last visited directory."
	(interactive)
	(dired-ranger-bookmark-visit dired-ranger-bookmark-LRU))

      ;; evil keybindings
      (general-def 'normal dired-mode-map
	"y" nil ;; prefix
	"yy" 'dired-ranger-copy
	"yP" 'dired-ranger-move
	"yp" 'dired-ranger-paste
	"`" nil ;; prefix
	"``" 'l/dired-ranger-bookmark-visit-LRU
	"`v" 'dired-ranger-bookmark-visit
	"`m" 'dired-ranger-bookmark))
    #+end_src

*** Dired rsync
    
    Rsync functionality for dired. Really useful for BIG files, as it does not freeze emacs while busy. Progress is also shown in the modeline.

One note though, while trying to copy to a FAT32 device, I discovered that there is some problem concerning the permissions. This has nothing to do with dired or emacs, it is a rsync thing. The workaround is to choose different flags for the rsync command, so I wrote a function to do this.

    #+begin_src emacs-lisp
    (use-package dired-rsync
      :ensure t
      :after dired
      :init
      (setq dired-rsync-unmark-on-completion nil)
      :config
      ;; workaround to rsync into FAT32
      (defun l/dired-rsync-to-FAT32 ()
	"Change `dired-rsync-options' temporarily to rsync to FAT32 driver."
	(interactive)
	(let ((dired-rsync-options "-rDz --info=progress2")
	      (dest (read-file-name "rsync to: " (dired-dwim-target-directory)
			      nil nil nil 'file-directory-p)))
	  (dired-rsync dest)))

      ;; evil keybindings
      (general-def 'normal dired-mode-map
	"rr" 'dired-rsync
	"rf" 'l/dired-rsync-to-FAT32))
    #+end_src

** Some bling!

   This section is all about the looks!

*** Dired rainbow

    Colors the output of dired. Haven't tweaked anything, this is just
    the defaults from the github page.

    #+begin_src emacs-lisp
    (use-package dired-rainbow
      :ensure t
      :after dired
      :config
      (progn
	(dired-rainbow-define-chmod directory "#6cb2eb" "d.*")
	(dired-rainbow-define html "#eb5286" ("css" "less" "sass" "scss" "htm" "html" "jhtm" "mht" "eml" "mustache" "xhtml"))
	(dired-rainbow-define xml "#f2d024" ("xml" "xsd" "xsl" "xslt" "wsdl" "bib" "json" "msg" "pgn" "rss" "yaml" "yml" "rdata"))
	(dired-rainbow-define document "#9561e2" ("docm" "doc" "docx" "odb" "odt" "pdb" "pdf" "ps" "rtf" "djvu" "epub" "odp" "ppt" "pptx"))
	(dired-rainbow-define markdown "#ffed4a" ("org" "etx" "info" "markdown" "md" "mkd" "nfo" "pod" "rst" "tex" "textfile" "txt"))
	(dired-rainbow-define database "#6574cd" ("xlsx" "xls" "csv" "accdb" "db" "mdb" "sqlite" "nc"))
	(dired-rainbow-define media "#de751f" ("mp3" "mp4" "MP3" "MP4" "avi" "mpeg" "mpg" "flv" "ogg" "mov" "mid" "midi" "wav" "aiff" "flac"))
	(dired-rainbow-define image "#f66d9b" ("tiff" "tif" "cdr" "gif" "ico" "jpeg" "jpg" "png" "psd" "eps" "svg"))
	(dired-rainbow-define log "#c17d11" ("log"))
	(dired-rainbow-define shell "#f6993f" ("awk" "bash" "bat" "sed" "sh" "zsh" "vim"))
	(dired-rainbow-define interpreted "#38c172" ("py" "ipynb" "rb" "pl" "t" "msql" "mysql" "pgsql" "sql" "r" "clj" "cljs" "scala" "js"))
	(dired-rainbow-define compiled "#4dc0b5" ("asm" "cl" "lisp" "el" "c" "h" "c++" "h++" "hpp" "hxx" "m" "cc" "cs" "cp" "cpp" "go" "f" "for" "ftn" "f90" "f95" "f03" "f08" "s" "rs" "hi" "hs" "pyc" ".java"))
	(dired-rainbow-define executable "#8cc4ff" ("exe" "msi"))
	(dired-rainbow-define compressed "#51d88a" ("7z" "zip" "bz2" "tgz" "txz" "gz" "xz" "z" "Z" "jar" "war" "ear" "rar" "sar" "xpi" "apk" "xz" "tar"))
	(dired-rainbow-define packaged "#faad63" ("deb" "rpm" "apk" "jad" "jar" "cab" "pak" "pk3" "vdf" "vpk" "bsp"))
	(dired-rainbow-define encrypted "#ffed4a" ("gpg" "pgp" "asc" "bfe" "enc" "signature" "sig" "p12" "pem"))
	(dired-rainbow-define fonts "#6cb2eb" ("afm" "fon" "fnt" "pfb" "pfm" "ttf" "otf"))
	(dired-rainbow-define partition "#e3342f" ("dmg" "iso" "bin" "nrg" "qcow" "toast" "vcd" "vmdk" "bak"))
	(dired-rainbow-define vc "#0074d9" ("git" "gitignore" "gitattributes" "gitmodules"))
	(dired-rainbow-define-chmod executable-unix "#38c172" "-.*x.*")
	))
    #+end_src

*** Dired icons

    Adds icons in front of file names. Always good to have! Depends on
    the all-the-icons package, which is loaded later in the config.

    #+begin_src emacs-lisp
    (use-package all-the-icons-dired
      :ensure t
      :delight
      :after dired all-the-icons
      :config
      (add-hook 'dired-mode-hook 'all-the-icons-dired-mode))
    #+end_src
    
** TODO TODO list [0/2]

*** TODO Fix/organize keybindings [0/3]

    This implementation is a massive improvement, but my keybindings
    are still all over the place.
    
**** TODO Evil-collection dired bindings

     See [[TODO Dired evil collection][this]] similar concern on evil-collection.

**** TODO More custom keymaps

     One point of improvement could be the definition of custom maps
     for various collections of bindings, for example the sorting
     functions.

**** TODO Keys in the wrong place

     Specifically this: I have bound my custom map for navigation
     under the "g" key. Also, under the "g" key is the command to move
     on the top of the file ("gg"), but it doesn't belong in this map.
     Find a way to fix this.

*** TODO Some more external functions

    Like my mp3-rename-script

* EMAIL CLIENT

  I use mu4e to manage my emails. mu4e is the emacs front-end for the
  program 'mu' so installing mu on your system brings also mu4e.
  Depending on your system, you might have to build it yourself, e.g
  from git. Then, find the path of mu4e and add it to load-path (in my
  case it was =/usr/local/share/emacs/site-lisp/mu4e=).

** The layout
*** Parts and components

    Mu4e only manages your emails. You actually need to install a
    different program to download them and store them to your
    computer. The most popular alternatives are [[https://www.offlineimap.org/][offlineimap]] and [[http://isync.sourceforge.net/][isync]]
    (which provides the executable mbsync). I use the latter. Sending
    email is also provided by a different package: the smtp and
    message packages that are bult-in within emacs.
  
    So: the steps to manage and send emails through emacs are:

    1. mbsync downloads the emails
    2. mu updates the maildirs
    3. smtp establishes connection with your email provider
    4. message composes and sends the actual email
    5. mu4e is used as a platform integrating all of the above

    _Discalimer:_ I do not understand fully all the mechanics involved
    here, so the above explanation might be from over-simplified to
    dead-wrong. However, it works, thanks to all the resources existing
    on the Internet.

    There is separate configuration required for mbsync. It is out of
    the scope of this description, so I will not go into it. There are a
    lot of sample configurations and instructions on the web, as well as
    a well-documented [[https://wiki.archlinux.org/index.php/Isync][archwiki article]]. However, configuring mbsync can
    be a headache. Best of luck!

*** Some info about my config

    Mu4e gives the ability to set an interval on which it's database
    updates. I set this to nil, as I prefer to have a cronjob taking
    care of that. I have set the interval to be 5 minutes. Updating
    while on mu4e happens only manually.

    Another thing to note is that I don't keep all my email info in
    this file. I use a separate file, which is required in the
    configuration, which provides a variable storing a list of all the
    accounts' information that mu4e needs to build te contexts,
    maildir structure etc. This is not about security, I wouldn't
    store passwords and stuff even to this file, it just seems more
    appropriate not to share all my email addresses in a public file.
    It also makes the config more portable, as you can easily
    implement the same file, a sample of which can be seen below:

    #+begin_example emacs-lisp
    (defvar l/accounts-info-list
      '(("account-name-1" . ((mail-addr . "my-name@my-provider.com")
			     (smtp-serv-def . "mail.my-provider.com")
			     (smtp-serv . "mail.my-provider.com")
			     (full-name . "my name")
			     (inbox-dir . ("/account-name-1/Inbox" . ?1))
			     (sent-dir . "/account-name-1/Sent")
			     (drafts-dir . "/account-name-1/Drafts")
			     (trash-dir . "/account-name-1/Trash")))
	("account-name-2" . ((mail-addr . "my-other-name@my-other-provider.com")
			     (smtp-serv-def . "smtp.my-other-provider.com")
			     (smtp-serv . "smtp.my-other-provider.com")
			     (full-name . "my other name")
			     (inbox-dir . ("/account-name-2/Inbox" . ?2))
			     (sent-dir . "/account-name-2/Sent")
			     (drafts-dir . "/account-name-2/Drafts")
			     (trash-dir . "/account-name-2/Trash")))))

    ;; don't forget to provide the code in the end of the file!
    (provide 'mu4e-sensitive)
    #+end_example

    Then, the location of this file should be added to load-path.

** The actual config
*** SMTP configuration

    SMTP handles the connection with your email provider. It also sets some values for the default email account.

    #+begin_src emacs-lisp
    (use-package smtpmail
      :config
      ;; since smtpmail is loaded first we will require here the sensitive file
      (add-to-list 'load-path "~/.personal/personal-scripts")
      (require 'mu4e-sensitive)
      ;; the default value is considered to be the first account on the list
      (let ((first-account (cdr (nth 0 l/accounts-info-list))))
	(setq smtpmail-smtp-user (cdr (assq 'mail-addr first-account))
	      smtpmail-default-smtp-server (cdr (assq 'smtp-serv-def first-account))
	      smtpmail-smtp-server (cdr (assq 'smtp-serv first-account))))

      ;; these seem to be default everywhere
      (setq smtpmail-stream-type 'starttls
	    smtpmail-smtp-service 587
	    smtpmail-debug-info t))
    #+end_src

*** Message configuration

    Message is the package that does the actual editing of an email
    message. It is configured to use smtpmail to actually send it.

    #+begin_src emacs-lisp
    (use-package message
      :after smtpmail
      :config
      (setq message-send-mail-function 'smtpmail-send-it)
      (setq message-kill-buffer-on-exit t))
    #+end_src
    
*** Mu4e -- base settings

    The 'main course'. If it goes all together it will be a very big
    code block, so I will brake it into several categories.

    Here are the basic settings.

    #+begin_src emacs-lisp
    (use-package mu4e
      :load-path "/usr/local/share/emacs/site-lisp/mu4e"
      :after message
      :init
      (setq mu4e-get-mail-command "mbsync -c ~/.config/mbsyncrc -a" ;; mbsync with custom config location
	    mu4e-maildir (expand-file-name "~/.personal/Mail")
	    mu4e-org-contacts-file "~/.personal/contacts.org"
	    mu4e-update-interval nil ;; cronjob takes care of this
	    mu4e-confirm-quit nil
	    mu4e-index-update-in-background t
	    mu4e-hide-index-messages t
	    mu4e-sent-messages-behavior 'sent
	    mu4e-change-filenames-when-moving t
	    mu4e-attachment-dir "~/Downloads"
	    mu4e-html2text-command "w3m -T text/html"
	    mu4e-headers-auto-update t
	    mu4e-headers-include-related nil
	    mu4e-headers-visible-columns 60
	    mu4e-split-view 'vertical
	    mu4e-view-show-addresses t
	    mu4e-compose-dont-reply-to-self nil
	    mu4e-compose-signature-auto-include nil
	    mu4e-context-policy 'pick-first)

      ;; this one does not work out of the box. Emacs needs to be compiled with imagemagick support. Will look into this
      (setq mu4e-show-images t)
      (when (fboundp 'imagemagick-register-types)
	(imagemagick-register-types))

      :config
      (setq mail-user-agent 'mu4e-user-agent)
      :bind
      ("C-x m" . 'mu4e))
    #+end_src

*** Mu4e -- accounts, maildirs and contexts

    In this section, the multiple account structure is established, by
    using the sensitive info file defined earlier. First, the users
    personal email list is built, then the shortcuts for the various
    Inboxes and finally the contexts' definitions.

    Note how portable this is: you can have 2 or 12 email accounts and
    this code will not change. However, also note that only shortcuts
    for the Inboxes are provided. This is to minimize the information
    stored in the info list. Maybe in the future I will come up with a
    better implementation.

    The code is kinda convoluted though... Defining contexts that way
    was a headache, so I am very happy to have figured it out.

    #+begin_src emacs-lisp
    (use-package mu4e
      :config
      ;; building the user's mail address list
      (setq mu4e-user-mail-address-list
	    (mapcar (lambda (entry) (cdr (assq 'mail-addr (cdr entry))))
		    l/accounts-info-list))

      ;; setting up default directories to the first account's directories
      ;; -- just a failsafe, this is normally handled by contexts
      (let ((first-account (cdr (nth 0 l/accounts-info-list))))
	(setq mu4e-drafts-folder (cdr (assq 'drafts-dir first-account))
	      mu4e-sent-folder (cdr (assq 'sent-dir first-account))
	      mu4e-trash-folder (cdr (assq 'trash-dir first-account))))

      ;; setting up shortcuts for the Inboxes
      (setq mu4e-maildir-shortcuts
	    (mapcar (lambda (entry) (cdr (assq 'inbox-dir (cdr entry))))
		    l/accounts-info-list))

      ;; build contexts
      (cl-loop for entry in l/accounts-info-list do
	       (let* ((name (car entry))
		      (info (cdr entry))
		      (mymail (cdr (assq 'mail-addr info)))
		      (fullname (cdr (assq 'full-name info)))
		      (smtpdef (cdr (assq 'smtp-serv-def info)))
		      (smtpserv (cdr (assq 'smtp-serv info)))
		      (mysent (cdr (assq 'sent-dir info)))
		      (mydrafts (cdr (assq 'drafts-dir info)))
		      (mytrash (cdr (assq 'trash-dir info)))
		      (matchfunc `(lambda (msg)
				    (when msg
				      (mu4e-message-contact-field-matches msg :to ,mymail))))
		      (myvars `((smtpmail-smtp-user . ,mymail)
				(smtpmail-default-smtp-server . ,smtpdef)
				(smtpmail-smtp-server . ,smtpserv)
				(user-mail-address . ,mymail)
				(user-full-name . ,fullname)
				(mu4e-sent-folder . ,mysent)
				(mu4e-drafts-folder . ,mydrafts)
				(mu4e-trash-folder . ,mytrash))))
		 (add-to-list 'mu4e-contexts (make-mu4e-context
					      :name name
					      :match-func matchfunc
					      :vars myvars) t))))
    #+end_src

*** Mu4e -- bookmarks and queries

    In mu4e, when you want to find an email, you perform a search
    query. You rarely go in your inbox folder and start scrolling
    around. As for the queries that you run most of the time, you can
    define them as bookmarks. Bookmarks in mu4e are pre-defined
    queries, callable with a keybinding.

   Mu4e provides some default bookmarks, the most common one to be
   unread messages, but they are not all useful. So I defined my own
   list:

   1. Unread messages -- by default
   2. Today's messages -- by default
   3. Messages from the last x days, where x is set interactively --
      this one is based on an example in the manual. I changed some
      things to integrate it with my various contexts.

   There was another query that I wanted to have as a bookmark, but I
   could not, due to some internals of the bookmarks' definition
   process. This is the ability to re-visit the last received message.
   So, the function that perform this specific query is callable from
   outside the bookmarks' scope.

   Another useful feature is to be able to perform a query for unread
   messages globally, meaning outside of mu4e. That way we can quickly
   jump to unread messages directly upon receiving an email. This is
   useful to be implemented system-wise.

   To facilitate definitions of queries that span through all
   different contexts, a variable holding a list of inboxes is also
   defined here.

   #+begin_src emacs-lisp
   (use-package mu4e
     :config
     ;; TODO - rewrite this variable using my custom list. In the end it will contain inboxes
     (defvar l/mu4e-context-names
       (mapcar (lambda (x) (car x))
	       (cl-map 'list (lambda (context)
			       (cons (mu4e-context-name context) context))
		       mu4e-contexts)))

     ;; get only the last received message
     (defun l/mu4e-fetch-last-received-msg ()
       "Shows the last received message in mu4e"
       (interactive)
       (let* ((query
	       (string-trim
		(format "%s"
			(mapcar (lambda (x) (concat "maildir:/" x "/Inbox OR "))
				l/mu4e-context-names)) "(" " OR )")))
	 (mu4e-headers-search
	  (concat "msgid:" (string-trim (shell-command-to-string (concat "mu find -n 1 --fields \"i\" --sortfield=date --reverse " query)) nil "\n")))))

     ;; Asks for how many days' messages to show -- from the manual, edited
     (defun l/mu4e-bookmark-num-days-old-query (days-old)
       (interactive (list (read-number "How many days? " 2)))
       (let ((start-date (subtract-time (current-time) (days-to-time days-old)))
	     (maildirquery (string-trim (format "%s" (mapcar (lambda (x) (concat "maildir:/" x "/Inbox OR ")) l/mu4e-context-names)) "(" " OR )")))
	 (concat "(" maildirquery ") AND date:"
		 (format-time-string "%Y%m%d" start-date))))

     ;; open unread from wherever
     (defun l/mu4e-open-unread ()
       "Open mu4e in unread messages."
       (interactive)
       (mu4e-headers-search "flag:unread AND NOT flag:trashed"))

     ;; bookmarks list
     (setq mu4e-bookmarks
	   `( ,(make-mu4e-bookmark
		:name "Unread messages"
		:query "flag:unread AND NOT flag:trashed"
		:key ?u)
	      ,(make-mu4e-bookmark
		:name "Today's messages"
		:query "date:today..now"
		:key ?t)
	      ,(make-mu4e-bookmark
		:name "Messages from last [x] days"
		:query (lambda () (call-interactively 'l/mu4e-bookmark-num-days-old-query))
		:key ?w)))    ;; TODO: fetch messages of the last x minutes

     ;; keybindings for the functions defined here --maybe move thos at the end?
     (evil-leader 'normal "m" 'l/mu4e-open-unread)
     (general-def 'normal mu4e-main-mode-map "g'" 'l/mu4e-fetch-last-received-msg)
     (general-def 'normal mu4e-headers-mode-map "g'" 'l/mu4e-fetch-last-received-msg))
   #+end_src
   
*** Mu4e -- actions

    Actions are pre-defined actions you can run on a mail message,
    either in headers view, or while visiting it. Mu4e defines some
    default actions, but you have to load them yourself. You can also
    write your own actions, however I haven't done that yet.

    The actions are defined by adding them in the related association
    list. Then, the actions are callable by pressing the actions
    shortcut ("a") and the first letter of the description associated
    with the action.

    The actions I load for now are:
    - _ViewInBrowser_: opens the message in browser as html
    - _org-contact-add_: adds the message's sender to my org-contacts
      file (for org-contacts see later section.) This action is
      callable both from the headers and from the message views.

    #+begin_src emacs-lisp
    (use-package mu4e
      :config
      (add-to-list 'mu4e-view-actions
		   '("ViewInBrowser" . mu4e-action-view-in-browser) t)
      (add-to-list 'mu4e-view-actions
		   '("org-contacts-add" . mu4e-action-add-org-contact) t)
      (add-to-list 'mu4e-headers-actions
		   '("org-contacts-add" . mu4e-action-add-org-contact) t))


    #+end_src

*** Mu4e -- extra customisation

    Here are some extra pieces of functionality that I put together.

    One is the ability to split the headers view when viewing a
    message according to the current window's dimensions. I have set
    the default to be a vertical split, but, if the window height is
    larger than the window width, then the split will be horizontal.
    This is achieved by advising the 'mu4e-headers-view-message'
    function.
    
    The other is to update my external mail notifications (I use
    i3blocks and dunst for that) by sending the required signal to
    i3blocks. This is run as a hook after updating the index as well
    as when viewing a message (thus disabling the unread flag).

    All other small pieces of functionality that don't really belong
    to any other section will be put here.

    #+begin_src emacs-lisp
    (use-package mu4e
      :config
      ;; split according to window dimensions
      (defun l/mu4e-view-change-split-advice ()
	"Used to advice `mu4e-headers-view-message'.
    Changes the way windows split when viewing a message depending on
    current window size. If height is greater than width, split
    horizontally. Else, split vertically"
	(if (> (window-pixel-height) (window-pixel-width))
	    (setq mu4e-split-view 'horizontal)
	  (setq mu4e-split-view 'vertical)))
  
      (advice-add 'mu4e-headers-view-message
		  :before #'l/mu4e-view-change-split-advice)
  
      ;; update i3blocks notification when updating manually
      (add-hook 'index-updated-hook
		(defun mu4e-signal-i3blocks ()
		  (shell-command "pkill -RTMIN+2 i3blocks")))
  
      ;; also when viewing a message
      (add-hook 'mu4e-view-mode-hook 'mu4e-signal-i3blocks))
    #+end_src


* ORG MODE

  Org mode is a note-taking and organizing framework that does much
  more than that. It can evaluate souce code blocks (see this very
  file), keep track of TODO lists, create and calculate datasheets,
  capture notes on the fly, keep an agenda etc... It is really hard to
  describe all the use cases of org-mode.

  Anyhow, this configuration is really, really basic, I haven't even
  scratched the surface: some sensible defaults, the ensurance of
  'org-plus-contrib' for extra functionality, a little bit of
  capturing etc... We 'll see how this goes.

** Basic configuration

   Defining some defaults. General behaviour etc.
   
   An important thing here is the ensurance of 'org-plus-contrib'.
   This library is not a part of the main org package, but expands
   org-mode in a lot of useful ways.

  #+begin_src emacs-lisp
  (use-package org
    :ensure org-plus-contrib
    :init
    (setq org-directory "~/.personal"
	  org-default-notes-file (concat org-directory "/organizer.org")
	  org-hide-leading-stars t
	  org-special-ctrl-a/e t
	  ;; links
	  org-link-search-must-match-exact-headline nil
	  ;; org src / code blocks
	  org-src-fontify-natively t
	  org-src-tab-acts-natively t
	  org-confirm-babel-evaluate nil
	  org-edit-src-content-indentation 0
	  org-src-window-setup 'current-window)
    :config
    (evil-leader-org
      :keymaps 'org-mode-map
      :states 'normal
      "p" 'org-set-property)
    :bind
    (("C-c l" . org-store-link)))
  #+end_src

** Org TODOs

   TODO lists is something that org does well. Some basic options
   defined here, like time-logging and behaviour for nested TODO
   headlines.

   Also, I pasted a function from the info page: this automates the
   change od the TODO state of a header with TODO children.
   
   All configuration considering clocking and time-management in
   general will be included here as well.

   #+begin_src emacs-lisp
   (use-package org
     :init
     (setq org-log-done 'time
	   org-log-into-drawer 'LOGBOOK
	   org-clock-into-drawer t
	   org-enforce-todo-dependencies t
	   org-enforce-todo-checkbox-dependencies t)
     :config
     ;; This is straight from the configs. I should probably tweak it at some point.
     ;; change todo states when all children todos are done
     (defun org-summary-todo (n-done n-not-done)
       "Switch entry to DONE when all subentries are done, to TODO otherwise."
       (let (org-log-done org-log-states)   ; turn off logging
	 (org-todo (if (= n-not-done 0) "DONE" "TODO"))))
  
     (add-hook 'org-after-todo-statistics-hook 'org-summary-todo)
     :bind
     (("C-c C-x C-z" . org-resolve-clocks)))
   #+end_src

** Org capture

   Org-capture lets you keep notes on the fly in an organized manner,
   and without interrupting your current workflow.

   This is done by pre-defining capture templates, which are then
   assigned to a shortcut key.

   The capture facility uses the 'org-directory' and the
   'org-default-notes-file' to figure out where to store the notes, if
   not specifically stated. These variables are defined in the
   previous section.

   Also, I implemented the idea presented [[https://www.youtube.com/watch?v=gjr9mP01oWE][here]] by Mike Zamansky
   (apparently he got it from somewhere else too, but anyway). It is
   about creating a new frame in org-capture mode and binding it to a
   keybinding on your system. That way you don't have to focus back to
   emacs if you want to take a note, say, while in your browser.
   
   My note-taking skills are bad at best, so I haven't put much stuff in here. I have some defaults that I rarely use, and some templates commented out, that I decided to be not useful, but I keep them for reference.

   My templates include:

   1. Todo: Specify a TODO headline in the default file, under the
      headline "Tasks". -- from the defaults
   2. Journal: A journal entry in the file "journal.org". I rarely use
      this. -- from the defaults
   3. Darkroom log: My darkroom progress notepad. Also logs time.
   4. Rempetika lyrics: Capture lyrics and save them with info about
      atrist, rhythm etc as properties.
   5. Contacts: Save a contact to "contacts.org"

   #+begin_src emacs-lisp
   (use-package org-capture
     :after org
     :init
     ;; my capture templates
     (setq org-capture-templates
	   '(("t" "Todo" entry (file+headline "" "Tasks")
	      "* TODO %?\n  %i\n  %a")

	     ("j" "Journal" entry (file+datetree "journal.org")
	      "* %^{entry title}%^G\n%U\n  %?\n")

	     ("p" "Logs for photographic process")
	     ("pd" "Darkroom log" entry (file+datetree "darkroom-log.org")
	      "* %U :darkroom:%^g\n%?" :clock-in t)

	     ("r" "Rempetika lyrics" entry (file+headline "~/stixoi.org" "Στίχοι ρεμπέτικα")
	      "* %^{ΤΙΤΛΟΣ}\n%^{ΤΡΑΓΟΥΔΙΣΤΗΣ}p%^{ΣΥΝΘΕΤΗΣ}p%^{ΡΥΘΜΟΣ}p%^{ΔΡΟΜΟΣ}p%^{ΤΟΝΟΣ}p\n%x")

	     ;; ("B" "Web purchase" entry (file+headline "web-stuff.org" "Purchases")
	     ;;  "* ORDERED %^{item desc.}\n\n%x\n\nEst. delivery: %?\n\nOrder placed on: %U")

	     ;; ("l" "Link" entry (file+headline "web-stuff.org" "Links")
	     ;;  "* %x %^g\n %?\n%U")

	     ;; ("b" "Bibliography reference" entry (file "bib-references.org")
	     ;;  "* @%^{.bib entry}: %^{description} %^g\n %^{page(s)} %?\n%U")

	     ("c" "Contact" entry (file "contacts.org")
	      "* %^{NICKNAME}\n%^{EMAIL}p\n:END:")))
     :config
     ;; Functions used in creating capture frame -- credits to Mike Zamansky
     (defadvice org-capture-finalize
	 (after delete-capture-frame activate)
       "Advise capture-finalize to close the frame"
       (if (equal "capture" (frame-parameter nil 'name))
	   (delete-frame)))

     (defadvice org-capture-destroy
	 (after delete-capture-frame activate)
       "Advise capture-destroy to close the frame"
       (if (equal "capture" (frame-parameter nil 'name))
	   (delete-frame)))

     (defun make-capture-frame ()
       "Create a new frame and run org-capture."
       (interactive)
       (make-frame '((name . "capture")))
       (select-frame-by-name "capture")
       (delete-other-windows))
     :bind
     (("C-c c" . org-capture)))
   #+end_src

** Org agenda

   Org agenda is what it says on the lid... It offers an overview of
   todos, appointments etc from your files in 'org-directory'. Of
   course, what you see is fully customizable. It also offers
   integration with the diary (see next section).

   #+begin_src emacs-lisp
   (use-package org-agenda
     :after org
     :init
     (setq org-agenda-include-diary t)
     :bind
     (("C-c a" . org-agenda)))
   #+end_src

** Other tools

   Some other tools that I use, or don't use...

*** Org contacts

    This package works in tandem with mu4e. It stores contacts in a
    contacts file, and offers some functionality on this file (like
    send mail to contact).

    #+begin_src emacs-lisp
    (use-package org-contacts
      :after org
      :custom
      (org-contacts-files '("~/.personal/contacts.org"))
      :bind ("C-x M-." . org-contacts-view-send-email))
    #+end_src

*** Org msg

    Org-msg is a package that is supposed to offer better integration
    of org-mode while composing an email message, so that you can send
    a correctly formatted html email. It is very interesting, but it
    never worked correctly for me, so I will keep it disabled.

    #+begin_src emacs-lisp
    (use-package org-msg
      :ensure t
      :disabled t
      :after org mu4e
      :bind
      (:map mu4e-compose-mode-map ("M-c" . org-msg-edit-mode)))
    #+end_src

* TODO CONFIURATION [4/14]
** TODO INTERFACE
*** Try packages

    #+begin_src emacs-lisp
    (use-package try
      :ensure t)
    #+end_src
    
*** Defaults

    #+begin_src emacs-lisp
    (setq inhibit-splash-screen t)       	;; disable the splash screen
    (setq initial-scratch-message nil)   	;; disable scratch message
    (tool-bar-mode -1)                   	;; all bars off
    (menu-bar-mode -1)
    (scroll-bar-mode -1)
    (blink-cursor-mode -1)
    (column-number-mode 1)               	;; show cursor position
    (global-visual-line-mode t)          	;; visual line mode everywhere
    (global-hl-line-mode t)              	;; highlight active line
    (fset 'yes-or-no-p 'y-or-n-p)        	;; ask me for y or n
    (setq default-directory (file-name-as-directory (getenv "HOME"))) ;; change the default directory to $HOME
    (setq select-enable-clipboard t)				  ;; use the clipboard for yanking
    (setq save-interprogram-paste-before-kill t)
    (setq help-window-select t)	       ;; always focus on help windows
    (setq sentence-end-double-space nil)   ;; better sentence navigation
    (delete-selection-mode 1)	       ;; typing deletes selected text
    (set-language-environment "UTF-8")     ;; always use UTF-8 encoding
    (set-default-coding-systems 'utf-8)
    (setq browse-url-browser-function 'browse-url-xdg-open) ;; open with default browser
    (setq vc-follow-symlinks t) ;; don't ask when visiting symlinks
    (global-set-key (kbd "M-SPC") nil)			;; temporary fix, I use this key combination to switch layouts stystem-wise, but emacs intercepts the key presses
    #+end_src

*** Enable some disabled features

    #+begin_src emacs-lisp
    (put 'downcase-region 'disabled nil) ;; binds to 'C-x C-l'
    (put 'upcase-region 'disabled nil) ;; binds to 'C-x C-u'
    (put 'narrow-to-region 'disabled nil) ;; binds to 'C-x n n'
    #+end_src

*** Font size

    #+begin_src emacs-lisp
    (global-set-key (kbd "C-<next>") 'text-scale-increase)
    (global-set-key (kbd "C-<prior>") 'text-scale-decrease)
    #+end_src

*** Line numbering

    #+begin_src emacs-lisp
    ;; (display-line-numbers-mode t)

    (use-package linum-relative
      :ensure t
      :after org
      :init
      (setq linum-relative-current-symbol "")
      :bind ("C-x M-l" . linum-relative-toggle))
    #+end_src

*** Darkroom mode

    A nice mode for reading and writing, similar to vim's goyo
    Does it make sense to configure follow-mode here? Maybe.

    #+begin_src emacs-lisp
    (use-package darkroom
      :ensure t
      :init
      (setq darkroom-text-scale-increase 0.8)
      :bind
      (("C-M-_" . darkroom-decrease-margins)
       ("C-x M-D" . darkroom-tentative-mode)))

    (global-set-key (kbd "C-x M-L") 'follow-mode)
    #+end_src

*** Rainbow mode

    #+begin_src emacs-lisp
    (use-package rainbow-mode
      :ensure t
      :delight
      :hook prog-mode conf-mode)
    #+end_src

*** Load theme

    #+begin_src emacs-lisp
    (use-package color-theme-sanityinc-tomorrow
      :ensure t)

    (color-theme-sanityinc-tomorrow--define-theme bright)
    #+end_src

*** All the icons
Icons for emacs.
#+begin_src emacs-lisp
;; Note: After the first load, run `all-the-icons-install-fonts'
(use-package all-the-icons
  :ensure t
  :delight)
#+end_src

#+begin_src emacs-lisp
(add-to-list 'load-path "~/.source")
(require 'font-lock+)
#+end_src

*** Hide info from modeline (delight)

    Normally I use the =:delight= keyword of use package, here are the built-in modes that I want to omit.

    #+begin_src emacs-lisp
    (use-package delight
      :ensure t
      :config
      (delight 'dired-mode "")
      (delight 'undo-tree-mode nil 'undo-tree)
      (delight 'visual-line-mode " ⏎" 'simple)
      (delight 'eldoc-mode nil 'eldoc)
      ;; for some reason, I cannot set this in use-package declaration of smartparens
      (delight 'smartparens-mode " {⬄}" 'smartparens))
    #+end_src

This seems a reasonable way to change modeline info for major modes. Why use delight for that? It also seems to work better for, e.g, this case.

    #+begin_src emacs-lisp
    (add-hook 'emacs-lisp-mode-hook
	  (lambda ()
	    (setq mode-name "ELisp")))
    #+end_src
    
*** Which key

    #+begin_src emacs-lisp
    (use-package which-key
      :ensure t
      :delight
      :config (which-key-mode))
    #+end_src
*** Default files

    Change the way that emacs keeps backups, also some default files, like custom

    #+begin_src emacs-lisp
    ;; use separate custom file
    (setq custom-file "~/.emacs.d/custom.el")
    (load custom-file)

    ;; backup files
    (setq backup-directory-alist `(("." . "~/.emacs.d/backups")))
    (setq backup-by-copying t) ;; this is to ensure all edited files keep their inodes
    #+end_src
*** Emojis

    Display emojis!

    #+begin_src emacs-lisp
    (use-package emojify
      :ensure t)
    #+end_src
*** Transparency

    Coz why not? Until I get bored with it. Or maybe make it toggle?
    
    UPDATE: It seems that there is some problems after all...

    #+begin_src emacs-lisp
    ;; (set-frame-parameter (selected-frame) 'alpha '(90 80))
    #+end_src

** TODO FUNCTIONALITY
*** Whole buffer evaluation

    #+begin_src emacs-lisp
    (global-set-key (kbd "C-x C-S-e") 'eval-buffer)
    #+end_src

*** Toggle comments

    #+begin_src emacs-lisp
    (global-set-key (kbd "C-;") 'comment-line)
    (global-set-key (kbd "C-M-;") 'comment-or-uncomment-region)
    #+end_src

*** Parentheses

    #+begin_src emacs-lisp
    (use-package smartparens-config
      :ensure smartparens
      ;; :delight ('smartparens-mode " \(\)" 'smartparens)
      :init
      (smartparens-global-mode 1)
      (show-smartparens-global-mode 1)
      (sp-local-pair 'emacs-lisp-mode "'" nil :actions nil)
      :bind
      ("M-s" . sp-splice-sexp))

    (use-package rainbow-delimiters
      :ensure t
      :init
      (add-hook 'prog-mode-hook #'rainbow-delimiters-mode))

    #+end_src

*** Expand region

    #+begin_src emacs-lisp
    (use-package expand-region
      :ensure t
      :bind
      (("C-=" . er/expand-region)
       ("C-c =" . er/expand-region)
       ("C--" . er/contract-region)
       ("C-c -" . er/contract-region)))
    #+end_src

*** Smarter move to beginning of line

    Part of Prelude

    #+begin_src emacs-lisp
    (defun smarter-move-beginning-of-line (arg)
      "Move point back to indentation of beginning of line.

    Move point to the first non-whitespace character on this line.
    If point is already there, move to the beginning of the line.
    Effectively toggle between the first non-whitespace character and
    the beginning of the line.

    If ARG is not nil or 1, move forward ARG - 1 lines first.  If
    point reaches the beginning or end of the buffer, stop there."
      (interactive "^p")
      (setq arg (or arg 1))

      ;; Move lines first
      (when (/= arg 1)
	(let ((line-move-visual nil))
	  (forward-line (1- arg))))

      (let ((orig-point (point)))
	(back-to-indentation)
	(when (= orig-point (point))
	  (move-beginning-of-line 1))))

    (global-set-key [remap move-beginning-of-line] 'smarter-move-beginning-of-line)
    #+end_src

    Kill the whole line

    #+begin_src emacs-lisp
    (global-set-key (kbd "C-S-k") 'kill-whole-line)
    #+end_src

*** Duplicate line

    #+begin_src emacs-lisp
    (defun duplicate-line()
      "Duplicates a line."
      (interactive)
      (move-beginning-of-line 1)
      (kill-line)
      (yank)
      (open-line 1)
      (next-line 1)
      (yank))

    (global-set-key (kbd "C-c d") 'duplicate-line)
    #+end_src

*** Auto-evaluate init file

    Auto-evaluate the init.el file when saving this org file. A must have!

    Got the general idea from https://www.reddit.com/r/emacs/comments/8hpyp5/tip_how_to_execute_a_bash_function_when_saving_a/

    #+begin_src emacs-lisp

    (defun l/reload-emacs ()
      "Reload the init file"
      (interactive)
      (load-file "~/.emacs.d/init.el"))

    (defun my/cmd-after-saved-file ()
      "Evaluate the init file automatically"
	(when (string= (buffer-file-name) (expand-file-name "~/.emacs.d/my-config.org"))
	  (l/reload-emacs)))

    (add-hook 'after-save-hook 'my/cmd-after-saved-file)

    ;; also makes sense to bind a "refresh" key, similar to the i3 config
    (global-set-key (kbd "C-M-S-r") 'l/reload-emacs)
    #+end_src

*** Restart emacs
Restart emacs from within emacs (duh!)
#+begin_src emacs-lisp
(use-package restart-emacs
  :ensure t
  :bind ("C-M-S-e" . 'restart-emacs))

#+end_src

*** Syntax highlighting for rc files

    #+begin_src emacs-lisp
    (add-to-list 'auto-mode-alist '("\\.*rc$" . conf-mode))
    #+end_src

** TODO WINDOW MANAGEMENT
*** Windows movement and resizing

    #+begin_src emacs-lisp
    (windmove-default-keybindings) ;; use arrow keys ot navigate

    ;; resize shortcuts
    (global-set-key (kbd "S-C-<left>") 'shrink-window-horizontally)
    (global-set-key (kbd "S-C-<right>") 'enlarge-window-horizontally)
    (global-set-key (kbd "S-C-<down>") 'shrink-window)
    (global-set-key (kbd "S-C-<up>") 'enlarge-window)
    #+end_src

*** Ace-window

    Ace-window is a more efficient way to move between windows.

    #+begin_src emacs-lisp
    (use-package ace-window
      :ensure t
      :init
      (setq aw-keys '(?h ?j ?k ?l ?a ?s ?d ?f ?g))
      :config
      (ace-window-display-mode 1)
      :bind
      (("C-x o" . ace-window)
       ("C-x M-o" . ace-swap-window)))
    #+end_src

*** Split windows and follow

    The default behaviour after splitting a window is to stay in the initial window. I always want to go to the new one.

    I don't remember from where I got this.

    #+begin_src emacs-lisp
    (defun split-window-and-follow-below ()
      "Split and follow container horizontally."
      (interactive)
      (split-window-below)
      (balance-windows)
      (other-window 1))

    (defun split-window-and-follow-right ()
      "Split and follow container vertically."
      (interactive)
      (split-window-right)
      (balance-windows)
      (other-window 1))

    (global-set-key (kbd "C-x 2") 'split-window-and-follow-below)
    (global-set-key (kbd "C-x 3") 'split-window-and-follow-right)

    #+end_src

*** Toggle window split
    
    I don't remember from where I got this either...

    #+begin_src emacs-lisp
    (defun toggle-window-split ()
      "Switch between horizontal and vertical split when using two windows."
      (interactive)
      (if (= (count-windows) 2)
	  (let* ((this-win-buffer (window-buffer))
		 (next-win-buffer (window-buffer (next-window)))
		 (this-win-edges (window-edges (selected-window)))
		 (next-win-edges (window-edges (next-window)))
		 (this-win-2nd (not (and (<= (car this-win-edges)
					     (car next-win-edges))
					 (<= (cadr this-win-edges)
					     (cadr next-win-edges)))))
		 (splitter
		  (if (= (car this-win-edges)
			 (car (window-edges (next-window))))
		      'split-window-horizontally
		    'split-window-vertically)))
	    (delete-other-windows)
	    (let ((first-win (selected-window)))
	      (funcall splitter)
	      (if this-win-2nd (other-window 1))
	      (set-window-buffer (selected-window) this-win-buffer)
	      (set-window-buffer (next-window) next-win-buffer)
	      (select-window first-win)
	      (if this-win-2nd (other-window 1))))))

    (global-set-key (kbd "C-x |") 'toggle-window-split)
    #+end_src

*** Swap windows

    #+begin_src emacs-lisp
    (global-set-key (kbd "C-x \\") 'window-swap-states)
    #+end_src

*** Evil window bindings

    Window functions with evil mode. Also some functions that make sense for me to be configured here, like buffer actions.

    #+begin_src emacs-lisp
    (eval-after-load "evil"
      '(progn
	 (define-key evil-normal-state-map "\\" nil) ;; prefix
	 (define-key evil-normal-state-map "\\0" 'ace-delete-window)
	 (define-key evil-normal-state-map "\\q" 'delete-window)
	 (define-key evil-normal-state-map "\\Q" 'kill-buffer-and-window)
	 (define-key evil-normal-state-map "\\1" 'delete-other-windows)
	 ;; for movement, it made more sense to use "gaming" keys (also because of the prefix key position)
	 (define-key evil-normal-state-map "\\a" 'windmove-left)
	 (define-key evil-normal-state-map "\\s" 'windmove-down)
	 (define-key evil-normal-state-map "\\w" 'windmove-up)
	 (define-key evil-normal-state-map "\\d" 'windmove-right)
	 (define-key evil-normal-state-map "\\s" 'split-window-and-follow-right)
	 (define-key evil-normal-state-map "\\3" 'split-window-and-follow-right)
	 (define-key evil-normal-state-map "\\v" 'split-window-and-follow-below)
	 (define-key evil-normal-state-map "\\2" 'split-window-and-follow-below)
	 (define-key evil-normal-state-map "\\_" 'toggle-window-split)
	 (define-key evil-normal-state-map "\\-" 'window-swap-states)
	 (define-key evil-normal-state-map "\\\\" 'ace-window)
	 (define-key evil-normal-state-map "\\|" 'ace-swap-window)
	 (define-key evil-normal-state-map (kbd "M-H") 'shrink-window-horizontally)
	 (define-key evil-normal-state-map (kbd "M-L") 'enlarge-window-horizontally)
	 (define-key evil-normal-state-map (kbd "M-J") 'shrink-window)
	 (define-key evil-normal-state-map (kbd "M-K") 'enlarge-window)
	 (define-key evil-normal-state-map (kbd "M-+") 'balance-windows)
	 ;; (define-key evil-normal-state-map "\\f" 'find-file)
	 (define-key evil-normal-state-map "\\f" 'helm-find-files)
	 (define-key evil-normal-state-map "\\b" 'switch-to-buffer)
	 (define-key evil-normal-state-map "\\," '(lambda () (interactive) (switch-to-buffer "*scratch*")))
	 (define-key evil-normal-state-map "\\<" 'switch-to-prev-buffer)
	 (define-key evil-normal-state-map "\\>" 'switch-to-next-buffer)
	 (define-key evil-normal-state-map "\\z" 'kill-current-buffer)
	 (define-key evil-normal-state-map "\\D" 'dired-jump)
	 ;; other window
	 (define-key evil-normal-state-map "\\'" nil) ;;prefix
	 (define-key evil-normal-state-map "\\'f" 'find-file-other-window)
	 (define-key evil-normal-state-map "\\'b" 'switch-to-buffer-other-window)
	 (define-key evil-normal-state-map "\\'D" 'dired-other-window)))

    #+end_src

** REJECTED HELM
   CLOSED: [2020-04-12 Sun 05:52]

     Helm was my previous selection for navigation. I dropped it in
     favour of ivy. It is very powerful, but for me, really hard to
     customize.

     I will keep my configuration here, disabled, in case I ever need it
     again.

***** Basics
     #+begin_src emacs-lisp
     (use-package helm-config
       :disabled
       :ensure helm
       :delight helm-mode
       :defer 1
       :init
       (setq helm-follow-mode-persistent t)
       (setq  helm-split-window-inside-p t)
       :config
       (helm-mode 1)
       :bind
       ("M-x" . helm-M-x)
       ("C-x C-f" . helm-find-files)
       ("M-y" . helm-show-kill-ring)
       ([remap switch-to-buffer] . helm-buffers-list))
     #+end_src

***** Helm-swoop
      #+begin_src emacs-lisp
      (use-package helm-swoop
	:disabled
	:ensure t
	:after helm evil
	:init
	(setq helm-swoop-speed-or-color t)
	;; pre-input disabled or marked word
	(setq helm-swoop-pre-input-function
	    (lambda ()
	      (if mark-active
		  (buffer-substring-no-properties (mark) (point)) "")))
	:bind
	("M-i" . 'helm-swoop)
	("C-M-i" . 'helm-multi-swoop)
	("M-I" . 'helm-swoop-back-to-last-point)
	(:map helm-swoop-map
	      ("M-i" . 'helm-multi-swoop-all-from-helm-swoop))
	(:map isearch-mode-map
	      ("M-i" . 'helm-swoop-from-isearch))
	(:map evil-motion-state-map
	      ("M-i" . 'helm-swoop-from-evil-search)))

      #+end_src
** TODO MULTIPLE CURSORS

     It seems that the mc package is not really needed. Maybe everything it does can be achieved by using replacement methods and/or macros. Not to mention vim's =:g= command, or helm-swoop.

     #+begin_src emacs-lisp
     (use-package multiple-cursors
       :ensure t
       :bind
       ("C-s-c C-s-c" . mc/edit-lines)
       ("C->" . mc/mark-next-like-this)
       ("C-<" . mc/mark-previous-like-this)
       ("C-c C-<" . mc/mark-all-like-this)
       ("C-<down-mouse-1>" . mc/add-cursor-on-click)
       ("C-!" . mc/insert-numbers))

     (use-package mc-extras
       :ensure t
       :after multiple-cursors)

     (use-package ace-mc
       :ensure t
       :after mc-extras
       :bind
       ("C-c )" . ace-mc-add-multiple-cursors)
       ("C-M-)" . ace-mc-add-single-cursor))
     #+end_src

** DONE DIRED [15/15]
     CLOSED: [2020-04-11 Sat 04:56]

     This *IS* my new file manager!
   
***** DONE Dired-x
      CLOSED: [2020-04-11 Sat 03:33]

      #+begin_src emacs-lisp
      ;; (use-package dired-x
	;; :ensure nil
	;; :delight dired-omit-mode
	;; :after dired
	;; :init
	;; (setq dired-omit-verbose nil)
	;; :config
	;; files to be ommited: beginning with one or more dots, beginning with $ (some files that come from Windows), ending with xmp (eg darktable data files), ending with srt, sub (I don't want to see subtitle files)
	;; (setq dired-omit-files (concat dired-omit-files "\\|^\\..+$\\|^\\$\\|xmp$\\|srt$\\|sub$")))
      #+end_src

***** DONE Some useful functions [5/5]
      CLOSED: [2020-04-11 Sat 02:23]
    
****** DONE Attatch marked files to email:
       CLOSED: [2020-04-11 Sat 01:00]

       Found [[https://emacs.stackexchange.com/questions/14652/attach-multiple-files-from-the-same-directory-to-an-email-message][here]].

       Open a dired buffer, mark some files and run the command. If there's an open message buffer use it, else create new message

       #+begin_src emacs-lisp
       ;; (defun compose-attach-marked-files ()
	 ;; "Compose mail and attach all the marked files from a dired buffer. Uses `compose-mail', (or `org-msg-attach-attach' if org-msg is enabled -- this is not true yet)."
	 ;; (interactive)
	 ;; (let ((files (dired-get-marked-files)))
	   ;; (compose-mail nil nil nil t)
	   ;; (dolist (file files)
	     ;; (if (file-regular-p file)
		 ;; (mml-attach-file file
				  ;; (mm-default-file-encoding file)
				  ;; nil "attachment")
	       ;; (message "skipping non-regular file %s" file)))))
       #+end_src

****** DONE Go to first/last directory:
       CLOSED: [2020-04-11 Sat 00:51]

       Instead of going to the beginning or end of the buffer, go to the first or last directory line
     
       Source: https://www.emacswiki.org/emacs/dired-extension.el

       #+begin_src emacs-lisp
       ;; (defun dired-goto-first-file ()
	 ;; "Move cursor to first file of dired."
	 ;; (interactive)
	 ;; (goto-char (point-min))
	 ;; (while (not (dired-move-to-filename))
	   ;; (call-interactively 'dired-next-line)))

       ;; (defun dired-goto-last-file ()
	 ;; "Move cursor to last file of dired."
	 ;; (interactive)
	 ;; (goto-char (point-max))
	 ;; (while (not (dired-move-to-filename))
	   ;; (call-interactively 'dired-previous-line)))
       #+end_src

****** DONE Sorting functions:
       CLOSED: [2020-04-11 Sat 00:31]

****** DONE Mark and move backwards:
       CLOSED: [2020-04-11 Sat 00:53]

       This was always a missing feature imho.

       #+begin_src emacs-lisp
       ;; (defun l/dired-mark-backwards ()
	 ;; "Mark file at point and move backwards."
	 ;; (interactive)
	 ;; (if (dired-move-to-filename)
	   ;; (progn
	     ;; (dired-mark 1)
	     ;; (dired-previous-line 2))))

       #+end_src

****** DONE Narrow to marked files:
       CLOSED: [2020-04-11 Sat 00:53]

       #+begin_src emacs-lisp
       ;; (defun l/dired-narrow-to-marked-files ()
	 ;; "Show only marked files in dired buffer."
	 ;; (interactive)
	 ;; (let ((files (dired-get-marked-files)))
	   ;; (unless (eq (length files) 1)
	     ;; (dired-toggle-marks)
	     ;; (dired-do-kill-lines))))
       #+end_src

***** DONE Some useful (external) functions [5/5]
      CLOSED: [2020-04-11 Sat 02:23]
    
      Useful functions that use external programs.

****** DONE Get subtitles:
       CLOSED: [2020-04-11 Sat 01:11]

       Use [[https://github.com/Diaoul/subliminal][subliminal]] to find subtitles online. The gist of using 'start-process' comes from [[http://ergoemacs.org/emacs/elisp_call_shell_command.html][here]], and the idea of using 'apply' from [[https://stackoverflow.com/questions/17075920/passing-list-to-rest-args?rq=1][here]].

       #+begin_src emacs-lisp
       ;; (defun l/get-subtitles ()
	 ;; "Get subtitles for marked files while in a dired buffer. Depends on subliminal, so it has to be on your system."
	 ;; (interactive)
	 ;; (when (eq major-mode 'dired-mode)
	   ;; (let* ((lang-list '("en" "gr"))
		  ;; (lang (completing-read "Select language: " lang-list nil t))
		  ;; (files (dired-get-marked-files))
		  ;; (process-connection-type nil))
	     ;; (if (get-buffer "*get-subtitles*")
		 ;; (kill-buffer "*get-subtitles*"))
	     ;; (apply 'start-process
		    ;; (append (list "get-subtitles" "*get-subtitles*" "subliminal" "download" "-l" lang) files))
	   ;; (switch-to-buffer-other-window "*get-subtitles*")
	   ;; (special-mode))))
       #+end_src

****** DONE Get files size:
       CLOSED: [2020-04-11 Sat 01:07]

       Source: 
       #+begin_src emacs-lisp
       ;; (defun dired-get-size ()
	 ;; "Get total size of marked files with `du' command.
       ;; If not marked any files, default is current file or directory."
	 ;; (interactive)
	 ;; (let ((files (dired-get-marked-files)))
	   ;; (with-temp-buffer
	     ;; (apply 'call-process "/usr/bin/du" nil t nil "-sch" files)
	     ;; (message "%s"
		      ;; (progn
			;; (re-search-backward "\\(^[0-9.,]+[A-Za-z]+\\).*\\(total\\|总用量\\)$")
			;; (match-string 1))))))
       #+end_src

****** DONE Change desktop background:
       CLOSED: [2020-04-11 Sat 01:12]

       #+begin_src emacs-lisp
       ;; (defun l/change-desktop-background ()
	 ;; "Change the desktop background using feh."
	 ;; (interactive)
	 ;; (let ((fit-type (completing-read "Select fit: " '("scale" "center" "fill" "max") nil t))
	       ;; (entry (shell-quote-argument (expand-file-name (dired-file-name-at-point))))
	       ;; (targetfile (shell-quote-argument (expand-file-name "~/.config/.wallpaper.jpg"))))
	   ;; (setq cpcmd (concat "cp " entry " " targetfile))
	   ;; (setq fehcmd (concat "feh --bg-" fit-type " " targetfile))
	   ;; (setq cmd (concat cpcmd " && " fehcmd))
	   ;; (shell-command cmd))) 
       #+end_src

****** DONE Unmount drives:
       CLOSED: [2020-04-11 Sat 01:10]

       Simple script to unmount drive. Uses 'mountpoint' and 'umount'. If unmounting fails, give some options (todo).

       #+begin_src emacs-lisp
       ;; (defun l/unmount-drive ()
	 ;; "Unmount selected directories, if they correspond to mountpoints."
	 ;; (interactive)
	 ;; (let ((dirs (dired-get-marked-files)))
	   ;; (dired-do-shell-command "mountpoint -q ? && sudo umount ? && sudo rmdir ?" nil dirs)
	   ;; (revert-buffer)))
       #+end_src

****** DONE COMMENT Pack/Unpack:
       CLOSED: [2020-04-11 Sat 01:10]

       I tried the dired-atool package but I didn't like it. I needed something simpler, also I didn't like the output display.

       So I checked out the pack/unpack functions in the source and made mine, but simpler.

       #+begin_src emacs-lisp
       ;; pack
       ;; (defun l/atool-pack ()
	 ;; "Use the `atool' program to pack some files."
	 ;; (interactive)
	 ;; (when (eq major-mode 'dired-mode)
	   ;; (let ((files (dired-get-marked-files t))
		 ;; (archive (expand-file-name
			   ;; (read-file-name "Pack files as:" nil nil nil)))
		 ;; (process-connection-type nil))
	     ;; (if (get-buffer "*atool-pack*")
		 ;; (kill-buffer "*atool-pack*"))
	     ;; (apply 'start-process
		    ;; (append (list "atool-pack" "*atool-pack*" "atool" "--explain" archive "-a") files))
	     ;; (switch-to-buffer-other-window "*atool-pack*")
	     ;; (special-mode))))

       ;; unpack
       ;; (defun l/atool-unpack ()
	 ;; "Use the `atool' program to unpack some archives."
	 ;; (interactive)
	 ;; (when (eq major-mode 'dired-mode)
	   ;; (let ((files (dired-get-marked-files t))
		 ;; (dest (expand-file-name
			;; (read-directory-name "Unpack files to:"
					     ;; (dired-dwim-target-directory) nil nil)))
		 ;; (process-connection-type nil))
	     ;; (if (get-buffer "*atool-unpack*")
		 ;; (kill-buffer "*atool-unpack*"))
	     ;; (if (not (file-directory-p dest))
		 ;; (make-directory dest))
	     ;; (apply 'start-process
		    ;; (append (list "atool-unpack" "*atool-unpack*" "atool" "--explain" "-X" dest) files))
	     ;; (switch-to-buffer-other-window "*atool-unpack*")
	     ;; (special-mode))))
       #+end_src
     
***** DONE Dired custom maps
      CLOSED: [2020-04-11 Sat 02:23]

      #+begin_src emacs-lisp
      ;; navigation map
      ;; (define-prefix-command 'l/dired-nav-map)

      ;; (define-key l/dired-nav-map "h" (lambda () (interactive) (dired "~/")))
      ;; (define-key l/dired-nav-map "D" (lambda () (interactive) (dired "~/Downloads/")))
      ;; (define-key l/dired-nav-map "d" (lambda () (interactive) (dired "~/Documents/")))
      ;; (define-key l/dired-nav-map "p" (lambda () (interactive) (dired "~/Pictures/")))
      ;; (define-key l/dired-nav-map "M" (lambda () (interactive) (dired "~/Music/")))
      ;; (define-key l/dired-nav-map "v" (lambda () (interactive) (dired "~/Videos/")))
      ;; (define-key l/dired-nav-map "m" (lambda () (interactive) (dired "/media")))
      ;; (define-key l/dired-nav-map "C" (lambda () (interactive) (dired "~/.config/")))
      ;; (define-key l/dired-nav-map "E" (lambda () (interactive) (dired "~/.emacs.d/")))
      ;; (define-key l/dired-nav-map "!" (lambda () (interactive) (dired "~/dotfiles/")))

      ;; external scripts map -- Note: after using those, I think it's better to write full shell scripts and run those in emacs -- Sidenote: use dmenu for selection if those are run externally, but in emacs use the default completing mechanisms.
      ;; (define-prefix-command 'l/dired-my-ext-cmds)

      ;; (define-key l/dired-my-ext-cmds "s" 'l/get-subtitles)
      ;; (define-key l/dired-my-ext-cmds "?" 'dired-get-size)
      ;; (define-key l/dired-my-ext-cmds "B" 'l/change-desktop-background)
      ;; (define-key l/dired-my-ext-cmds "u" 'l/unmount-drive)
      ;; (define-key l/dired-my-ext-cmds "zz" 'l/atool-pack)
      ;; (define-key l/dired-my-ext-cmds "zx" 'l/atool-unpack)
      #+end_src

***** DONE Dired defaults
      CLOSED: [2020-04-11 Sat 03:37]

      #+begin_src emacs-lisp
      ;; (setq dired-dwim-target t)
      ;; (setq dired-listing-switches "-alh") ;; add human-readable sizes


      ;; (add-hook 'dired-mode-hook
		;; (lambda ()
		  ;; (dired-hide-details-mode)
		  ;; (dired-omit-mode)))

      ;; This hook seems to be added automatically to my 'custom.el' file and breaks dired. I have to find out where it comes from. It was a part of the `ranger' package, which I have deleted.
      ;; (remove-hook 'dired-mode-hook 'ranger-set-dired-key)
      #+end_src

***** DONE Image dired
      CLOSED: [2020-04-11 Sat 03:37]

      #+begin_src emacs-lisp
      ;; (setq image-dired-thumb-width 250)
      ;; (setq image-dired-thumbs-per-row 4)
      ;; (setq image-dired-external-viewer "sxiv")
      #+end_src

***** DONE Dired keybindings
      CLOSED: [2020-04-11 Sat 03:37]

      Changing some default keybindings

      #+begin_src emacs-lisp
      ;; (eval-after-load "dired"
	;; '(progn
	   ;; (define-key dired-mode-map "G" 'revert-buffer)
	   ;; (define-key dired-mode-map "g" 'l/dired-nav-map)
	   ;; (define-key dired-mode-map "z" 'dired-omit-mode)
	   ;; (define-key dired-mode-map (kbd "C-x M-.") 'compose-attach-marked-files)
	   ;; (define-key dired-mode-map (kbd "M-<") 'dired-goto-first-file)
	   ;; (define-key dired-mode-map (kbd "M->") 'dired-goto-last-file)))
      #+end_src

***** DONE Evil dired bindings
      CLOSED: [2020-04-11 Sat 02:49]

     Loading the whole evil-collection proved cumbersome for me, there was some trouble with my custom keybindings (eg. I couldn't use 'r' as a prefix key, even when binding it to nil after loading evil-collection). Might be sth that I did wrong, but anyhow...

     #+begin_src emacs-lisp
     ;; ;; this is from evil-collection with some changes
     ;; (eval-after-load "evil"
     ;;   '(progn
     ;;      (evil-define-key 'normal dired-mode-map
     ;;        ;; basics
     ;;        "q" 'quit-window
     ;;        ;; basic movement
     ;;        "j" 'dired-next-line
     ;;        "k" 'dired-previous-line
     ;;        "h" 'dired-up-directory
     ;;        "l" 'dired-find-file
     ;;        ">" 'dired-next-dirline
     ;;        "<" 'dired-prev-dirline
     ;;        "gg" 'dired-goto-first-file
     ;;        "G" 'dired-goto-last-file
     ;;        ;; basic functions
     ;;        "A" 'dired-do-find-regexp
     ;;        "B" 'dired-do-byte-compile
     ;;        "C" 'dired-do-copy
     ;;        "D" 'dired-do-delete
     ;;        ;; dired-do-chgrp
     ;;        "H" 'dired-do-hardlink
     ;;        "L" 'dired-do-load
     ;;        "M" 'dired-do-chmod
     ;;        "O" 'dired-do-chown
     ;;        "P" 'dired-do-print
     ;;        "Q" 'dired-do-find-regexp-and-replace
     ;;        "R" 'dired-do-rename
     ;;        "S" 'dired-do-symlink
     ;;        "T" 'dired-do-touch
     ;;        "Z" 'dired-do-compress
     ;;        "c" 'dired-do-compress-to
     ;;        "!" 'dired-do-shell-command
     ;;        "&" 'dired-do-async-shell-command
     ;;        "=" 'dired-diff
     ;;        ;; regexp operations
     ;;        "%" nil ;; prefix
     ;;        "%u" 'dired-upcase
     ;;        "%l" 'dired-downcase
     ;;        "%d" 'dired-flag-files-regexp
     ;;        "%g" 'dired-mark-files-containing-regexp
     ;;        "%m" 'dired-mark-files-regexp
     ;;        "%C" 'dired-do-copy-regexp
     ;;        "%H" 'dired-do-hardlink-regexp
     ;;        "%R" 'dired-do-rename-regexp
     ;;        "%S" 'dired-do-symlink-regexp
     ;;        "%&" 'dired-flag-garbage-files
     ;;        ;; marks & flags
     ;;        "U" 'dired-unmark-all-marks
     ;;        "u" 'dired-unmark
     ;;        "m" 'dired-mark
     ;;        (kbd "<SPC>") 'dired-mark
     ;;        (kbd "C-<SPC>") 'l/dired-mark-backwards
     ;;        "t" 'dired-toggle-marks
     ;;        "d" 'dired-flag-file-deletion
     ;;        "x" 'dired-do-flagged-delete
     ;;        (kbd "* <delete>") 'dired-unmark-backward
     ;;        (kbd "<delete>") 'dired-unmark-backward
     ;;        "*" nil ;; prefix
     ;;        "**" 'dired-mark-executables
     ;;        "*/" 'dired-mark-directories
     ;;        "*@" 'dired-mark-symlinks
     ;;        "*%" 'dired-mark-files-regexp
     ;;        "*(" 'dired-mark-sexp
     ;;        "*." 'dired-mark-extension
     ;;        "*O" 'dired-mark-omitted
     ;;        "*c" 'dired-change-marks
     ;;        "*s" 'dired-mark-subdir-files
     ;;        "*?" 'dired-unmark-all-files
     ;;        "*!" 'dired-unmark-all-marks
     ;;        "*f" 'l/dired-narrow-to-marked-files
     ;;        ;; encryption-decryption (epa-dired)
     ;;        ";d" 'epa-dired-do-decrypt
     ;;        ";v" 'epa-dired-do-verify
     ;;        ";s" 'epa-dired-do-sign
     ;;        ";e" 'epa-dired-do-encrypt
     ;;        ;; unsorted
     ;;        "X" 'l/dired-my-ext-cmds
     ;;        "z" 'dired-omit-mode
     ;;        "g" 'l/dired-nav-map
     ;;        "gr" 'revert-buffer
     ;;        "gR" 'dired-do-redisplay
     ;;        "I" 'dired-maybe-insert-subdir
     ;;        "i" 'dired-toggle-read-only
     ;;        "J" 'dired-goto-file
     ;;        "K" 'dired-do-kill-lines
     ;;        "a" 'dired-find-alternate-file
     ;;        "gy" 'dired-show-file-type
     ;;        "Y" 'dired-copy-filename-as-kill
     ;;        "+" 'dired-create-directory
     ;;        (kbd "S-<return>") 'dired-find-file-other-window
     ;;        (kbd "RET") 'dired-find-file
     ;;        (kbd "M-<return>") 'browse-url-of-dired-file
     ;;        ;; sorting
     ;;        "o" nil ;; prefix -- was dired-sort-toggle-or-edit
     ;;        "oo" 'l/dired-sort-by-name
     ;;        "od" 'l/dired-sort-by-date
     ;;        "os" 'l/dired-sort-by-size
     ;;        "ox" 'l/dired-sort-by-ext
     ;;        "o=" 'l/dired-sort-dirs-first
     ;;        "(" 'dired-hide-details-mode
     ;;        "g?" 'dired-summary
     ;;        "?" 'dired-get-size)

     ;;      (add-hook 'dired-mode-hook 'evil-normalize-keymaps)))
     #+end_src

***** DONE Dired subtree
      CLOSED: [2020-04-11 Sat 04:28]

      #+begin_src emacs-lisp
      ;; (use-package dired-subtree
	;; :ensure t
	;; :after dired evil
	;; :config
	;; (evil-define-key 'normal dired-mode-map (kbd "TAB") 'dired-subtree-toggle))
      #+end_src

***** DONE Peep dired
      CLOSED: [2020-04-11 Sat 04:23]

      Peep dired is loaded from [[https://github.com/dakodeon/peep-dired][my fork]].

****** Peepy-fied dired functions

       Some functions for a more consistent peeping experience.
     
       Note: these were left out of my peep-dired fork because they are not part of dired

       #+begin_src emacs-lisp
       ;; (defun l/peep-dired-goto-first-file ()
	 ;; "Go to first file line and peep there. Uses `dired-goto-first-file'"
	 ;; (interactive)
	 ;; (dired-goto-first-file)
	 ;; (peep-dired-display-file-other-window))

       ;; (defun l/peep-dired-goto-last-file ()
	 ;; "Go to last file line and peep there. Uses `dired-goto-last-file'"
	 ;; (interactive)
	 ;; (dired-goto-last-file)
	 ;; (peep-dired-display-file-other-window))

       ;; (defun l/peep-dired-mark-backwards ()
	 ;; "Mark and peep backwards."
	 ;; (interactive)
	 ;; (l/dired-mark-backwards)
	 ;; (peep-dired-display-file-other-window))
       #+end_src

****** Load Peep

       This is my fork of peep-dired. clone it from [[https://github.com/dakodeon/peep-dired/tree/luc][github]] and set =:load-path= to point to the correct path.

      #+begin_src emacs-lisp
      ;; (use-package peep-dired
	;; :load-path "~/.source/peep-dired"
	;; :delight (peep-dired " ")
	;; :after dired-x
	;; :init
	;; is this that creates an error? -- Yes, do not use it, or fix it
	;; (setq peep-dired-cleanup-eagerly t)
	;; (setq peep-dired-ignored-extensions '("mkv" "mp4" "avi" "mov" "mp3" "wav" "iso"))
	;; :config
	;; evil integration
	;; (eval-after-load "evil"
	  ;; '(progn
	     ;; (evil-define-key 'normal peep-dired-mode-map
	       ;; (kbd "C-j") 'peep-dired-scroll-page-down
	       ;; (kbd "C-k") 'peep-dired-scroll-page-up
	       ;; (kbd "j") 'peep-dired-next-file
	       ;; (kbd "<down>") 'peep-dired-next-file
	       ;; (kbd "k") 'peep-dired-prev-file
	       ;; (kbd "<up>") 'peep-dired-prev-file
	       ;; (kbd "h") 'peep-dired-up-directory
	       ;; (kbd "<left>") 'peep-dired-up-directory
	       ;; (kbd "l") 'peep-dired-find-file
	       ;; (kbd "<right>") 'peep-dired-find-file
	       ;; (kbd ">") 'peep-dired-next-dirline
	       ;; (kbd "<") 'peep-dired-prev-dirline
	       ;; (kbd "g g") 'l/peep-dired-goto-first-file
	       ;; (kbd "G") 'l/peep-dired-goto-last-file
	       ;; (kbd "C-SPC") 'l/peep-dired-mark-backwards)
	     ;; (evil-define-key 'normal dired-mode-map (kbd "p") 'peep-dired)
	     ;; (add-hook 'peep-dired-hook 'evil-normalize-keymaps)))
	;; :bind
	;; (:map dired-mode-map
	      ;; ("p" . 'peep-dired)))
      #+end_src

***** DONE Dired narrow
      CLOSED: [2020-04-11 Sat 04:30]

      Narrow down what is shown in dired by filtering filenames.

      #+begin_src emacs-lisp
      ;; (use-package dired-narrow
	;; :ensure t
	;; :delight (dired-narrow-mode " >⋅<")
	;; :after dired evil
	;; :init
	;; (setq dired-narrow-exit-when-one-left t)
	;; :config
	;; (evil-define-key 'normal dired-mode-map (kbd "f") 'dired-narrow)
	;; :bind
	;; (:map dired-mode-map
	      ;; ("f" . 'dired-narrow)))

      #+end_src

***** DONE Copying and pasting (and bookmarks)
      CLOSED: [2020-04-11 Sat 04:50]

      Three methods of copying and pasting:
      1. Normal: The default dired way, copy and select destination on execution. Works neatly with the =dired-target-dwim= option, but sometimes you want to mark some files to copy and then paste them after some navigation.

      2. Dired-ranger: Ranger-like copying and pasting (also bookmarks, but I have to check those out)

      #+begin_src emacs-lisp
      ;; (use-package dired-ranger
	;; :ensure t
	;; :after dired
	;; :init
	;; (setq dired-ranger-bookmark-reopen 'always)
	;; :config
	;; function to visit previous directory
	;; (defun l/dired-ranger-bookmark-visit-LRU ()
	  ;; "Go to last visited directory."
	  ;; (interactive)
	  ;; (dired-ranger-bookmark-visit dired-ranger-bookmark-LRU))

	;; evil integration
	;; (eval-after-load "evil"
	  ;; '(progn
	     ;; (evil-define-key 'normal dired-mode-map
	       ;; "y" nil ;; prefix
	       ;; "yy" 'dired-ranger-copy
	       ;; "yP" 'dired-ranger-move
	       ;; "yp" 'dired-ranger-paste
	       ;; "`" nil ;; prefix
	       ;; "``" 'l/dired-ranger-bookmark-visit-LRU
	       ;; "`v" 'dired-ranger-bookmark-visit
	       ;; "`m" 'dired-ranger-bookmark))))
      #+end_src

      3. Dired-rsync: Really useful for BIG files, as it does not freeze emacs. Also, progress is shown in the modeline! Some other benefits, like copy-pasting from remote, are not yet explored. Works like normal copying.

      #+begin_src emacs-lisp
      ;; (use-package dired-rsync
	;; :ensure t
	;; :after dired
	;; :init
	;; (setq dired-rsync-unmark-on-completion nil)
	;; :config
	;; (defun l/dired-rsync-to-FAT32 ()
	  ;; "Change `dired-rsync-options' temporarily to rsync to FAT32 driver."
	  ;; (interactive)
	  ;; (let ((dired-rsync-options "-rDz --info=progress2")
		;; (dest (read-file-name "rsync to: " (dired-dwim-target-directory)
				;; nil nil nil 'file-directory-p)))
		;; (dired-rsync dest)))
	;; (eval-after-load "evil"
	  ;; '(progn
	     ;; (evil-define-key 'normal dired-mode-map "rr" 'dired-rsync)
	     ;; (evil-define-key 'normal dired-mode-map "rf" 'l/dired-rsync-to-FAT32))))
      #+end_src

****** TODO Simplify keystrokes:
       All this is really nice, but now I have three different keys related to copy-pasting (C, y, r). Maybe I should fix this somehow? I guess I will decide as I use it.

***** DONE Wdired [2/2]
      CLOSED: [2020-04-11 Sat 04:43]

****** DONE Renaming functions
       CLOSED: [2020-04-11 Sat 03:59]
       #+begin_src emacs-lisp
       ;; (defun l/evil-wdired-append-to-filename ()
	 ;; "Renaming helper for `wdired'. Append to filename before the extension."
	 ;; (interactive)
	 ;; (move-end-of-line nil)
	 ;; (search-backward ".")
	 ;; (evil-insert 1))

       ;; (defun l/evil-wdired-change-filename ()
	 ;; "Renaming helper for `wdired'. Change the filename but keep the extension."
	 ;; (interactive)
	 ;; (move-end-of-line nil)
	 ;; (search-backward ".")
	 ;; (kill-region 1 (point))
	 ;; (evil-insert 1))

       ;; (defun l/evil-wdired-change-extension ()
	 ;; "Renaming helper for `wdired'. Change file's extension."
	 ;; (interactive)
	 ;; (move-end-of-line nil)
	 ;; (set-mark-command nil)
	 ;; (search-backward ".")
	 ;; (forward-char)
	 ;; (kill-region (point) (mark))
	 ;; (evil-insert 1))
       #+end_src

****** DONE Wdired hook
       CLOSED: [2020-04-11 Sat 03:59]

       Just display a message when entering wdired!

       #+begin_src emacs-lisp
       ;; (eval-after-load "evil"
	 ;; '(progn
	    ;; (evil-define-key 'normal wdired-mode-map
	      ;; (kbd "C-r w") 'l/evil-wdired-change-filename
	      ;; (kbd "C-r a") 'l/evil-wdired-append-to-filename
	      ;; (kbd "C-r x") 'l/evil-wdired-change-extension)))
       #+end_src

***** DONE Dired rainbow
      CLOSED: [2020-04-11 Sat 04:53]

      Prettier dired. I haven't really tweaked anything, it's just some defaults from their github page.

      #+begin_src emacs-lisp
      ;; (use-package dired-rainbow
	;; :ensure t
	;; :config
	;; (progn
	  ;; (dired-rainbow-define-chmod directory "#6cb2eb" "d.*")
	  ;; (dired-rainbow-define html "#eb5286" ("css" "less" "sass" "scss" "htm" "html" "jhtm" "mht" "eml" "mustache" "xhtml"))
	  ;; (dired-rainbow-define xml "#f2d024" ("xml" "xsd" "xsl" "xslt" "wsdl" "bib" "json" "msg" "pgn" "rss" "yaml" "yml" "rdata"))
	  ;; (dired-rainbow-define document "#9561e2" ("docm" "doc" "docx" "odb" "odt" "pdb" "pdf" "ps" "rtf" "djvu" "epub" "odp" "ppt" "pptx"))
	  ;; (dired-rainbow-define markdown "#ffed4a" ("org" "etx" "info" "markdown" "md" "mkd" "nfo" "pod" "rst" "tex" "textfile" "txt"))
	  ;; (dired-rainbow-define database "#6574cd" ("xlsx" "xls" "csv" "accdb" "db" "mdb" "sqlite" "nc"))
	  ;; (dired-rainbow-define media "#de751f" ("mp3" "mp4" "MP3" "MP4" "avi" "mpeg" "mpg" "flv" "ogg" "mov" "mid" "midi" "wav" "aiff" "flac"))
	  ;; (dired-rainbow-define image "#f66d9b" ("tiff" "tif" "cdr" "gif" "ico" "jpeg" "jpg" "png" "psd" "eps" "svg"))
	  ;; (dired-rainbow-define log "#c17d11" ("log"))
	  ;; (dired-rainbow-define shell "#f6993f" ("awk" "bash" "bat" "sed" "sh" "zsh" "vim"))
	  ;; (dired-rainbow-define interpreted "#38c172" ("py" "ipynb" "rb" "pl" "t" "msql" "mysql" "pgsql" "sql" "r" "clj" "cljs" "scala" "js"))
	  ;; (dired-rainbow-define compiled "#4dc0b5" ("asm" "cl" "lisp" "el" "c" "h" "c++" "h++" "hpp" "hxx" "m" "cc" "cs" "cp" "cpp" "go" "f" "for" "ftn" "f90" "f95" "f03" "f08" "s" "rs" "hi" "hs" "pyc" ".java"))
	  ;; (dired-rainbow-define executable "#8cc4ff" ("exe" "msi"))
	  ;; (dired-rainbow-define compressed "#51d88a" ("7z" "zip" "bz2" "tgz" "txz" "gz" "xz" "z" "Z" "jar" "war" "ear" "rar" "sar" "xpi" "apk" "xz" "tar"))
	  ;; (dired-rainbow-define packaged "#faad63" ("deb" "rpm" "apk" "jad" "jar" "cab" "pak" "pk3" "vdf" "vpk" "bsp"))
	  ;; (dired-rainbow-define encrypted "#ffed4a" ("gpg" "pgp" "asc" "bfe" "enc" "signature" "sig" "p12" "pem"))
	  ;; (dired-rainbow-define fonts "#6cb2eb" ("afm" "fon" "fnt" "pfb" "pfm" "ttf" "otf"))
	  ;; (dired-rainbow-define partition "#e3342f" ("dmg" "iso" "bin" "nrg" "qcow" "toast" "vcd" "vmdk" "bak"))
	  ;; (dired-rainbow-define vc "#0074d9" ("git" "gitignore" "gitattributes" "gitmodules"))
	  ;; (dired-rainbow-define-chmod executable-unix "#38c172" "-.*x.*")
	  ;; ))
      #+end_src

***** DONE Dired icons
      CLOSED: [2020-04-11 Sat 04:56]

      Pretty icons for Dired!

      #+begin_src emacs-lisp
      ;; (use-package all-the-icons-dired
	;; :ensure t
	;; :delight
	;; :after dired all-the-icons
	;; :config
	;; (add-hook 'dired-mode-hook 'all-the-icons-dired-mode))
      #+end_src

** TODO PDF TOOLS

     Pdf-tools cannot handle an update.
     #+begin_src emacs-lisp
       ;; (use-package pdf-tools
	 ;; :ensure t
	 ;; :pin manual ;; don't reinstall on updates
	 ;; :init
	 ;; (pdf-tools-install))

       ;; (add-to-list 'load-path "~/.source/pdf-tools")
       ;; (require 'pdf-tools)
       ;; (eval-after-load "pdf-tools"
	 ;; (pdf-tools-install))
     #+end_src

** TODO DIARY AND CALENDAR

     It made sense for these two to be configured together.

     I want to make diary/calendar mode my default scheduling application.
     The diary will show upon entering emacs, and all the diary entries will be shown in the calendar.
   
     #+begin_src emacs-lisp
     ;; default diary file
     (setq diary-file "~/.personal/diary")

     ;; default entries shown in the diary
     (setq diary-number-of-entries 7)

     ;; date style
     (calendar-set-date-style 'european)

     ;; calendar-diary integration
     (setq calendar-view-diary-initially-flag t)
     (setq calendar-mark-diary-entries-flag t)

     ;; launch diary on startup
     (diary)
     #+end_src
   
***** TODO Future improvements
      - External notifications using dunst
      - Add/remove entries easily (org-capture?)
      - Archive old entries, keep clean file (maybe)
      - Integration with org-agenda

** TODO VTERM

     A new friend in the family! I am pretty excited about this,
  after testing it seems to be a viable option for a terminal emulator
  inside of emacs.

  #+begin_src emacs-lisp
  (use-package vterm
    :load-path "~/.source/emacs-libvterm"
    :init
    (setq vterm-kill-buffer-on-exit t)
    (setq vterm-clear-scrollback t))
  #+end_src

** DONE ORG-MODE [7/7]
***** DONE Ensure org-plus-contrib
      CLOSED: [2020-04-12 Sun 23:59]

      #+begin_src emacs-lisp
      ;; (unless (package-installed-p 'org-plus-contrib)
	;; (package-refresh-contents)
	;; (package-install 'org-plus-contrib))
      #+end_src

***** DONE Org-mode misc options
      CLOSED: [2020-04-14 Tue 15:43]

      #+begin_src emacs-lisp
      ;; prettify
      ;; (setq org-hide-leading-stars t)

      ;; tables
      ;; (define-key org-mode-map (kbd "C-x ,") 'org-table-toggle-column-width)

      ;; src options
      ;; (require 'org-tempo)

      ;; (setq org-src-fontify-natively t)

      ;; (setq org-src-tab-acts-natively t)
      ;; (setq org-confirm-babel-evaluate nil)
      ;; (setq org-edit-src-content-indentation 0)

      ;; (setq org-special-ctrl-a/e t)
      ;; (setq org-src-window-setup 'current-window)
      ;; export options -- for mail html export (fix it locally!)
      ;;    (setq org-export-with-toc nil)
      ;;  (setq org-export-with-section-numbers nil)

      ;; change todo states when all children todos are done
      ;; (defun org-summary-todo (n-done n-not-done)
	;; "Switch entry to DONE when all subentries are done, to TODO otherwise."
	;; (let (org-log-done org-log-states)   ; turn off logging
	  ;; (org-todo (if (= n-not-done 0) "DONE" "TODO"))))

      ;; (add-hook 'org-after-todo-statistics-hook 'org-summary-todo)

      ;; (setq org-enforce-todo-dependencies t)
      ;; (setq org-enforce-todo-checkbox-dependencies t)
      ;; links
      ;; (setq org-link-search-must-match-exact-headline nil)
      #+end_src

***** DONE Org-mode capture and agenda
      CLOSED: [2020-04-14 Tue 14:28]

      #+begin_src emacs-lisp
      ;; files
      ;; (setq org-directory "~/.personal")
      ;; (setq org-default-notes-file (concat org-directory "/organizer.org"))

      ;; include diary entries in agenda
      ;; (setq org-agenda-include-diary t)

      ;; TODOs
      ;; (setq org-log-done 'time)
      ;; (setq org-log-into-drawer 'LOGBOOK)
      ;; (setq org-clock-into-drawer t)


      ;; bindings
      ;; (global-set-key (kbd "C-c l") 'org-store-link)
      ;; (global-set-key (kbd "C-c a") 'org-agenda)
      ;; (global-set-key (kbd "C-c c") 'org-capture)
      ;; (global-set-key (kbd "C-c C-x C-z") 'org-resolve-clocks)

      ;; some capture functions from Zamansky's configuration
      ;; (defadvice org-capture-finalize
	  ;; (after delete-capture-frame activate)
	;; "Advise capture-finalize to close the frame"
	;; (if (equal "capture" (frame-parameter nil 'name))
	    ;; (delete-frame)))

      ;; (defadvice org-capture-destroy
	  ;; (after delete-capture-frame activate)
	;; "Advise capture-destroy to close the frame"
	;; (if (equal "capture" (frame-parameter nil 'name))
	    ;; (delete-frame)))

      ;; (defun make-capture-frame ()
	;; "Create a new frame and run org-capture."
	;; (interactive)
	;; (make-frame '((name . "capture")))
	;; (select-frame-by-name "capture")
	;; (delete-other-windows))
      #+end_src

***** DONE Org-capture templates
      CLOSED: [2020-04-14 Tue 14:42]

      #+begin_src emacs-lisp
      ;; (setq org-capture-templates
      ;;       '(("t" "Todo" entry (file+headline "" "Tasks")
      ;; 	 "* TODO %?\n  %i\n  %a")

      ;; 	("j" "Journal" entry (file+datetree "journal.org")
      ;; 	 "* %^{entry title}%^G\n%U\n  %?\n")

      ;; 	("p" "Logs for photographic process")

      ;; 	("pd" "Darkroom log" entry (file+datetree "darkroom-log.org")
      ;; 	 "* %U :darkroom:%^g\n%?" :clock-in t)

      ;; 	("r" "Rempetika lyrics" entry (file+headline "~/stixoi.org" "Στίχοι ρεμπέτικα")
      ;; 	 "* %^{ΤΙΤΛΟΣ}\n%^{ΤΡΑΓΟΥΔΙΣΤΗΣ}p%^{ΣΥΝΘΕΤΗΣ}p%^{ΡΥΘΜΟΣ}p%^{ΔΡΟΜΟΣ}p%^{ΤΟΝΟΣ}p\n%x")

      ;; 	;; ("B" "Web purchase" entry (file+headline "web-stuff.org" "Purchases")
      ;; 	;;  "* ORDERED %^{item desc.}\n\n%x\n\nEst. delivery: %?\n\nOrder placed on: %U")

      ;; 	;; ("l" "Link" entry (file+headline "web-stuff.org" "Links")
      ;; 	;;  "* %x %^g\n %?\n%U")

      ;; 	;; ("b" "Bibliography reference" entry (file "bib-references.org")
      ;; 	;;  "* @%^{.bib entry}: %^{description} %^g\n %^{page(s)} %?\n%U")

      ;; 	("c" "Contact" entry (file "contacts.org")
      ;; 	 "* %^{NICKNAME}\n%^{EMAIL}p\n:END:")
      ;; 	))
      #+end_src

***** DONE Org-contacts
      CLOSED: [2020-04-14 Tue 15:55]

      #+begin_src emacs-lisp
      ;; (use-package org-contacts
	;; :ensure nil
	;; :after org mu4e
	;; :custom (org-contacts-files '("~/.personal/contacts.org"))
	;; :bind  ("C-x M-." . 'org-contacts-view-send-email))
      #+end_src

***** DONE org-msg
      CLOSED: [2020-04-14 Tue 15:59]
      #+begin_src emacs-lisp
      (use-package org-msg
	:ensure t
	:after org mu4e
	:bind
	(:map mu4e-compose-mode-map ("M-c" . 'org-msg-edit-mode)))
      #+end_src

***** DONE org-general
      CLOSED: [2020-04-13 Mon 00:20]

      Temporary fix. Later to be declared in use-package.

      #+begin_src emacs-lisp
      ;; (evil-leader-org
	 ;; :keymaps 'org-mode-map
	 ;; :states 'normal
	 ;; "p" 'org-set-property)
      #+end_src

** WORKING LATEX

     #+begin_src emacs-lisp
     (setq TeX-parse-self t)
     (setq-default TeX-master nil)

     ;; === run xelatex on save for latex mode
     (defun latex-save-compile ()
       "Compile file after saving in latex mode. Using Xelatex."
       (when (eq major-mode 'latex-mode)
	 (when (memq this-command '(save-buffer))
	   (shell-command-to-string (format "xelatex %s" buffer-file-name)))))

     (add-hook 'after-save-hook #'latex-save-compile)
     #+end_src

** DONE MU4E [13/13]
   CLOSED: [2020-04-12 Sun 16:02]
***** DONE mu4e basic setup
      CLOSED: [2020-04-12 Sun 16:02]

      #+begin_src emacs-lisp
      ;; (add-to-list 'load-path "/usr/local/share/emacs/site-lisp/mu4e")
      ;; (require 'mu4e)


      ;; some interface options
      ;; (setq mu4e-confirm-quit nil) ;; do not confirm quitting
      ;; (setq mail-user-agent 'mu4e-user-agent) ;; make mu4e the default for email
      ;; (setq message-kill-buffer-on-exit t) ;; kill message buffer on exit
      ;; (setq mu4e-index-update-in-background t) ;; do not show me the update process
      ;; (setq mu4e-hide-index-messages t)
      ;; (setq mu4e-headers-include-related nil)
      ;; (setq mu4e-compose-dont-reply-to-self nil)
      ;; (setq mu4e-compose-signature-auto-include nil)
      ;; (setq mu4e-sent-messages-behavior 'sent)
      ;; (setq mu4e-change-filenames-when-moving t)
      ;; (setq mu4e-attachment-dir "~/Downloads")
      ;; (setq mu4e-view-show-addresses t)
      ;; (setq mu4e-headers-visible-columns 60)
      ;; (setq mu4e-split-view 'vertical) ;; should write a function: if height is longer than width, split horizontally
      ;; this one does not work out of the box. Emacs needs to be compiled with imagemagick support. Will look into this
      ;; (setq mu4e-show-images t)
      ;; (when (fboundp 'imagemagick-register-types)
	;; (imagemagick-register-types))


      ;; (setq mu4e-user-mail-address-list '("loukas.bass@gmx.com"
					  ;; "dakodeon@hotmail.com"
					  ;; "freehuggs701@gmail.com"
					  ;; "luc.bassoukos@gmail.com"))
      #+end_src

***** DONE mu4e (smtp setup)
      CLOSED: [2020-04-11 Sat 21:24]

      #+begin_src emacs-lisp
      ;; (require 'smtpmail)

      ;; (setq message-send-mail-function 'smtpmail-send-it
	    ;; smtpmail-default-smtp-server "mail.gmx.com"
	    ;; smtpmail-smtp-server "mail.gmx.com"
	    ;; smtpmail-smtp-user "loukas.bass@gmx.com"
	    ;; smtpmail-stream-type 'starttls
	    ;; smtpmail-smtp-service 587
	    ;; smtpmail-debug-info t)
      #+end_src

***** DONE mu4e sync mail
      CLOSED: [2020-04-11 Sat 23:21]

      #+begin_src emacs-lisp
      ;; (setq mu4e-get-mail-command "mbsync -c ~/.config/mbsyncrc -a") ;; default location of mbsyncrc is in ~
      ;; (setq mu4e-html2text-command "w3m -T text/html")
      ;; (setq mu4e-update-interval nil) ;; do not auto-update, this is done with cronjob
      ;; (setq mu4e-headers-auto-update t)
      #+end_src

***** DONE mu4e directories
      CLOSED: [2020-04-12 Sun 01:25]

      #+begin_src emacs-lisp
      ;; (setq mu4e-maildir (expand-file-name "~/.personal/Mail"))

      ;; default directories
      ;; (setq mu4e-drafts-folder "/loukas.bass/Drafts")
      ;; (setq mu4e-sent-folder "/loukas.bass/Sent")
      ;; (setq mu4e-trash-folder "/loukas.bass/Trash")

      ;; maildirs shortcuts
      ;; (setq mu4e-maildir-shortcuts
	    ;; '( ("/Inbox" . ?i)
	       ;; ("/loukas.bass/Inbox" . ?l)
	       ;; ("/loukas.bass/Sent" . ?s)
	       ;; ("/loukas.bass/Trash" . ?t)
	       ;; ("/loukas.bass/Drafts" . ?D)
	       ;; ("/gmail/Inbox" . ?g)
	       ;; ("/gmail_luc/Inbox" . ?G)
	       ;; ("/dakodeon/Inbox" . ?d)))
      #+end_src

***** DONE mu4e contexts
      CLOSED: [2020-04-12 Sun 05:47]

      #+begin_src emacs-lisp
      ;; (setq mu4e-contexts
	    ;; `( ,(make-mu4e-context
		 ;; :name "loukas.bass"
		 ;; :match-func (lambda (msg)
			       ;; (when msg
				 ;; (mu4e-message-contact-field-matches msg
								     ;; :to "loukas.bass@gmx.com")))
		 ;; :vars '((smtpmail-smtp-user . "loukas.bass@gmx.com")
			 ;; (smtpmail-default-smtp-server . "mail.gmx.com")
			 ;; (smtpmail-smtp-server . "mail.gmx.com")
			 ;; (user-mail-address . "loukas.bass@gmx.com")
			 ;; (user-full-name . "loukas bass")
			 ;; (mu4e-sent-folder . "/loukas.bass/Sent")
			 ;; (mu4e-drafts-folder . "/loukas.bass/Drafts")
			 ;; (mu4e-trash-folder . "/loukas.bass/Trash")))

	       ;; ,(make-mu4e-context
		 ;; :name "gmail_luc"
		 ;; :match-func (lambda (msg)
			       ;; (when msg
				 ;; (mu4e-message-contact-field-matches msg
								     ;; :to "luc.bassoukos@gmail.com")))
		 ;; :vars '((smtpmail-smtp-user . "luc.bassoukos@gmail.com")
			 ;; (smtpmail-default-smtp-server . "smtp.gmail.com")
			 ;; (smtpmail-smtp-server . "smtp.gmail.com")
			 ;; (user-mail-address . "luc.bassoukos@gmail.com")
			 ;; (user-full-name . "luc bassoukos")
			 ;; (mu4e-sent-folder . "/gmail_luc/[Gmail]/Sent Mail")
			 ;; (mu4e-drafts-folder . "/gmail_luc/Drafts")
			 ;; (mu4e-trash-folder . "/gmail_luc/Trash")))

	       ;; ,(make-mu4e-context
		 ;; :name "gmail"
		 ;; :match-func (lambda (msg)
			       ;; (when msg
				 ;; (mu4e-message-contact-field-matches msg
								     ;; :to "freehuggs701@gmail.com")))
		 ;; :vars '((smtpmail-smtp-user . "freehuggs701@gmail.com")
			 ;; (smtpmail-default-smtp-server . "smtp.gmail.com")
			 ;; (smtpmail-smtp-server . "smtp.gmail.com")
			 ;; (user-mail-address . "freehuggs701@gmail.com")
			 ;; (user-full-name . "freexon")
			 ;; (mu4e-sent-folder . "/gmail/[Gmail]/Sent Mail")
			 ;; (mu4e-drafts-folder . "/gmail/Drafts")
			 ;; (mu4e-trash-folder . "/gmail/Trash")))

	       ;; ,(make-mu4e-context
		 ;; :name "dakodeon"
		 ;; :match-func (lambda (msg)
			       ;; (when msg
				 ;; (mu4e-message-contact-field-matches msg
								     ;; :to "dakodeon@hotmail.com")))
		 ;; :vars '((smtpmail-smtp-user . "dakodeon@hotmail.com")
			 ;; (smtpmail-default-smtp-server . "smtp.office365.com")
			 ;; (smtpmail-smtp-server . "smtp.office365.com")
			 ;; (user-mail-address . "dakodeon@hotmail.com")
			 ;; (user-full-name . "loukas b")
			 ;; (mu4e-sent-folder . "/dakodeon/Sent")
			 ;; (mu4e-drafts-folder . "/dakodeon/Drafts")
			 ;; (mu4e-trash-folder . "/dakodeon/Trash")))))

      ;; (setq mu4e-context-policy 'pick-first)

      ;; it is useful for a lot of queries to have a list of contexts

      ;; (defvar l/mu4e-context-names
	;; (mapcar (lambda (x) (car x))
		;; (cl-map 'list (lambda (context)
				;; (cons (mu4e-context-name context) context))
			;; mu4e-contexts)))
      #+end_src

***** DONE mu4e bookmarks
      CLOSED: [2020-04-12 Sun 13:47]

      #+begin_src emacs-lisp
      ;; get only the last received message
      ;; (defun l/mu4e-fetch-last-received-msg ()
	;; "Shows the last received message in mu4e"
	;; (interactive)
	;; (let* ((query (string-trim (format "%s" (mapcar (lambda (x) (concat "maildir:/" x "/Inbox OR ")) l/mu4e-context-names)) "(" " OR )")))
	  ;; (mu4e-headers-search (concat "msgid:" (string-trim (shell-command-to-string (concat "mu find -n 1 --fields \"i\" --sortfield=date --reverse " query)) nil "\n")))))

      ;; (eval-after-load "evil"
	;; '(progn
	  ;; (evil-define-key 'normal mu4e-main-mode-map
	    ;; "gl" 'l/mu4e-fetch-last-received-msg)
	  ;; (evil-define-key 'normal mu4e-headers-mode-map
	    ;; "gl" 'l/mu4e-fetch-last-received-msg)))


      ;; brazenly stolen from the manual, then changed to fit my contexts
      ;; Asks for how many days' messages to show
      ;; (defun l/mu4e-bookmark-num-days-old-query (days-old)
	;; (interactive (list (read-number "How many days? " 2)))
	;; (let ((start-date (subtract-time (current-time) (days-to-time days-old)))
	      ;; (maildirquery (string-trim (format "%s" (mapcar (lambda (x) (concat "maildir:/" x "/Inbox OR ")) l/mu4e-context-names)) "(" " OR )")))
	  ;; (concat "(" maildirquery ") AND date:"
		  ;; (format-time-string "%Y%m%d" start-date))))

      ;; (setq mu4e-bookmarks
	    ;; `( ,(make-mu4e-bookmark
		 ;; :name "Unread messages"
		 ;; :query "flag:unread AND NOT flag:trashed"
		 ;; :key ?u)
	       ;; ,(make-mu4e-bookmark
		 ;; :name "Today's messages"
		 ;; :query "date:today..now"
		 ;; :key ?t)
	       ;; ,(make-mu4e-bookmark
		 ;; :name "Messages from last [x] days"
		 ;; :query (lambda () (call-interactively 'l/mu4e-bookmark-num-days-old-query))
		 ;; :key ?w)))			;; TODO: fetch messages of the last x minutes

      #+end_src

***** REJECTED mu4e open in headers of specific account
      CLOSED: [2020-04-12 Sun 06:03]

      #+begin_src emacs-lisp
      ;; (defun mu4e-open-in-headers (account)
	;; "Open mu4e in account's Inbox"
	;; (interactive)
	;; (mu4e~start)
	;; (if (get-buffer "*mu4e-headers*" )
	    ;; (switch-to-buffer "*mu4e-headers*"))
	;; (mu4e-headers-search (concat "maildir:/" account "/Inbox")))
      #+end_src

***** DONE mu4e open directly in unread messages
      CLOSED: [2020-04-12 Sun 05:58]

      #+begin_src emacs-lisp
      ;; (defun l/mu4e-open-unread ()
	;; "Open mu4e in unread messages."
	;; (interactive)
	;; (mu4e-headers-search "flag:unread AND NOT flag:trashed"))
      #+end_src

***** DONE mu4e change split depending on window dimensions
      CLOSED: [2020-04-12 Sun 15:53]

      #+begin_src emacs-lisp
      ;; (defun l/mu4e-view-change-split-advice ()
	;; "Used to advice `mu4e-headers-view-message'.
      ;; Changes the way windows split when viewing a message depending on
      ;; current window size. If height is greater than width, split
      ;; horizontally. Else, split vertically"
	;; (if (> (window-pixel-height) (window-pixel-width))
	    ;; (setq mu4e-split-view 'horizontal)
	  ;; (setq mu4e-split-view 'vertical)))

      ;; (advice-add 'mu4e-headers-view-message :before #'l/mu4e-view-change-split-advice)

      #+end_src

***** DONE mu4e external notifications (for i3blocks)
      CLOSED: [2020-04-12 Sun 15:52]

      #+begin_src emacs-lisp
      ;; (add-hook 'mu4e-index-updated-hook
		;; (defun mu4e-signal-i3blocks ()
		  ;; (shell-command "pkill -RTMIN+2 i3blocks")))

      ;; (add-hook 'mu4e-view-mode-hook 'mu4e-signal-i3blocks)
      #+end_src

***** DONE Contacts management
      CLOSED: [2020-04-12 Sun 14:29]

  Manage contacts with org-contacts

  #+begin_src emacs-lisp
  ;; (setq mu4e-org-contacts-file "~/.personal/contacts.org")

  ;; (add-to-list 'mu4e-headers-actions
	       ;; '("org-contact-add" . mu4e-action-add-org-contact) t)

  ;; (add-to-list 'mu4e-view-actions
	       ;; '("org-contact-add" . mu4e-action-add-org-contact) t)
  #+end_src

***** REJECTED Start mu4e
      CLOSED: [2020-04-12 Sun 14:56]

  Auto start mu4e on emacs startup

      #+begin_src emacs-lisp
      ;; (global-set-key (kbd "C-x m") 'mu4e)
      ;; (mu4e~start)
      ;; (mu4e-update-mail-and-index t)
      #+end_src
***** DONE mu4e general
      CLOSED: [2020-04-12 Sun 13:44]

      Temporary fix. Later to be declared in use-package

      #+begin_src emacs-lisp
      ;; (evil-leader 'normal
	;; "m" 'l/mu4e-open-unread)
      #+end_src
** TODO CUSTOM FILE SHORTCUTS

     #+begin_src emacs-lisp
     ;; (defun goto-file-or-dir (f)
       ;; "Find the given file. If file is a directory, run dired"
       ;; (if (file-directory-p f)
	   ;; (helm-find-files-1 f)
	 ;; (if (file-exists-p f)
	     ;; (find-file f))))

     ;; create a prefix
     (define-prefix-command 'z-map)
     (global-set-key (kbd "C-x g") 'z-map)

     (define-key z-map (kbd "E") (lambda () (interactive) (find-file "~/.emacs.d/init.el")))
     (define-key z-map (kbd "e") (lambda () (interactive) (find-file "~/.emacs.d/my-config.org")))
     (define-key z-map (kbd "i") (lambda () (interactive) (find-file "~/.config/i3/i3.conf")))
     (define-key z-map (kbd "r") (lambda () (interactive) (find-file "~/.config/ranger/rc.conf")))
     (define-key z-map (kbd "x") (lambda () (interactive) (find-file "~/.Xresources")))
     (define-key z-map (kbd "z") (lambda () (interactive) (find-file "~/.zshrc")))
     (define-key z-map (kbd "h") (lambda () (interactive) (find-file "~/")))
     (define-key z-map (kbd "P") (lambda () (interactive) (find-file "~/Pictures/")))
     (define-key z-map (kbd "p") (lambda () (interactive) (find-file "~/.personal/")))
     (define-key z-map (kbd "C") (lambda () (interactive) (find-file "~/.config/")))
     (define-key z-map (kbd "D") (lambda () (interactive) (find-file "~/Downloads/")))
     (define-key z-map (kbd "d") (lambda () (interactive) (find-file "~/Documents/")))
     (define-key z-map (kbd "!") (lambda () (interactive) (find-file "~/.source/dotfiles/")))
     (define-key z-map (kbd "S") (lambda () (interactive) (find-file "~/.local/bin/")))
     #+end_src
 
** TODO GAMES
***** SNAKE
    
      #+begin_src emacs-lisp
      (eval-after-load "evil"
	'(progn
	   (evil-set-initial-state 'snake-mode 'normal)
	   (evil-define-key 'normal snake-mode-map
	     "h" 'snake-move-left
	     "j" 'snake-move-down
	     "k" 'snake-move-up
	     "l" 'snake-move-right
	     "p" 'snake-pause-game
	     "q" 'quit-window
	     "N" 'snake-start-game)))
      #+end_src
***** 2048

      #+begin_src emacs-lisp
      (use-package 2048-game
	:ensure t)
      #+end_src


