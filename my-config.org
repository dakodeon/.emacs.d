#+TITLE: My Emacs configuration
#+AUTHOR: dakodeon
#+EMAIL: dakodeon@hotmail.com

* INTRODUCTION

Emacs configuration managed with org-mode and use-package.

The code snippets below are loaded by =init.el=, which also loads
=use-package=.

** TODO Attempting a more concise documentation
  - Start by loading frameworks like evil and general (avoid writing eval-after-load all the time.)
  - Use :general use-package delcaration to specify leader keys and the :general keyword in all other packages. (maybe)
  - Generalise the use of use package, for consistency


* GENERAL

  General provides a universal way of binding keys, which integrates
  both define-key and evil-define-key. It also offers a way to
  immitate vim's leader key functionality, both locally and globally.
  This is great for someone who uses evil, as bindings can be a mess.

  It is supposed to provide a key for use-package (:general), which
  can be used for per-package configuration. That way I can define all
  leaders in general's declaration and then assign key chords in a
  per-package basis.

  I haven't really played around with this package, so I am not sure
  if I will keep it around.
  
   #+begin_src emacs-lisp
   (use-package general
     :ensure t
     :after evil
     :bind
     ("C-h G" . 'general-describe-keybindings)
     :config
     (general-create-definer evil-leader
       :prefix "SPC")
     (general-create-definer evil-leader-org
       :prefix "SPC o"))
   #+end_src

* EVIL

  I tried evil-mode after being forced to stop using my arrow keys, as
  they were broken. So I got used to 'h,j,k,l'. I ended up really
  enjoying modal editing. Already using i3, it was a logical next
  step.

  So I decided to base my Emacs build on Evil mode.

  The most imortant change that I made is the replacement of insert
  state with normal emacs. That way I can have emacs bindings while
  editing text.

  I also use Evil collection. This is a package with preconfigured
  evil-bindings for many emacs packages, like mu4e and org-mode. I
  dont enable evil collection for all packages. For example, I define
  custom bindings for dired, due to some buggy behaviour (for some
  reason I was unable to rebind a key bound by evil collection).

** Evil collection

    #+begin_src emacs-lisp
    (use-package evil-collection
      :after evil
      :ensure t
      :config
      (evil-collection-init 'mu4e)
      (evil-collection-init 'image-dired)
      (evil-collection-init 'outline)
      (evil-collection-init 'help)
      (evil-collection-init 'man)
      (evil-collection-init 'package-menu)
      (evil-collection-init 'pdf)
      (evil-collection-init 'tetris)
      (evil-collection-init '2048-game))
    #+end_src

** Evil mode

    * Note: there's a bunch of bindings in normal-state beause of the
    visual-line-mode that I use. I have to get rid of that at some
    point.

    #+begin_src emacs-lisp
    (use-package evil
      :ensure t
      :init
      (setq evil-move-cursor-back nil)
      (setq evil-want-C-u-scroll t)
      (setq evil-want-fine-undo t)
      (setq evil-normal-state-cursor 'box)
      (setq evil-emacs-state-cursor 'bar)
      (setq evil-replace-state-cursor 'hbar)
      (setq evil-want-integration t)
      (setq evil-want-keybinding nil)
      (setq evil-find-skip-newlines t)
      :config
      (evil-mode 1)
      (evil-set-initial-state 'Info-mode 'emacs)
      (evil-set-initial-state 'org-capture-mode 'emacs)
      (evil-set-initial-state 'mu4e-compose-mode 'emacs)
      (evil-set-initial-state 'org-msg-mode 'emacs)
      ;; (evil-set-initial-state 'package-menu-mode 'emacs)
      (evil-set-initial-state 'special-mode 'emacs)
      ;; Use emacs state instead of insert state
      (evil-define-state emacs
	"Emacs used as insert state in evil."
	:tag " <EE> "
	:message "-- EMACS INSERT --"
	:input-method t)
      (defadvice evil-insert-state
	  (around emacs-state-instead-of-insert-state activate)
	"Emacs instead of Insert."
	(evil-emacs-state))
      :bind
      (:map evil-normal-state-map
	    ("j" . 'evil-next-visual-line)
	    ("k" . 'evil-previous-visual-line)
	    ("^" . 'evil-beginning-of-visual-line)
	    ("g^" . 'evil-first-non-blank-of-visual-line)
	    ("$" . 'evil-end-of-visual-line)
	    ;; ("g ^" . 'evil-beginning-of-line)
	    ("g$" . 'evil-end-of-line)
	    ([down] . 'evil-next-visual-line)
	    ([up] . 'evil-previous-visual-line)
	    ("C-S-o" . 'evil-jump-forward)
	    ("*" . nil) ;;prefix
	    ("*w" . 'evil-search-word-forward)
	    :map evil-emacs-state-map
	    ([escape] . 'evil-normal-state)))
     #+end_src

* AUTOCOMPLETE

  This is just a generic autocompletion framework. I haven't tweaked
  it in any way and it only works most of the time. For example,
  filename completion never worked as intended.

  Anyhow, it is still useable, but I guess I will try something like
  company soon.

   #+begin_src emacs-lisp
   (use-package auto-complete
     :ensure t
     :delight (auto-complete-mode " ⋯")
     :init
     (ac-config-default)
     (global-auto-complete-mode t)
     (setq ac-sources (append ac-sources '(ac-sources-filename)))
     (setq ac-ignore-case nil))
   #+end_src
     
* NAVIGATION WITH IVY
*** Ivy-mode
    
    Ivy is a narrowing and completion fraqmework for emacs. I switched
    to it from helm, because it was a lot easier to customize.

    Together with counsel, ivy provides alternatives to emacs
    commands, like switch-buffer, find-file, M-x etc. It also
    interfaces with some external tools, like fzf, ripgrep and wmctrl,
    which is great.

    I wrote some custom functions for Ivy to improve upon the existing
    functionality of inserting in the minibuffer text from the current
    buffer. However, these were rendered obsolete by a somewhat hidden
    feature of Ivy (ivy-next-history-element), which does exactly
    that, but better. I keep those, because of the code I wrote.

   #+begin_src emacs-lisp
   (use-package ivy
     :ensure t
     :delight
     :init
     (setq ivy-use-virtual-buffers t)
     (setq ivy-count-format "(%d/%d) ")
     :config
     ;; better word and symbol yanking in the minibuffer
     ;; UPDATE: -- I just learned that M-n calls `ivy-next-history-element', which does exactly what I want,
     ;; it yanks to the minibuffer the symbol or the word at point, or the active region, so...
     (defun l/ivy-yank-word ()
       "Pull word at point from buffer into search string."
       (interactive)
       (let (text)
	 (with-ivy-window
	   (setq text (thing-at-point 'word 'no-properties)))
	 (when text
	   (insert (replace-regexp-in-string
		    "  +" " "
		    (ivy--yank-handle-case-fold text)
		    t t)))))

     (defun l/ivy-yank-symbol ()
       "Pull symbol at point from buffer into search string."
       (interactive)
       (let (text)
	 (with-ivy-window
	   (setq text (thing-at-point 'symbol 'no-properties)))
	 (when text
	   (insert (replace-regexp-in-string
		    "  +" " "
		    (ivy--yank-handle-case-fold text)
		    t t)))))
     :bind
     (:map ivy-minibuffer-map
     ("M-w" . l/ivy-yank-word)
     ("M-s" . l/ivy-yank-symbol)))
   #+end_src
*** Counsel
    
    Counsel is essentially the frontend of ivy. It packs all the
    useful ivy-enriched commands.

    Some of the functionality I use:

    - counsel-fzf: [[https://github.com/junegunn/fzf][Fzf]] is a fuzzy finder for files. Great tool! I
      added functionality from [[https://protesilaos.com/dotemacs][prot's configuration]] that enables us to
      switch root directory for a search (although I simplified it, as
      I still don't use counsel-rg). I also wrote a wrapper around the
      default function so that I can search for marked text if the
      region is active.
    - cousel-outline: Navigate an org file by searching it's headers.
      Also great! Just for customization's sake, I wrote an action to
      begin a fzf search with selected candidate, inspired by the way
      Prot handles switching from fzf to rg and vice-versa.
    - l/counsel-sufraw (to be renamed): [[https://gitlab.com/surfraw/Surfraw][Surfraw]] is a tool for
      searching the web from the command line. It provides a set of
      scripts (they are called elvi) which correspond each to a search
      engine (eg. Google, DuckDuckGo etc). Although there is already a
      package that integrates surfraw with ivy ([[https://github.com/jws85/counsel-surfraw/blob/master/counsel-surfraw.el][counsel-surfraw]]) I
      wrote my own, just for practice and for the sake of it! I ended
      up using some code from this package though. I also took an
      extra step (just for the bling!) and took the elvi's
      descriptions and passed them to ivy-rich (see next section).

    
   #+begin_src emacs-lisp
   (use-package counsel
     :ensure t
     :delight
     :config
     (defun l/counsel-fzf ()
       "Wraps around `counsel-fzf' to allow input from marked region."
       (interactive)
       (let (text)
	 (if mark-active
	     (setq text (buffer-substring-no-properties (region-beginning) (region-end))))
	 (counsel-fzf text)))

     ;; based on code by prot
     (defun l/counsel-fzf-dir (arg)
       "Specify root directory for `counsel-fzf'."
       (counsel-fzf ivy-text
		    (read-directory-name
		     (concat (car (split-string counsel-fzf-cmd))
			     " in directory: "))))

     (ivy-add-actions 'counsel-fzf
		      '(("r" l/counsel-fzf-dir "change root directory")))

   ;; from counsel-outline to fzf -- I should split these.
   (defun l/counsel-fzf-from-outline (arg)
     "Search for outline header with fzf."
     (counsel-fzf (car (last (split-string (substring-no-properties (ivy-state-current ivy-last)) "/")))))

   (ivy-add-actions 'counsel-outline
		    '(("f" l/counsel-fzf-from-outline "search with fzf")))

     ;; surfraw frontend
     (defvar l/surfraw-elvi-list
       (mapcar (lambda (x) (split-string x "\t+-- "))
	       (seq-remove
		(lambda (str) (not (string-match-p "--" str)))
		(split-string (shell-command-to-string "surfraw -elvi") "\n")))
       "An association list of elvi. Used by `l/ivy-surfraw'")

     (defun l/ivy-rich--ivy-surfraw-describe-elvi (elvi)
       (car (cdr (assoc elvi l/surfraw-elvi-list))))

     (defun l/ivy-surfraw ()
       "Search the web with surfraw. If region is active, search for that."
       (interactive)
       (let (text)
	 (if mark-active
	     (setq text (buffer-substring-no-properties (mark) (point)))
	   (setq text (read-string "What u wanna search? ")))
	 (ivy-read "Select search engine: "
		   (mapcar (lambda (entry) (car entry)) l/surfraw-elvi-list)
		   :action (lambda (x)
			     (let ((engine (replace-regexp-in-string " +.*$" "" x)))
			       (shell-command (concat "surfraw " engine " " (shell-quote-argument text)))))
		   :caller 'l/ivy-surfraw)))

     (eval-after-load "evil"
       '(progn
	  (evil-define-key 'normal org-mode-map "**" 'counsel-outline)))
     (ivy-mode 1)
     :bind
     (("M-x" . counsel-M-x)
     ("C-h f" . counsel-describe-function)
     ("C-h v" . counsel-describe-variable)
     ("C-c f" . l/counsel-fzf)
     ("C-c g" . counsel-rg)
     ("C-c b" . l/ivy-surfraw)))
   #+end_src
   
**** TODO Pack l/counsel-sufraw:
     I should keep this in a separate file and load it as a package.

*** TODO Swiper

    I should add here the configuration about swiper.

*** Other functionality
 
    Here is some extra packages for ivy/counsel/swiper:

**** AMX

     AMX is a rating system for selection candidates. Most rated
     candidates are more likely to appear fisrt when using ivy.
    
    #+begin_src emacs-lisp
    (use-package amx
      :ensure t
      :after ivy
      :custom
      (amx-backend 'auto)
      (amx-save-file "~/.emacs.d/amx-items")
      :config
      (amx-mode 1))
    #+end_src

**** Ivy-rich

     Ivy-rich provides help strings to be displayed alongside ivy
     candidates. Really useful for some quick reference.

     I added functionality for my ivy-surfraw function.

    #+begin_src emacs-lisp
    (use-package ivy-rich
      :ensure t
      :config
      (plist-put ivy-rich-display-transformers-list
	       'l/ivy-surfraw '(:columns
				((ivy-rich-candidate (:width 20))
				 (l/ivy-rich--ivy-surfraw-describe-elvi)
				 )))
      (setcdr (assq t ivy-format-functions-alist) #'ivy-format-function-line)
      (ivy-rich-mode 1))
    #+end_src

**** Ivy-posframe

     Ivy-posframe provides custom positioning of the minibuffer
     depending on which function is called.

     The way I set it up is essentially copied from Prot's
     configuration. The default is for the minibuffer to be displayed
     as a box in the center of the frame, but for some functions, like
     swiper for example, it is best to be kept in the traditional
     position.

#+begin_src emacs-lisp
    (use-package ivy-posframe
      :ensure t
      :delight
      :custom
      (ivy-posframe-display-functions-alist
       '((complete-symbol . ivy-posframe-display-at-point)
	 (counsel-describe-function . nil)
	 (counsel-describe-variable . nil)
	 (swiper . nil)
	 (swiper-isearch . nil)
	 (t . ivy-posframe-display-at-frame-center)))
      :config
      (ivy-posframe-mode 1))
    #+end_src

* DIRED

  Dired, the DIRectory EDitor, is the default file manager inside
  emacs. It uses ls with ls switches to generate an editable buffer of
  files lists, in which you can do whatever you would normally do in
  any file manager, and maybe more.

  I customized dired up to the point that I am very happy with the
  workflow achieved. This is a really long config, so I guess it is
  best to document it along the way.

** Defaults

   Here I define some defaults for dired. These include the default ls
   switches that generate the dired buffer, the use of dwim (do what I
   mean) while copying and moving (meaning that when performing a copy
   or move action the default target is the dired buffer in the other
   window, if existing), also adding hide-details-mode to the hook, as
   well as fixing a bug caused by a package no longer existent
   (something like a digital equivalent of a ghost limb).

   One drastic change I made to the defaults is the way dired shows up
   in the modeline. Delight does not work for dired, as its modeline
   output changes every time the ls flags change. This clutters the
   modeline as, for example, one flag that I use is
   '--group-directories-first'... I discovered the culprit: it was the
   function 'dired-sort-set-mode-line'. So, I completely redefined the
   function to output my custom names instead (note -- I know I should
   just advise the function, not completely redefine it, but at the
   time I was not familiar enough with advising. I might look into it
   soon).
  
  #+begin_src emacs-lisp
  (use-package dired
    :init
    (setq dired-dwim-target t)
    (setq dired-listing-switches "-Alh") ;; human-readable sizes, also omit . and ..
    :config
    ;; This hook seems to be added automatically to my 'custom.el' file
    ;; and breaks dired. I have to find out where it comes from. It was
    ;; a part of the `ranger' package, which I have deleted.
    (remove-hook 'dired-mode-hook 'ranger-set-dired-key)

    (add-hook 'dired-mode-hook 'dired-hide-details-mode) ;; list only filenames

    ;; modeline hack -- should replace this with advice
    (defun dired-sort-set-mode-line ()
      ;; Set mode line display according to dired-actual-switches.
      ;; Mode line display of "by name" or "by date" guarantees the user a
      ;; match with the corresponding regexps.  Non-matching switches are
      ;; shown literally.
      (when (eq major-mode 'dired-mode)
	(setq mode-name
	      (let (case-fold-search)
		(cond ((string-match-p
			(concat (regexp-quote "-Alh") "\\(\\s-\\|$\\)")
			dired-actual-switches)
		       "")
		      ((string-match-p
			(concat (regexp-quote "-Alht") "\\(\\s-\\|$\\)")
			dired-actual-switches)
		       "⇓D")
		      ((string-match-p
			(concat (regexp-quote "-AlhS") "\\(\\s-\\|$\\)")
			dired-actual-switches)
		       "⇓S")
		      ((string-match-p
			(concat (regexp-quote "-AlhX") "\\(\\s-\\|$\\)")
			dired-actual-switches)
		       "⇓X")
		      (t
		       "⇓?"))))
	(if (string-match-p
	     (regexp-quote " --group-directories-first")
	     dired-actual-switches)
	    (setq mode-name (concat mode-name "⋮"))
	  (setq mode-name (replace-regexp-in-string "⋮" "" mode-name)))
	(force-mode-line-update))))
  #+end_src

** Some basic customization

   Some tweaks of basic behaviour that I felt were missing:
   
   - The default behaviour when moving to the beginning / end of the
     buffer is to treat it like a normal buffer, instead I wanted to
     move to the first / last line in the file list. I found these
     code snippets code snippets from a file called [[https://www.emacswiki.org/emacs/dired-extension.el][dired-extension]]
     that was posted in emacswiki.
   - The default behaviour when marking a file is to mark and move
     forward. This makes it really easy to mark a bunch of consecutive
     files. But what about in reverse? Let's define a function to do
     exactly that!
   - The ability to kill lines of a dired buffer so that you can
     narrow down the files you're working on is very useful. More
     useful is to be able to do it on a selection of files.
   - After I started using emacs as my mail client, I thought it would
     be great to use dired to attach files to an email. Apparently
     someone else also thought about this in [[https://emacs.stackexchange.com/questions/14652/attach-multiple-files-from-the-same-directory-to-an-email-message][this]] question in
     stackexchange. This is the provided function, with the ability to
     attach all marked files. /NOTE: this does not always work as
     intended, and anyways I don't use it as much. It is worth
     checking out however./

   #+begin_src emacs-lisp
   (use-package emacs
     :config
     ;; go to first / last file line
     (defun dired-goto-first-file ()
	  "Move cursor to first file of dired."
	  (interactive)
	  (goto-char (point-min))
	  (while (not (dired-move-to-filename))
	    (call-interactively 'dired-next-line)))

     (defun dired-goto-last-file ()
       "Move cursor to last file of dired."
       (interactive)
       (goto-char (point-max))
       (while (not (dired-move-to-filename))
	 (call-interactively 'dired-previous-line)))

     ;; mark and move backwards
     (defun l/dired-mark-backwards ()
       "Mark file at point and move backwards."
       (interactive)
       (if (dired-move-to-filename)
	   (progn
	     (dired-mark 1)
	     (dired-previous-line 2))))

     ;; narrow to marked files
     (defun l/dired-narrow-to-marked-files ()
       "Show only marked files in dired buffer."
       (interactive)
       (let ((files (dired-get-marked-files)))
	 (unless (eq (length files) 1)
	   (dired-toggle-marks)
	   (dired-do-kill-lines))))

     ;; attach marked files to email
     (defun compose-attach-marked-files ()
       "Compose mail and attach all the marked files from a dired
   buffer."
       (interactive)
       (let ((files (dired-get-marked-files)))
	 (compose-mail nil nil nil t)
	 (dolist (file files)
	   (if (file-regular-p file)
	       (mml-attach-file file
				(mm-default-file-encoding file)
				nil "attachment")
	     (message "skipping non-regular file %s" file))))))
   #+end_src

** Sorting functions

   Although the use of ls switches can be very useful for diferent
   sorting options, dired by default does not provide this kind of
   functionality. Here I define some functions to switch between
   sorting by name, by date, by size, by extension, and grouping of
   directories first as a toggle on top of the other switches.

   #+begin_src emacs-lisp
   (use-package dired
     :config
     ;; sort by
     (defun l/dired-sort-by (sw)
       "Sort dired buffer by given switches and go to first line. If
   the switches provided are the same with the current switches, do
   nothing"
       (let ((switches dired-actual-switches))
	 (unless (string= sw switches)
	   (dired-sort-other sw)
	   (dired-goto-first-file))))
  
     ;; callable functions
     ;; by name
     (defun l/dired-sort-by-name ()
       "Sort by name. Calls `l/dired-sort-by'."
       (interactive)
       (l/dired-sort-by "-Alh"))
  
     ;; by date
     (defun l/dired-sort-by-date ()
       "Sort by date. Calls `l/dired-sort-by'."
       (interactive)
       (l/dired-sort-by "-Alht"))
  
     ;; by size
     (defun l/dired-sort-by-size ()
       "Sort by size. Calls `l/dired-sort-by'."
       (interactive)
       (l/dired-sort-by "-AlhS"))
  
     ;; by extension
     (defun l/dired-sort-by-ext ()
       "Sort by extension. Calls `l/dired-sort-by'."
       (interactive)
       (l/dired-sort-by "-AlhX"))
  
     ;; toggle directories first
     (defun l/dired-sort-dirs-first ()
       "Toggles grouping directories first."
       (interactive)
       (let ((switches dired-actual-switches))
	 (if (string-match-p (regexp-quote " --group-directories-first") switches)
	     (setq switches (replace-regexp-in-string " --group-directories-first" "" switches))
	   (setq switches (concat switches " --group-directories-first")))
	 (dired-sort-other switches))
       (dired-goto-first-file)))
   #+end_src

** External programs

  Definitions of some "external" functions. These are functions that
  act on files or lists of files using some external tool. Those
  include:

  - dired-get-size: calls du and outputs the size on the minibuffer. I
    got this from [[https://www.emacswiki.org/emacs/dired-extension.el][this]] post on emacswiki, from the same package called
    dired-extension mentioned previously. I also left the chinese text
    inside!
  - l/unmount-drive: if called on a mountpoint, it unmounts the drive
    mounted there. Really simple function, as I rarely use it, and
    only for this, quickly unmount a drive if I am already there.
  - l/atool-pack and unpack: atool is a script for managing file
    archives. I tried the existing [[https://github.com/HKey/dired-atool][dired-atool]] package from github,
    but I didn't like it, so I wrote my own functions with modified
    code from this project. I prefered something simpler and with nice
    output.
  - l/get-subtitles: uses sublime, a command-line tool to download
    subtitles written in python. Although the implementation is mine,
    I got some basic ideas from [[http://ergoemacs.org/emacs/elisp_call_shell_command.html][this post about 'start-process']] on
    ergoemacs and [[https://stackoverflow.com/questions/17075920/passing-list-to-rest-args?rq=1][this one about 'apply']] on stackoverflow.
  - l/change-desktop-background: uses feh, a minimal image viewer, to
    set the desktop background with the file at point. Provides a menu
    with different fits.
    
  #+begin_src emacs-lisp
  (use-package dired
    :config
    ;; get filesize
    (defun dired-get-size ()
      "Get total size of marked files with `du' command.
       If not marked any files, default is current file or directory."
      (interactive)
      (let ((files (dired-get-marked-files)))
	(with-temp-buffer
	  (apply 'call-process "/usr/bin/du" nil t nil "-sch" files)
	  (message "%s"
		   (progn
		     (re-search-backward "\\(^[0-9.,]+[A-Za-z]+\\).*\\(total\\|总用量\\)$")
		     (match-string 1))))))

    ;; unmount drive from mountpoint
    (defun l/unmount-drive ()
      "Unmount selected directories, if they correspond to mountpoints."
      (interactive)
      (let ((dirs (dired-get-marked-files)))
	(dired-do-shell-command "mountpoint -q ? && sudo umount ? && sudo rmdir ?" nil dirs)
	(revert-buffer)))

    ;; pack and unpack
    (defun l/atool-pack ()
      "Use the `atool' program to pack some files."
      (interactive)
      (when (eq major-mode 'dired-mode)
	(let ((files (dired-get-marked-files t))
	      (archive (expand-file-name
			(read-file-name "Pack files as:" nil nil nil)))
	      (process-connection-type nil))
	  (if (get-buffer "*atool-pack*")
	      (kill-buffer "*atool-pack*"))
	  (apply 'start-process
		 (append (list "atool-pack" "*atool-pack*" "atool" "--explain" archive "-a") files))
	  (switch-to-buffer-other-window "*atool-pack*")
	  (special-mode))))
  
    (defun l/atool-unpack ()
      "Use the `atool' program to unpack some archives."
      (interactive)
      (when (eq major-mode 'dired-mode)
	(let ((files (dired-get-marked-files t))
	      (dest (expand-file-name
		     (read-directory-name "Unpack files to:"
					  (dired-dwim-target-directory) nil nil)))
	      (process-connection-type nil))
	  (if (get-buffer "*atool-unpack*")
	      (kill-buffer "*atool-unpack*"))
	  (if (not (file-directory-p dest))
	      (make-directory dest))
	  (apply 'start-process
		 (append (list "atool-unpack" "*atool-unpack*" "atool" "--explain" "-X" dest) files))
	  (switch-to-buffer-other-window "*atool-unpack*")
	  (special-mode))))

    ;; get subtitles
    (defun l/get-subtitles ()
      "Get subtitles for marked files while in a dired buffer. Depends on subliminal, so it has to be on your system."
      (interactive)
      (when (eq major-mode 'dired-mode)
	(let* ((lang-list '("en" "gr"))
	       (lang (completing-read "Select language: " lang-list nil t))
	       (files (dired-get-marked-files))
	       (process-connection-type nil))
	  (if (get-buffer "*get-subtitles*")
	      (kill-buffer "*get-subtitles*"))
	  (apply 'start-process
		 (append (list "get-subtitles" "*get-subtitles*" "subliminal" "download" "-l" lang) files))
	  (switch-to-buffer-other-window "*get-subtitles*")
	  (special-mode))))

    ;; change desktop background
    (defun l/change-desktop-background ()
      "Change the desktop background using feh."
      (interactive)
      (let ((fit-type (completing-read "Select fit: " '("scale" "center" "fill" "max") nil t))
	    (entry (shell-quote-argument (expand-file-name (dired-file-name-at-point))))
	    (targetfile (shell-quote-argument (expand-file-name "~/.config/.wallpaper.jpg"))))
	(setq cpcmd (concat "cp " entry " " targetfile))
	(setq fehcmd (concat "feh --bg-" fit-type " " targetfile))
	(setq cmd (concat cpcmd " && " fehcmd))
	(shell-command cmd))))
  #+end_src

  I also defined a custom keymap with shortcuts to most used
  directories, similar to the navigation system in ranger (gh -- go to
  home, gD -- go to Downloads etc)


  Another part of dired's configuration is the evil bindings. I did
  not use the pre-existing bindings from evil-collection, due to some
  buggy behavior that wouldn't let me rebind a key. Maybe I will
  revisit this possibility as my config tidies up, it could be some
  weird conflict that would resolve itself with a tidier config.

** Custom maps

   Here are declared two prefix commands with their bindings:

   - l/dired-nav-map offers ranger-like shortcuts to directories.
   - l/dired-my-ext-cmds includes keybindings for the functions that
     call external programs.

   #+begin_src emacs-lisp
   (use-package dired
     :config
     ;; navigation map
     (define-prefix-command 'l/dired-nav-map)

     (general-def l/dired-nav-map
       "h" (lambda () (interactive) (dired "~/"))
       "D" (lambda () (interactive) (dired "~/Downloads/"))
       "d" (lambda () (interactive) (dired "~/Documents/"))
       "p" (lambda () (interactive) (dired "~/Pictures/")) 
       "M" (lambda () (interactive) (dired "~/Music/"))  
       "v" (lambda () (interactive) (dired "~/Videos/"))   
       "m" (lambda () (interactive) (dired "/media"))    
       "C" (lambda () (interactive) (dired "~/.config/"))  
       "E" (lambda () (interactive) (dired "~/.emacs.d/")) 
       "!" (lambda () (interactive) (dired "~/dotfiles/"))
       "g" 'dired-goto-first-file)

     ;; my external commands
     (define-prefix-command 'l/dired-my-ext-cmds)

     (general-def l/dired-my-ext-cmds
       "s" 'l/get-subtitles
       "?" 'dired-get-size
       "B" 'l/change-desktop-background
       "u" 'l/unmount-drive
       "zz" 'l/atool-pack
       "zx" 'l/atool-unpack)
   #+end_src

** Keybindings

   In this section I define all the keybindings for dired. The list is
   long...

   #+begin_src emacs-lisp
   (use-package dired
     :config
     (general-def 'dired-mode-map
       "G" 'revert-buffer
       "g" 'l/dired-nav-map
       "C-x M-." 'compose-attach-marked-files
       "M-<" 'dired-goto-first-file
       "M->" 'dired-goto-last-file)

     (general-def 'normal dired-mode-map
       "q" 'quit-window
       ;; basic movement
       "j" 'dired-next-line
       "k" 'dired-previous-line
       "h" 'dired-up-directory
       "l" 'dired-find-file
       ">" 'dired-next-dirline
       "<" 'dired-prev-dirline
       ;; here should be "gg" 'dired-goto-first-file, but it is in the
       ;; nav-map
       "G" 'dired-goto-last-file
       ;; basic functions
       "A" 'dired-do-find-regexp
       "B" 'dired-do-byte-compile
       "C" 'dired-do-copy
       "D" 'dired-do-delete
       ;; dired-do-chgrp
       "H" 'dired-do-hardlink
       "L" 'dired-do-load
       "M" 'dired-do-chmod
       "O" 'dired-do-chown
       "P" 'dired-do-print
       "Q" 'dired-do-find-regexp-and-replace
       "R" 'dired-do-rename
       "S" 'dired-do-symlink
       "T" 'dired-do-touch
       "Z" 'dired-do-compress
       "c" 'dired-do-compress-to
       "!" 'dired-do-shell-command
       "&" 'dired-do-async-shell-command
       "=" 'dired-diff
       ;; regexp operations
       "%" nil ;; prefix
       "%u" 'dired-upcase
       "%l" 'dired-downcase
       "%d" 'dired-flag-files-regexp
       "%g" 'dired-mark-files-containing-regexp
       "%m" 'dired-mark-files-regexp
       "%C" 'dired-do-copy-regexp
       "%H" 'dired-do-hardlink-regexp
       "%R" 'dired-do-rename-regexp
       "%S" 'dired-do-symlink-regexp
       "%&" 'dired-flag-garbage-files
       ;; marks & flags
       "U" 'dired-unmark-all-marks
       "u" 'dired-unmark
       "m" 'dired-mark
       (kbd "<SPC>") 'dired-mark
       (kbd "C-<SPC>") 'l/dired-mark-backwards
       "t" 'dired-toggle-marks
       "d" 'dired-flag-file-deletion
       "x" 'dired-do-flagged-delete
       (kbd "* <delete>") 'dired-unmark-backward
       (kbd "<delete>") 'dired-unmark-backward
       "*" nil ;; prefix
       "**" 'dired-mark-executables
       "*/" 'dired-mark-directories
       "*@" 'dired-mark-symlinks
       "*%" 'dired-mark-files-regexp
       "*(" 'dired-mark-sexp
       "*." 'dired-mark-extension
       "*O" 'dired-mark-omitted
       "*c" 'dired-change-marks
       "*s" 'dired-mark-subdir-files
       "*?" 'dired-unmark-all-files
       "*!" 'dired-unmark-all-marks
       "*f" 'l/dired-narrow-to-marked-files
       ;; encryption-decryption (epa-dired)
       ";d" 'epa-dired-do-decrypt
       ";v" 'epa-dired-do-verify
       ";s" 'epa-dired-do-sign
       ";e" 'epa-dired-do-encrypt
       ;; unsorted
       "X" 'l/dired-my-ext-cmds
       "z" 'dired-omit-mode
       "g" 'l/dired-nav-map
       "gr" 'revert-buffer
       "gR" 'dired-do-redisplay
       "I" 'dired-maybe-insert-subdir
       "i" 'dired-toggle-read-only
       "J" 'dired-goto-file
       "K" 'dired-do-kill-lines
       "a" 'dired-find-alternate-file
       "gy" 'dired-show-file-type
       "Y" 'dired-copy-filename-as-kill
       "+" 'dired-create-directory
       (kbd "S-<return>") 'dired-find-file-other-window
       (kbd "RET") 'dired-find-file
       (kbd "M-<return>") 'browse-url-of-dired-file
       ;; sorting
       "o" nil ;; prefix -- was dired-sort-toggle-or-edit
       "oo" 'l/dired-sort-by-name
       "od" 'l/dired-sort-by-date
       "os" 'l/dired-sort-by-size
       "ox" 'l/dired-sort-by-ext
       "o=" 'l/dired-sort-dirs-first
       "(" 'dired-hide-details-mode
       "?" 'dired-summary))

   (add-hook 'dired-mode-hook 'evil-normalize-keymaps))

   #+end_src

** Dired-x

   Dired-X provides some extra functionality for dired.

   For now, I use it only for the omit-mode that it offers, which
   hides non-interesting files by regexp or by extension.

   However, there are other useful features which I should check, like
   shell command guessing.

   #+begin_src emacs-lisp
   (use-package dired-x
     :delight dired-omit-mode
     :after dired
     :bind
     (:map dired-mode-map
	   ("z" . 'dired-omit-mode))
     :init
     (setq dired-omit-verbose nil)
     :config
     ;; files to be ommited: beginning with one or more dots, beginning with $ (some files that come from Windows), ending with xmp (eg darktable data files), ending with srt, sub (I don't want to see subtitle files)
     (setq dired-omit-files (concat dired-omit-files "\\|^\\..+$\\|^\\$"))
     (setq dired-omit-extensions
	   (append dired-omit-extensions '("xmp" "srt" "sub")))

     (add-hook 'dired-mode-hook 'dired-omit-mode))
   #+end_src

** Wdired

   Wdired (Writable dired) is a way to manipulate the file listing
   like a text file. This means super-easy renaming.

   #+begin_src emacs-lisp
   (use-package wdired
     :after dired)
   #+end_src

** Image dired

   Image dired provides functionality to view images in emacs. Nothing too fancy, just some sane defaults.

   #+begin_src emacs-lisp
   (use-package image-dired
     :after dired
     :init
     (setq image-dired-thumb-width 250)
     (setq image-dired-thumbs-per-row 4)
     (setq image-dired-external-viewer "sxiv"))
   #+end_src

** Peep dired

   Peep dired is a minor mode for dired which offers a preview of the file at point on another window. Very useful. It provides an experience similar to file managers like Ranger.

   However, some features where missing imho, also some functions
   caused abnormal behaviour. So, I cloned the project from the
   [[https://github.com/asok/peep-dired][original repo]], tweaked it, added some extra functions and run it...
   It still needs maintenance, some stuff should be reimplemented, but
   it will do for now. My fork can be found [[https://github.com/dakodeon/peep-dired][here]].

   #+begin_src emacs-lisp
   (use-package peep-dired
     :load-path "~/.source/peep-dired"
     :delight (peep-dired " ")
     :after dired
     :init
     (setq peep-dired-cleanup-eagerly t)
     (setq peep-dired-ignored-extensions '("mkv" "mp4" "avi" "mov" "mp3" "wav" "iso"))
     :config
     ;; custom dired functions customized further for peep. Maybe use advice?
     (defun l/peep-dired-goto-first-file ()
       "Go to first file line and peep there. Uses `dired-goto-first-file'"
       (interactive)
       (dired-goto-first-file)
       (peep-dired-display-file-other-window))
  
     (defun l/peep-dired-goto-last-file ()
       "Go to last file line and peep there. Uses `dired-goto-last-file'"
       (interactive)
       (dired-goto-last-file)
       (peep-dired-display-file-other-window))
  
     (defun l/peep-dired-mark-backwards ()
       "Mark and peep backwards."
       (interactive)
       (l/dired-mark-backwards)
       (peep-dired-display-file-other-window))
  
     ;; evil bindings
     (general-def 'normal peep-dired-mode-map
       "C-j" 'peep-dired-scroll-page-down
       "C-k" 'peep-dired-scroll-page-up
       "j" 'peep-dired-next-file
       "<down>" 'peep-dired-next-file
       "k" 'peep-dired-prev-file
       "<up>" 'peep-dired-prev-file
       "h" 'peep-dired-up-directory
       "<left>" 'peep-dired-up-directory
       "l" 'peep-dired-find-file
       "<right>" 'peep-dired-find-file
       ">" 'peep-dired-next-dirline
       "<" 'peep-dired-prev-dirline
       "g g" 'l/peep-dired-goto-first-file
       "G" 'l/peep-dired-goto-last-file
       "C-SPC" 'l/peep-dired-mark-backwards)
     (general-def 'normal dired-mode-map
       "p" 'peep-dired)

     (add-hook 'peep-dired-hook 'evil-normalize-keymaps)
     :bind
     (:map dired-mode-map
	   ("p" . 'peep-dired)))

   #+end_src

** Some extra pieces of functionality

   Here are some packages that offer a little bit of extra
   functionality. Small things really, but they make a better
   experience.

*** Dired subtree

    This package makes directories open in the same buffer like
    subtrees.

    #+begin_src emacs-lisp
    (use-package dired-subtree
      :ensure t
      :after dired
      :config
      (general-def 'normal dired-mode-map
	"TAB" 'dired-subtree-toggle))
    #+end_src

*** Dired narrow

    Narrows down what is shown in the dired buffer by filtering
    filenames. Really useful for quickly finding something.

    #+begin_src emacs-lisp
    (use-package dired-narrow
      :ensure t
      :delight (dired-narrow-mode " >⋅<")
      :after dired
      :init
      (setq dired-narrow-exit-when-one-left t)
      :config
      (general-def 'normal dired-mode-map
	"f" 'dired-narrow)
      :bind
      (:map dired-mode-map
	    ("f" . 'dired-narrow)))
    #+end_src

*** Dired ranger

    Dired-ranger ports some of the functionality from the ranger file
    manager. Specifically it implements the copying/moving mechanism
    and the bookmark mechanism.

    The way it handles copying and moving can be useful from time to
    time. Instead of knowing beforehand where you want to put the
    file, you can perform the 'yank' and then paste it in whichever
    directory you want.

    Bookmarks is also a useful feature for quick navigation. You can
    quickly set and visit a bookmark, while a custom function that I
    wrote, handles moving to the last visited place. Note that these
    bookmarks are not persistent, they will be lost upon exiting
    emacs.

    #+begin_src emacs-lisp
    (use-package dired-ranger
      :ensure t
      :after dired
      :init
      (setq dired-ranger-bookmark-reopen 'always)
      :config
      ;; function to visit previous directory
      (defun l/dired-ranger-bookmark-visit-LRU ()
	"Go to last visited directory."
	(interactive)
	(dired-ranger-bookmark-visit dired-ranger-bookmark-LRU))

      ;; evil keybindings
      (general-def 'normal dired-mode-map
	"y" nil ;; prefix
	"yy" 'dired-ranger-copy
	"yP" 'dired-ranger-move
	"yp" 'dired-ranger-paste
	"`" nil ;; prefix
	"``" 'l/dired-ranger-bookmark-visit-LRU
	"`v" 'dired-ranger-bookmark-visit
	"`m" 'dired-ranger-bookmark))
    #+end_src

*** Dired rsync
    
    Rsync functionality for dired. Really useful for BIG files, as it does not freeze emacs while busy. Progress is also shown in the modeline.

One note though, while trying to copy to a FAT32 device, I discovered that there is some problem concerning the permissions. This has nothing to do with dired or emacs, it is a rsync thing. The workaround is to choose different flags for the rsync command, so I wrote a function to do this.

    #+begin_src emacs-lisp
    (use-package dired-rsync
      :ensure t
      :after dired
      :init
      (setq dired-rsync-unmark-on-completion nil)
      :config
      ;; workaround to rsync into FAT32
      (defun l/dired-rsync-to-FAT32 ()
	"Change `dired-rsync-options' temporarily to rsync to FAT32 driver."
	(interactive)
	(let ((dired-rsync-options "-rDz --info=progress2")
	      (dest (read-file-name "rsync to: " (dired-dwim-target-directory)
			      nil nil nil 'file-directory-p)))
	  (dired-rsync dest)))

      ;; evil keybindings
      (general-def 'normal dired-mode-map
	"rr" 'dired-rsync
	"rf" 'l/dired-rsync-to-FAT32))
    #+end_src

** Some bling!

   This section is all about the looks!

*** Dired rainbow

    Colors the output of dired. Haven't tweaked anything, this is just
    the defaults from the github page.

    #+begin_src emacs-lisp
    (use-package dired-rainbow
      :ensure t
      :after dired
      :config
      (progn
	(dired-rainbow-define-chmod directory "#6cb2eb" "d.*")
	(dired-rainbow-define html "#eb5286" ("css" "less" "sass" "scss" "htm" "html" "jhtm" "mht" "eml" "mustache" "xhtml"))
	(dired-rainbow-define xml "#f2d024" ("xml" "xsd" "xsl" "xslt" "wsdl" "bib" "json" "msg" "pgn" "rss" "yaml" "yml" "rdata"))
	(dired-rainbow-define document "#9561e2" ("docm" "doc" "docx" "odb" "odt" "pdb" "pdf" "ps" "rtf" "djvu" "epub" "odp" "ppt" "pptx"))
	(dired-rainbow-define markdown "#ffed4a" ("org" "etx" "info" "markdown" "md" "mkd" "nfo" "pod" "rst" "tex" "textfile" "txt"))
	(dired-rainbow-define database "#6574cd" ("xlsx" "xls" "csv" "accdb" "db" "mdb" "sqlite" "nc"))
	(dired-rainbow-define media "#de751f" ("mp3" "mp4" "MP3" "MP4" "avi" "mpeg" "mpg" "flv" "ogg" "mov" "mid" "midi" "wav" "aiff" "flac"))
	(dired-rainbow-define image "#f66d9b" ("tiff" "tif" "cdr" "gif" "ico" "jpeg" "jpg" "png" "psd" "eps" "svg"))
	(dired-rainbow-define log "#c17d11" ("log"))
	(dired-rainbow-define shell "#f6993f" ("awk" "bash" "bat" "sed" "sh" "zsh" "vim"))
	(dired-rainbow-define interpreted "#38c172" ("py" "ipynb" "rb" "pl" "t" "msql" "mysql" "pgsql" "sql" "r" "clj" "cljs" "scala" "js"))
	(dired-rainbow-define compiled "#4dc0b5" ("asm" "cl" "lisp" "el" "c" "h" "c++" "h++" "hpp" "hxx" "m" "cc" "cs" "cp" "cpp" "go" "f" "for" "ftn" "f90" "f95" "f03" "f08" "s" "rs" "hi" "hs" "pyc" ".java"))
	(dired-rainbow-define executable "#8cc4ff" ("exe" "msi"))
	(dired-rainbow-define compressed "#51d88a" ("7z" "zip" "bz2" "tgz" "txz" "gz" "xz" "z" "Z" "jar" "war" "ear" "rar" "sar" "xpi" "apk" "xz" "tar"))
	(dired-rainbow-define packaged "#faad63" ("deb" "rpm" "apk" "jad" "jar" "cab" "pak" "pk3" "vdf" "vpk" "bsp"))
	(dired-rainbow-define encrypted "#ffed4a" ("gpg" "pgp" "asc" "bfe" "enc" "signature" "sig" "p12" "pem"))
	(dired-rainbow-define fonts "#6cb2eb" ("afm" "fon" "fnt" "pfb" "pfm" "ttf" "otf"))
	(dired-rainbow-define partition "#e3342f" ("dmg" "iso" "bin" "nrg" "qcow" "toast" "vcd" "vmdk" "bak"))
	(dired-rainbow-define vc "#0074d9" ("git" "gitignore" "gitattributes" "gitmodules"))
	(dired-rainbow-define-chmod executable-unix "#38c172" "-.*x.*")
	))
    #+end_src

*** Dired icons

    Adds icons in front of file names. Always good to have! Depends on
    the all-the-icons package, which is loaded later in the config.

    #+begin_src emacs-lisp
    (use-package all-the-icons-dired
      :ensure t
      :delight
      :after dired all-the-icons
      :config
      (add-hook 'dired-mode-hook 'all-the-icons-dired-mode))
    #+end_src


* CONFIURATION
** INTERFACE
*** Try packages

    #+begin_src emacs-lisp
    (use-package try
      :ensure t)
    #+end_src
    
*** Defaults

    #+begin_src emacs-lisp
    (setq inhibit-splash-screen t)       	;; disable the splash screen
    (setq initial-scratch-message nil)   	;; disable scratch message
    (tool-bar-mode -1)                   	;; all bars off
    (menu-bar-mode -1)
    (scroll-bar-mode -1)
    (blink-cursor-mode -1)
    (column-number-mode 1)               	;; show cursor position
    (global-visual-line-mode t)          	;; visual line mode everywhere
    (global-hl-line-mode t)              	;; highlight active line
    (fset 'yes-or-no-p 'y-or-n-p)        	;; ask me for y or n
    (setq default-directory (file-name-as-directory (getenv "HOME"))) ;; change the default directory to $HOME
    (setq select-enable-clipboard t)				  ;; use the clipboard for yanking
    (setq save-interprogram-paste-before-kill t)
    (setq help-window-select t)	       ;; always focus on help windows
    (setq sentence-end-double-space nil)   ;; better sentence navigation
    (delete-selection-mode 1)	       ;; typing deletes selected text
    (set-language-environment "UTF-8")     ;; always use UTF-8 encoding
    (set-default-coding-systems 'utf-8)
    (setq browse-url-browser-function 'browse-url-xdg-open) ;; open with default browser
    (setq vc-follow-symlinks t) ;; don't ask when visiting symlinks
    (global-set-key (kbd "M-SPC") nil)			;; temporary fix, I use this key combination to switch layouts stystem-wise, but emacs intercepts the key presses
    #+end_src

*** Enable some disabled features

    #+begin_src emacs-lisp
    (put 'downcase-region 'disabled nil) ;; binds to 'C-x C-l'
    (put 'upcase-region 'disabled nil) ;; binds to 'C-x C-u'
    (put 'narrow-to-region 'disabled nil) ;; binds to 'C-x n n'
    #+end_src

*** Font size

    #+begin_src emacs-lisp
    (global-set-key (kbd "C-<next>") 'text-scale-increase)
    (global-set-key (kbd "C-<prior>") 'text-scale-decrease)
    #+end_src

*** Line numbering

    #+begin_src emacs-lisp
    ;; (display-line-numbers-mode t)

    (use-package linum-relative
      :ensure t
      :after org
      :init
      (setq linum-relative-current-symbol "")
      :bind ("C-x M-l" . linum-relative-toggle))
    #+end_src

*** Darkroom mode

    A nice mode for reading and writing, similar to vim's goyo
    Does it make sense to configure follow-mode here? Maybe.

    #+begin_src emacs-lisp
    (use-package darkroom
      :ensure t
      :init
      (setq darkroom-text-scale-increase 0.8)
      :bind
      (("C-M-_" . darkroom-decrease-margins)
       ("C-x M-D" . darkroom-tentative-mode)))

    (global-set-key (kbd "C-x M-L") 'follow-mode)
    #+end_src

*** Rainbow mode

    #+begin_src emacs-lisp
    (use-package rainbow-mode
      :ensure t
      :delight
      :hook prog-mode conf-mode)
    #+end_src

*** Load theme

    #+begin_src emacs-lisp
    (use-package color-theme-sanityinc-tomorrow
      :ensure t)

    (color-theme-sanityinc-tomorrow--define-theme bright)
    #+end_src

*** All the icons
Icons for emacs.
#+begin_src emacs-lisp
;; Note: After the first load, run `all-the-icons-install-fonts'
(use-package all-the-icons
  :ensure t
  :delight)
#+end_src

#+begin_src emacs-lisp
(add-to-list 'load-path "~/.source")
(require 'font-lock+)
#+end_src

*** Hide info from modeline (delight)

    Normally I use the =:delight= keyword of use package, here are the built-in modes that I want to omit.

    #+begin_src emacs-lisp
    (use-package delight
      :ensure t
      :config
      (delight 'dired-mode "")
      (delight 'undo-tree-mode nil 'undo-tree)
      (delight 'visual-line-mode " ⏎" 'simple)
      (delight 'eldoc-mode nil 'eldoc)
      ;; for some reason, I cannot set this in use-package declaration of smartparens
      (delight 'smartparens-mode " {⬄}" 'smartparens))
    #+end_src

This seems a reasonable way to change modeline info for major modes. Why use delight for that? It also seems to work better for, e.g, this case.

    #+begin_src emacs-lisp
    (add-hook 'emacs-lisp-mode-hook
	  (lambda ()
	    (setq mode-name "ELisp")))
    #+end_src
    
*** Which key

    #+begin_src emacs-lisp
    (use-package which-key
      :ensure t
      :delight
      :config (which-key-mode))
    #+end_src
*** Default files

    Change the way that emacs keeps backups, also some default files, like custom

    #+begin_src emacs-lisp
    ;; use separate custom file
    (setq custom-file "~/.emacs.d/custom.el")
    (load custom-file)

    ;; backup files
    (setq backup-directory-alist `(("." . "~/.emacs.d/backups")))
    (setq backup-by-copying t) ;; this is to ensure all edited files keep their inodes
    #+end_src
*** Emojis

    Display emojis!

    #+begin_src emacs-lisp
    (use-package emojify
      :ensure t)
    #+end_src
*** Transparency

    Coz why not? Until I get bored with it. Or maybe make it toggle?
    
    UPDATE: It seems that there is some problems after all...

    #+begin_src emacs-lisp
    ;; (set-frame-parameter (selected-frame) 'alpha '(90 80))
    #+end_src

** FUNCTIONALITY
*** Whole buffer evaluation

    #+begin_src emacs-lisp
    (global-set-key (kbd "C-x C-S-e") 'eval-buffer)
    #+end_src

*** Toggle comments

    #+begin_src emacs-lisp
    (global-set-key (kbd "C-;") 'comment-line)
    (global-set-key (kbd "C-M-;") 'comment-or-uncomment-region)
    #+end_src

*** Parentheses

    #+begin_src emacs-lisp
    (use-package smartparens-config
      :ensure smartparens
      ;; :delight ('smartparens-mode " \(\)" 'smartparens)
      :init
      (smartparens-global-mode 1)
      (show-smartparens-global-mode 1)
      (sp-local-pair 'emacs-lisp-mode "'" nil :actions nil)
      :bind
      ("M-s" . sp-splice-sexp))

    (use-package rainbow-delimiters
      :ensure t
      :init
      (add-hook 'prog-mode-hook #'rainbow-delimiters-mode))

    #+end_src

*** Expand region

    #+begin_src emacs-lisp
    (use-package expand-region
      :ensure t
      :bind
      (("C-=" . er/expand-region)
       ("C-c =" . er/expand-region)
       ("C--" . er/contract-region)
       ("C-c -" . er/contract-region)))
    #+end_src

*** Smarter move to beginning of line

    Part of Prelude

    #+begin_src emacs-lisp
    (defun smarter-move-beginning-of-line (arg)
      "Move point back to indentation of beginning of line.

    Move point to the first non-whitespace character on this line.
    If point is already there, move to the beginning of the line.
    Effectively toggle between the first non-whitespace character and
    the beginning of the line.

    If ARG is not nil or 1, move forward ARG - 1 lines first.  If
    point reaches the beginning or end of the buffer, stop there."
      (interactive "^p")
      (setq arg (or arg 1))

      ;; Move lines first
      (when (/= arg 1)
	(let ((line-move-visual nil))
	  (forward-line (1- arg))))

      (let ((orig-point (point)))
	(back-to-indentation)
	(when (= orig-point (point))
	  (move-beginning-of-line 1))))

    (global-set-key [remap move-beginning-of-line] 'smarter-move-beginning-of-line)
    #+end_src

    Kill the whole line

    #+begin_src emacs-lisp
    (global-set-key (kbd "C-S-k") 'kill-whole-line)
    #+end_src

*** Duplicate line

    #+begin_src emacs-lisp
    (defun duplicate-line()
      "Duplicates a line."
      (interactive)
      (move-beginning-of-line 1)
      (kill-line)
      (yank)
      (open-line 1)
      (next-line 1)
      (yank))

    (global-set-key (kbd "C-c d") 'duplicate-line)
    #+end_src

*** Auto-evaluate init file

    Auto-evaluate the init.el file when saving this org file. A must have!

    Got the general idea from https://www.reddit.com/r/emacs/comments/8hpyp5/tip_how_to_execute_a_bash_function_when_saving_a/

    #+begin_src emacs-lisp

    (defun l/reload-emacs ()
      "Reload the init file"
      (interactive)
      (load-file "~/.emacs.d/init.el"))

    (defun my/cmd-after-saved-file ()
      "Evaluate the init file automatically"
	(when (string= (buffer-file-name) (expand-file-name "~/.emacs.d/my-config.org"))
	  (l/reload-emacs)))

    (add-hook 'after-save-hook 'my/cmd-after-saved-file)

    ;; also makes sense to bind a "refresh" key, similar to the i3 config
    (global-set-key (kbd "C-M-S-r") 'l/reload-emacs)
    #+end_src

*** Restart emacs
Restart emacs from within emacs (duh!)
#+begin_src emacs-lisp
(use-package restart-emacs
  :ensure t
  :bind ("C-M-S-e" . 'restart-emacs))

#+end_src

*** Syntax highlighting for rc files

    #+begin_src emacs-lisp
    (add-to-list 'auto-mode-alist '("\\.*rc$" . conf-mode))
    #+end_src

** WINDOW MANAGEMENT
*** Windows movement and resizing

    #+begin_src emacs-lisp
    (windmove-default-keybindings) ;; use arrow keys ot navigate

    ;; resize shortcuts
    (global-set-key (kbd "S-C-<left>") 'shrink-window-horizontally)
    (global-set-key (kbd "S-C-<right>") 'enlarge-window-horizontally)
    (global-set-key (kbd "S-C-<down>") 'shrink-window)
    (global-set-key (kbd "S-C-<up>") 'enlarge-window)
    #+end_src

*** Ace-window

    Ace-window is a more efficient way to move between windows.

    #+begin_src emacs-lisp
    (use-package ace-window
      :ensure t
      :init
      (setq aw-keys '(?h ?j ?k ?l ?a ?s ?d ?f ?g))
      :config
      (ace-window-display-mode 1)
      :bind
      (("C-x o" . ace-window)
       ("C-x M-o" . ace-swap-window)))
    #+end_src

*** Split windows and follow

    The default behaviour after splitting a window is to stay in the initial window. I always want to go to the new one.

    I don't remember from where I got this.

    #+begin_src emacs-lisp
    (defun split-window-and-follow-below ()
      "Split and follow container horizontally."
      (interactive)
      (split-window-below)
      (balance-windows)
      (other-window 1))

    (defun split-window-and-follow-right ()
      "Split and follow container vertically."
      (interactive)
      (split-window-right)
      (balance-windows)
      (other-window 1))

    (global-set-key (kbd "C-x 2") 'split-window-and-follow-below)
    (global-set-key (kbd "C-x 3") 'split-window-and-follow-right)

    #+end_src

*** Toggle window split
    
    I don't remember from where I got this either...

    #+begin_src emacs-lisp
    (defun toggle-window-split ()
      "Switch between horizontal and vertical split when using two windows."
      (interactive)
      (if (= (count-windows) 2)
	  (let* ((this-win-buffer (window-buffer))
		 (next-win-buffer (window-buffer (next-window)))
		 (this-win-edges (window-edges (selected-window)))
		 (next-win-edges (window-edges (next-window)))
		 (this-win-2nd (not (and (<= (car this-win-edges)
					     (car next-win-edges))
					 (<= (cadr this-win-edges)
					     (cadr next-win-edges)))))
		 (splitter
		  (if (= (car this-win-edges)
			 (car (window-edges (next-window))))
		      'split-window-horizontally
		    'split-window-vertically)))
	    (delete-other-windows)
	    (let ((first-win (selected-window)))
	      (funcall splitter)
	      (if this-win-2nd (other-window 1))
	      (set-window-buffer (selected-window) this-win-buffer)
	      (set-window-buffer (next-window) next-win-buffer)
	      (select-window first-win)
	      (if this-win-2nd (other-window 1))))))

    (global-set-key (kbd "C-x |") 'toggle-window-split)
    #+end_src

*** Swap windows

    #+begin_src emacs-lisp
    (global-set-key (kbd "C-x \\") 'window-swap-states)
    #+end_src

*** Evil window bindings

    Window functions with evil mode. Also some functions that make sense for me to be configured here, like buffer actions.

    #+begin_src emacs-lisp
    (eval-after-load "evil"
      '(progn
	 (define-key evil-normal-state-map "\\" nil) ;; prefix
	 (define-key evil-normal-state-map "\\0" 'ace-delete-window)
	 (define-key evil-normal-state-map "\\q" 'delete-window)
	 (define-key evil-normal-state-map "\\Q" 'kill-buffer-and-window)
	 (define-key evil-normal-state-map "\\1" 'delete-other-windows)
	 ;; for movement, it made more sense to use "gaming" keys (also because of the prefix key position)
	 (define-key evil-normal-state-map "\\a" 'windmove-left)
	 (define-key evil-normal-state-map "\\s" 'windmove-down)
	 (define-key evil-normal-state-map "\\w" 'windmove-up)
	 (define-key evil-normal-state-map "\\d" 'windmove-right)
	 (define-key evil-normal-state-map "\\s" 'split-window-and-follow-right)
	 (define-key evil-normal-state-map "\\3" 'split-window-and-follow-right)
	 (define-key evil-normal-state-map "\\v" 'split-window-and-follow-below)
	 (define-key evil-normal-state-map "\\2" 'split-window-and-follow-below)
	 (define-key evil-normal-state-map "\\_" 'toggle-window-split)
	 (define-key evil-normal-state-map "\\-" 'window-swap-states)
	 (define-key evil-normal-state-map "\\\\" 'ace-window)
	 (define-key evil-normal-state-map "\\|" 'ace-swap-window)
	 (define-key evil-normal-state-map (kbd "M-H") 'shrink-window-horizontally)
	 (define-key evil-normal-state-map (kbd "M-L") 'enlarge-window-horizontally)
	 (define-key evil-normal-state-map (kbd "M-J") 'shrink-window)
	 (define-key evil-normal-state-map (kbd "M-K") 'enlarge-window)
	 (define-key evil-normal-state-map (kbd "M-+") 'balance-windows)
	 ;; (define-key evil-normal-state-map "\\f" 'find-file)
	 (define-key evil-normal-state-map "\\f" 'helm-find-files)
	 (define-key evil-normal-state-map "\\b" 'switch-to-buffer)
	 (define-key evil-normal-state-map "\\," '(lambda () (interactive) (switch-to-buffer "*scratch*")))
	 (define-key evil-normal-state-map "\\<" 'switch-to-prev-buffer)
	 (define-key evil-normal-state-map "\\>" 'switch-to-next-buffer)
	 (define-key evil-normal-state-map "\\z" 'kill-current-buffer)
	 (define-key evil-normal-state-map "\\D" 'dired-jump)
	 ;; other window
	 (define-key evil-normal-state-map "\\'" nil) ;;prefix
	 (define-key evil-normal-state-map "\\'f" 'find-file-other-window)
	 (define-key evil-normal-state-map "\\'b" 'switch-to-buffer-other-window)
	 (define-key evil-normal-state-map "\\'D" 'dired-other-window)))

    #+end_src

** HELM

   Helm was my previous selection for navigation. I dropped it in
   favour of ivy. It is very powerful, but for me, really hard to
   customize.

   I will keep my configuration here, disabled, in case I ever need it
   again.

*** Basics
   #+begin_src emacs-lisp
   (use-package helm-config
     :disabled
     :ensure helm
     :delight helm-mode
     :defer 1
     :init
     (setq helm-follow-mode-persistent t)
     (setq  helm-split-window-inside-p t)
     :config
     (helm-mode 1)
     :bind
     ("M-x" . helm-M-x)
     ("C-x C-f" . helm-find-files)
     ("M-y" . helm-show-kill-ring)
     ([remap switch-to-buffer] . helm-buffers-list))
   #+end_src

*** Helm-swoop
    #+begin_src emacs-lisp
    (use-package helm-swoop
      :disabled
      :ensure t
      :after helm evil
      :init
      (setq helm-swoop-speed-or-color t)
      ;; pre-input disabled or marked word
      (setq helm-swoop-pre-input-function
	  (lambda ()
	    (if mark-active
		(buffer-substring-no-properties (mark) (point)) "")))
      :bind
      ("M-i" . 'helm-swoop)
      ("C-M-i" . 'helm-multi-swoop)
      ("M-I" . 'helm-swoop-back-to-last-point)
      (:map helm-swoop-map
	    ("M-i" . 'helm-multi-swoop-all-from-helm-swoop))
      (:map isearch-mode-map
	    ("M-i" . 'helm-swoop-from-isearch))
      (:map evil-motion-state-map
	    ("M-i" . 'helm-swoop-from-evil-search)))

    #+end_src
** MULTIPLE CURSORS

   It seems that the mc package is not really needed. Maybe everything it does can be achieved by using replacement methods and/or macros. Not to mention vim's =:g= command, or helm-swoop.

   #+begin_src emacs-lisp
   (use-package multiple-cursors
     :ensure t
     :bind
     ("C-s-c C-s-c" . mc/edit-lines)
     ("C->" . mc/mark-next-like-this)
     ("C-<" . mc/mark-previous-like-this)
     ("C-c C-<" . mc/mark-all-like-this)
     ("C-<down-mouse-1>" . mc/add-cursor-on-click)
     ("C-!" . mc/insert-numbers))

   (use-package mc-extras
     :ensure t
     :after multiple-cursors)

   (use-package ace-mc
     :ensure t
     :after mc-extras
     :bind
     ("C-c )" . ace-mc-add-multiple-cursors)
     ("C-M-)" . ace-mc-add-single-cursor))
   #+end_src

** DONE DIRED [15/15]
   CLOSED: [2020-04-11 Sat 04:56]

   This *IS* my new file manager!
   
*** DONE Dired-x
    CLOSED: [2020-04-11 Sat 03:33]

    #+begin_src emacs-lisp
    ;; (use-package dired-x
      ;; :ensure nil
      ;; :delight dired-omit-mode
      ;; :after dired
      ;; :init
      ;; (setq dired-omit-verbose nil)
      ;; :config
      ;; files to be ommited: beginning with one or more dots, beginning with $ (some files that come from Windows), ending with xmp (eg darktable data files), ending with srt, sub (I don't want to see subtitle files)
      ;; (setq dired-omit-files (concat dired-omit-files "\\|^\\..+$\\|^\\$\\|xmp$\\|srt$\\|sub$")))
    #+end_src

*** DONE Some useful functions [5/5]
    CLOSED: [2020-04-11 Sat 02:23]
    
**** DONE Attatch marked files to email:
     CLOSED: [2020-04-11 Sat 01:00]

     Found [[https://emacs.stackexchange.com/questions/14652/attach-multiple-files-from-the-same-directory-to-an-email-message][here]].

     Open a dired buffer, mark some files and run the command. If there's an open message buffer use it, else create new message

     #+begin_src emacs-lisp
     ;; (defun compose-attach-marked-files ()
       ;; "Compose mail and attach all the marked files from a dired buffer. Uses `compose-mail', (or `org-msg-attach-attach' if org-msg is enabled -- this is not true yet)."
       ;; (interactive)
       ;; (let ((files (dired-get-marked-files)))
	 ;; (compose-mail nil nil nil t)
	 ;; (dolist (file files)
	   ;; (if (file-regular-p file)
	       ;; (mml-attach-file file
				;; (mm-default-file-encoding file)
				;; nil "attachment")
	     ;; (message "skipping non-regular file %s" file)))))
     #+end_src

**** DONE Go to first/last directory:
     CLOSED: [2020-04-11 Sat 00:51]

     Instead of going to the beginning or end of the buffer, go to the first or last directory line
     
     Source: https://www.emacswiki.org/emacs/dired-extension.el

     #+begin_src emacs-lisp
     ;; (defun dired-goto-first-file ()
       ;; "Move cursor to first file of dired."
       ;; (interactive)
       ;; (goto-char (point-min))
       ;; (while (not (dired-move-to-filename))
	 ;; (call-interactively 'dired-next-line)))

     ;; (defun dired-goto-last-file ()
       ;; "Move cursor to last file of dired."
       ;; (interactive)
       ;; (goto-char (point-max))
       ;; (while (not (dired-move-to-filename))
	 ;; (call-interactively 'dired-previous-line)))
     #+end_src

**** DONE Sorting functions:
     CLOSED: [2020-04-11 Sat 00:31]

**** DONE Mark and move backwards:
     CLOSED: [2020-04-11 Sat 00:53]

     This was always a missing feature imho.

     #+begin_src emacs-lisp
     ;; (defun l/dired-mark-backwards ()
       ;; "Mark file at point and move backwards."
       ;; (interactive)
       ;; (if (dired-move-to-filename)
	 ;; (progn
	   ;; (dired-mark 1)
	   ;; (dired-previous-line 2))))

     #+end_src

**** DONE Narrow to marked files:
     CLOSED: [2020-04-11 Sat 00:53]

     #+begin_src emacs-lisp
     ;; (defun l/dired-narrow-to-marked-files ()
       ;; "Show only marked files in dired buffer."
       ;; (interactive)
       ;; (let ((files (dired-get-marked-files)))
	 ;; (unless (eq (length files) 1)
	   ;; (dired-toggle-marks)
	   ;; (dired-do-kill-lines))))
     #+end_src

*** DONE Some useful (external) functions [5/5]
    CLOSED: [2020-04-11 Sat 02:23]
    
    Useful functions that use external programs.

**** DONE Get subtitles:
     CLOSED: [2020-04-11 Sat 01:11]

     Use [[https://github.com/Diaoul/subliminal][subliminal]] to find subtitles online. The gist of using 'start-process' comes from [[http://ergoemacs.org/emacs/elisp_call_shell_command.html][here]], and the idea of using 'apply' from [[https://stackoverflow.com/questions/17075920/passing-list-to-rest-args?rq=1][here]].

     #+begin_src emacs-lisp
     ;; (defun l/get-subtitles ()
       ;; "Get subtitles for marked files while in a dired buffer. Depends on subliminal, so it has to be on your system."
       ;; (interactive)
       ;; (when (eq major-mode 'dired-mode)
	 ;; (let* ((lang-list '("en" "gr"))
		;; (lang (completing-read "Select language: " lang-list nil t))
		;; (files (dired-get-marked-files))
		;; (process-connection-type nil))
	   ;; (if (get-buffer "*get-subtitles*")
	       ;; (kill-buffer "*get-subtitles*"))
	   ;; (apply 'start-process
		  ;; (append (list "get-subtitles" "*get-subtitles*" "subliminal" "download" "-l" lang) files))
	 ;; (switch-to-buffer-other-window "*get-subtitles*")
	 ;; (special-mode))))
     #+end_src

**** DONE Get files size:
     CLOSED: [2020-04-11 Sat 01:07]

     Source: 
     #+begin_src emacs-lisp
     ;; (defun dired-get-size ()
       ;; "Get total size of marked files with `du' command.
     ;; If not marked any files, default is current file or directory."
       ;; (interactive)
       ;; (let ((files (dired-get-marked-files)))
	 ;; (with-temp-buffer
	   ;; (apply 'call-process "/usr/bin/du" nil t nil "-sch" files)
	   ;; (message "%s"
		    ;; (progn
		      ;; (re-search-backward "\\(^[0-9.,]+[A-Za-z]+\\).*\\(total\\|总用量\\)$")
		      ;; (match-string 1))))))
     #+end_src

**** DONE Change desktop background:
     CLOSED: [2020-04-11 Sat 01:12]

     #+begin_src emacs-lisp
     ;; (defun l/change-desktop-background ()
       ;; "Change the desktop background using feh."
       ;; (interactive)
       ;; (let ((fit-type (completing-read "Select fit: " '("scale" "center" "fill" "max") nil t))
	     ;; (entry (shell-quote-argument (expand-file-name (dired-file-name-at-point))))
	     ;; (targetfile (shell-quote-argument (expand-file-name "~/.config/.wallpaper.jpg"))))
	 ;; (setq cpcmd (concat "cp " entry " " targetfile))
	 ;; (setq fehcmd (concat "feh --bg-" fit-type " " targetfile))
	 ;; (setq cmd (concat cpcmd " && " fehcmd))
	 ;; (shell-command cmd))) 
     #+end_src

**** DONE Unmount drives:
     CLOSED: [2020-04-11 Sat 01:10]

     Simple script to unmount drive. Uses 'mountpoint' and 'umount'. If unmounting fails, give some options (todo).

     #+begin_src emacs-lisp
     ;; (defun l/unmount-drive ()
       ;; "Unmount selected directories, if they correspond to mountpoints."
       ;; (interactive)
       ;; (let ((dirs (dired-get-marked-files)))
	 ;; (dired-do-shell-command "mountpoint -q ? && sudo umount ? && sudo rmdir ?" nil dirs)
	 ;; (revert-buffer)))
     #+end_src

**** DONE COMMENT Pack/Unpack:
     CLOSED: [2020-04-11 Sat 01:10]

     I tried the dired-atool package but I didn't like it. I needed something simpler, also I didn't like the output display.

     So I checked out the pack/unpack functions in the source and made mine, but simpler.

     #+begin_src emacs-lisp
     ;; pack
     ;; (defun l/atool-pack ()
       ;; "Use the `atool' program to pack some files."
       ;; (interactive)
       ;; (when (eq major-mode 'dired-mode)
	 ;; (let ((files (dired-get-marked-files t))
	       ;; (archive (expand-file-name
			 ;; (read-file-name "Pack files as:" nil nil nil)))
	       ;; (process-connection-type nil))
	   ;; (if (get-buffer "*atool-pack*")
	       ;; (kill-buffer "*atool-pack*"))
	   ;; (apply 'start-process
		  ;; (append (list "atool-pack" "*atool-pack*" "atool" "--explain" archive "-a") files))
	   ;; (switch-to-buffer-other-window "*atool-pack*")
	   ;; (special-mode))))

     ;; unpack
     ;; (defun l/atool-unpack ()
       ;; "Use the `atool' program to unpack some archives."
       ;; (interactive)
       ;; (when (eq major-mode 'dired-mode)
	 ;; (let ((files (dired-get-marked-files t))
	       ;; (dest (expand-file-name
		      ;; (read-directory-name "Unpack files to:"
					   ;; (dired-dwim-target-directory) nil nil)))
	       ;; (process-connection-type nil))
	   ;; (if (get-buffer "*atool-unpack*")
	       ;; (kill-buffer "*atool-unpack*"))
	   ;; (if (not (file-directory-p dest))
	       ;; (make-directory dest))
	   ;; (apply 'start-process
		  ;; (append (list "atool-unpack" "*atool-unpack*" "atool" "--explain" "-X" dest) files))
	   ;; (switch-to-buffer-other-window "*atool-unpack*")
	   ;; (special-mode))))
     #+end_src
     
*** DONE Dired custom maps
    CLOSED: [2020-04-11 Sat 02:23]

    #+begin_src emacs-lisp
    ;; navigation map
    ;; (define-prefix-command 'l/dired-nav-map)

    ;; (define-key l/dired-nav-map "h" (lambda () (interactive) (dired "~/")))
    ;; (define-key l/dired-nav-map "D" (lambda () (interactive) (dired "~/Downloads/")))
    ;; (define-key l/dired-nav-map "d" (lambda () (interactive) (dired "~/Documents/")))
    ;; (define-key l/dired-nav-map "p" (lambda () (interactive) (dired "~/Pictures/")))
    ;; (define-key l/dired-nav-map "M" (lambda () (interactive) (dired "~/Music/")))
    ;; (define-key l/dired-nav-map "v" (lambda () (interactive) (dired "~/Videos/")))
    ;; (define-key l/dired-nav-map "m" (lambda () (interactive) (dired "/media")))
    ;; (define-key l/dired-nav-map "C" (lambda () (interactive) (dired "~/.config/")))
    ;; (define-key l/dired-nav-map "E" (lambda () (interactive) (dired "~/.emacs.d/")))
    ;; (define-key l/dired-nav-map "!" (lambda () (interactive) (dired "~/dotfiles/")))

    ;; external scripts map -- Note: after using those, I think it's better to write full shell scripts and run those in emacs -- Sidenote: use dmenu for selection if those are run externally, but in emacs use the default completing mechanisms.
    ;; (define-prefix-command 'l/dired-my-ext-cmds)

    ;; (define-key l/dired-my-ext-cmds "s" 'l/get-subtitles)
    ;; (define-key l/dired-my-ext-cmds "?" 'dired-get-size)
    ;; (define-key l/dired-my-ext-cmds "B" 'l/change-desktop-background)
    ;; (define-key l/dired-my-ext-cmds "u" 'l/unmount-drive)
    ;; (define-key l/dired-my-ext-cmds "zz" 'l/atool-pack)
    ;; (define-key l/dired-my-ext-cmds "zx" 'l/atool-unpack)
    #+end_src

*** DONE Dired defaults
    CLOSED: [2020-04-11 Sat 03:37]

    #+begin_src emacs-lisp
    ;; (setq dired-dwim-target t)
    ;; (setq dired-listing-switches "-alh") ;; add human-readable sizes


    ;; (add-hook 'dired-mode-hook
	      ;; (lambda ()
		;; (dired-hide-details-mode)
		;; (dired-omit-mode)))

    ;; This hook seems to be added automatically to my 'custom.el' file and breaks dired. I have to find out where it comes from. It was a part of the `ranger' package, which I have deleted.
    ;; (remove-hook 'dired-mode-hook 'ranger-set-dired-key)
    #+end_src

*** DONE Image dired
    CLOSED: [2020-04-11 Sat 03:37]

    #+begin_src emacs-lisp
    ;; (setq image-dired-thumb-width 250)
    ;; (setq image-dired-thumbs-per-row 4)
    ;; (setq image-dired-external-viewer "sxiv")
    #+end_src

*** DONE Dired keybindings
    CLOSED: [2020-04-11 Sat 03:37]

    Changing some default keybindings

    #+begin_src emacs-lisp
    ;; (eval-after-load "dired"
      ;; '(progn
	 ;; (define-key dired-mode-map "G" 'revert-buffer)
	 ;; (define-key dired-mode-map "g" 'l/dired-nav-map)
	 ;; (define-key dired-mode-map "z" 'dired-omit-mode)
	 ;; (define-key dired-mode-map (kbd "C-x M-.") 'compose-attach-marked-files)
	 ;; (define-key dired-mode-map (kbd "M-<") 'dired-goto-first-file)
	 ;; (define-key dired-mode-map (kbd "M->") 'dired-goto-last-file)))
    #+end_src

*** DONE Evil dired bindings
    CLOSED: [2020-04-11 Sat 02:49]

   Loading the whole evil-collection proved cumbersome for me, there was some trouble with my custom keybindings (eg. I couldn't use 'r' as a prefix key, even when binding it to nil after loading evil-collection). Might be sth that I did wrong, but anyhow...

   #+begin_src emacs-lisp
   ;; ;; this is from evil-collection with some changes
   ;; (eval-after-load "evil"
   ;;   '(progn
   ;;      (evil-define-key 'normal dired-mode-map
   ;;        ;; basics
   ;;        "q" 'quit-window
   ;;        ;; basic movement
   ;;        "j" 'dired-next-line
   ;;        "k" 'dired-previous-line
   ;;        "h" 'dired-up-directory
   ;;        "l" 'dired-find-file
   ;;        ">" 'dired-next-dirline
   ;;        "<" 'dired-prev-dirline
   ;;        "gg" 'dired-goto-first-file
   ;;        "G" 'dired-goto-last-file
   ;;        ;; basic functions
   ;;        "A" 'dired-do-find-regexp
   ;;        "B" 'dired-do-byte-compile
   ;;        "C" 'dired-do-copy
   ;;        "D" 'dired-do-delete
   ;;        ;; dired-do-chgrp
   ;;        "H" 'dired-do-hardlink
   ;;        "L" 'dired-do-load
   ;;        "M" 'dired-do-chmod
   ;;        "O" 'dired-do-chown
   ;;        "P" 'dired-do-print
   ;;        "Q" 'dired-do-find-regexp-and-replace
   ;;        "R" 'dired-do-rename
   ;;        "S" 'dired-do-symlink
   ;;        "T" 'dired-do-touch
   ;;        "Z" 'dired-do-compress
   ;;        "c" 'dired-do-compress-to
   ;;        "!" 'dired-do-shell-command
   ;;        "&" 'dired-do-async-shell-command
   ;;        "=" 'dired-diff
   ;;        ;; regexp operations
   ;;        "%" nil ;; prefix
   ;;        "%u" 'dired-upcase
   ;;        "%l" 'dired-downcase
   ;;        "%d" 'dired-flag-files-regexp
   ;;        "%g" 'dired-mark-files-containing-regexp
   ;;        "%m" 'dired-mark-files-regexp
   ;;        "%C" 'dired-do-copy-regexp
   ;;        "%H" 'dired-do-hardlink-regexp
   ;;        "%R" 'dired-do-rename-regexp
   ;;        "%S" 'dired-do-symlink-regexp
   ;;        "%&" 'dired-flag-garbage-files
   ;;        ;; marks & flags
   ;;        "U" 'dired-unmark-all-marks
   ;;        "u" 'dired-unmark
   ;;        "m" 'dired-mark
   ;;        (kbd "<SPC>") 'dired-mark
   ;;        (kbd "C-<SPC>") 'l/dired-mark-backwards
   ;;        "t" 'dired-toggle-marks
   ;;        "d" 'dired-flag-file-deletion
   ;;        "x" 'dired-do-flagged-delete
   ;;        (kbd "* <delete>") 'dired-unmark-backward
   ;;        (kbd "<delete>") 'dired-unmark-backward
   ;;        "*" nil ;; prefix
   ;;        "**" 'dired-mark-executables
   ;;        "*/" 'dired-mark-directories
   ;;        "*@" 'dired-mark-symlinks
   ;;        "*%" 'dired-mark-files-regexp
   ;;        "*(" 'dired-mark-sexp
   ;;        "*." 'dired-mark-extension
   ;;        "*O" 'dired-mark-omitted
   ;;        "*c" 'dired-change-marks
   ;;        "*s" 'dired-mark-subdir-files
   ;;        "*?" 'dired-unmark-all-files
   ;;        "*!" 'dired-unmark-all-marks
   ;;        "*f" 'l/dired-narrow-to-marked-files
   ;;        ;; encryption-decryption (epa-dired)
   ;;        ";d" 'epa-dired-do-decrypt
   ;;        ";v" 'epa-dired-do-verify
   ;;        ";s" 'epa-dired-do-sign
   ;;        ";e" 'epa-dired-do-encrypt
   ;;        ;; unsorted
   ;;        "X" 'l/dired-my-ext-cmds
   ;;        "z" 'dired-omit-mode
   ;;        "g" 'l/dired-nav-map
   ;;        "gr" 'revert-buffer
   ;;        "gR" 'dired-do-redisplay
   ;;        "I" 'dired-maybe-insert-subdir
   ;;        "i" 'dired-toggle-read-only
   ;;        "J" 'dired-goto-file
   ;;        "K" 'dired-do-kill-lines
   ;;        "a" 'dired-find-alternate-file
   ;;        "gy" 'dired-show-file-type
   ;;        "Y" 'dired-copy-filename-as-kill
   ;;        "+" 'dired-create-directory
   ;;        (kbd "S-<return>") 'dired-find-file-other-window
   ;;        (kbd "RET") 'dired-find-file
   ;;        (kbd "M-<return>") 'browse-url-of-dired-file
   ;;        ;; sorting
   ;;        "o" nil ;; prefix -- was dired-sort-toggle-or-edit
   ;;        "oo" 'l/dired-sort-by-name
   ;;        "od" 'l/dired-sort-by-date
   ;;        "os" 'l/dired-sort-by-size
   ;;        "ox" 'l/dired-sort-by-ext
   ;;        "o=" 'l/dired-sort-dirs-first
   ;;        "(" 'dired-hide-details-mode
   ;;        "g?" 'dired-summary
   ;;        "?" 'dired-get-size)

   ;;      (add-hook 'dired-mode-hook 'evil-normalize-keymaps)))
   #+end_src

*** DONE Dired subtree
    CLOSED: [2020-04-11 Sat 04:28]

    #+begin_src emacs-lisp
    ;; (use-package dired-subtree
      ;; :ensure t
      ;; :after dired evil
      ;; :config
      ;; (evil-define-key 'normal dired-mode-map (kbd "TAB") 'dired-subtree-toggle))
    #+end_src

*** DONE Peep dired
    CLOSED: [2020-04-11 Sat 04:23]

    Peep dired is loaded from [[https://github.com/dakodeon/peep-dired][my fork]].

**** Peepy-fied dired functions

     Some functions for a more consistent peeping experience.
     
     Note: these were left out of my peep-dired fork because they are not part of dired

     #+begin_src emacs-lisp
     ;; (defun l/peep-dired-goto-first-file ()
       ;; "Go to first file line and peep there. Uses `dired-goto-first-file'"
       ;; (interactive)
       ;; (dired-goto-first-file)
       ;; (peep-dired-display-file-other-window))

     ;; (defun l/peep-dired-goto-last-file ()
       ;; "Go to last file line and peep there. Uses `dired-goto-last-file'"
       ;; (interactive)
       ;; (dired-goto-last-file)
       ;; (peep-dired-display-file-other-window))

     ;; (defun l/peep-dired-mark-backwards ()
       ;; "Mark and peep backwards."
       ;; (interactive)
       ;; (l/dired-mark-backwards)
       ;; (peep-dired-display-file-other-window))
     #+end_src

**** Load Peep

     This is my fork of peep-dired. clone it from [[https://github.com/dakodeon/peep-dired/tree/luc][github]] and set =:load-path= to point to the correct path.

    #+begin_src emacs-lisp
    ;; (use-package peep-dired
      ;; :load-path "~/.source/peep-dired"
      ;; :delight (peep-dired " ")
      ;; :after dired-x
      ;; :init
      ;; is this that creates an error? -- Yes, do not use it, or fix it
      ;; (setq peep-dired-cleanup-eagerly t)
      ;; (setq peep-dired-ignored-extensions '("mkv" "mp4" "avi" "mov" "mp3" "wav" "iso"))
      ;; :config
      ;; evil integration
      ;; (eval-after-load "evil"
	;; '(progn
	   ;; (evil-define-key 'normal peep-dired-mode-map
	     ;; (kbd "C-j") 'peep-dired-scroll-page-down
	     ;; (kbd "C-k") 'peep-dired-scroll-page-up
	     ;; (kbd "j") 'peep-dired-next-file
	     ;; (kbd "<down>") 'peep-dired-next-file
	     ;; (kbd "k") 'peep-dired-prev-file
	     ;; (kbd "<up>") 'peep-dired-prev-file
	     ;; (kbd "h") 'peep-dired-up-directory
	     ;; (kbd "<left>") 'peep-dired-up-directory
	     ;; (kbd "l") 'peep-dired-find-file
	     ;; (kbd "<right>") 'peep-dired-find-file
	     ;; (kbd ">") 'peep-dired-next-dirline
	     ;; (kbd "<") 'peep-dired-prev-dirline
	     ;; (kbd "g g") 'l/peep-dired-goto-first-file
	     ;; (kbd "G") 'l/peep-dired-goto-last-file
	     ;; (kbd "C-SPC") 'l/peep-dired-mark-backwards)
	   ;; (evil-define-key 'normal dired-mode-map (kbd "p") 'peep-dired)
	   ;; (add-hook 'peep-dired-hook 'evil-normalize-keymaps)))
      ;; :bind
      ;; (:map dired-mode-map
	    ;; ("p" . 'peep-dired)))
    #+end_src

*** DONE Dired narrow
    CLOSED: [2020-04-11 Sat 04:30]

    Narrow down what is shown in dired by filtering filenames.

    #+begin_src emacs-lisp
    ;; (use-package dired-narrow
      ;; :ensure t
      ;; :delight (dired-narrow-mode " >⋅<")
      ;; :after dired evil
      ;; :init
      ;; (setq dired-narrow-exit-when-one-left t)
      ;; :config
      ;; (evil-define-key 'normal dired-mode-map (kbd "f") 'dired-narrow)
      ;; :bind
      ;; (:map dired-mode-map
	    ;; ("f" . 'dired-narrow)))

    #+end_src

*** DONE Copying and pasting (and bookmarks)
    CLOSED: [2020-04-11 Sat 04:50]

    Three methods of copying and pasting:
    1. Normal: The default dired way, copy and select destination on execution. Works neatly with the =dired-target-dwim= option, but sometimes you want to mark some files to copy and then paste them after some navigation.

    2. Dired-ranger: Ranger-like copying and pasting (also bookmarks, but I have to check those out)

    #+begin_src emacs-lisp
    ;; (use-package dired-ranger
      ;; :ensure t
      ;; :after dired
      ;; :init
      ;; (setq dired-ranger-bookmark-reopen 'always)
      ;; :config
      ;; function to visit previous directory
      ;; (defun l/dired-ranger-bookmark-visit-LRU ()
	;; "Go to last visited directory."
	;; (interactive)
	;; (dired-ranger-bookmark-visit dired-ranger-bookmark-LRU))

      ;; evil integration
      ;; (eval-after-load "evil"
	;; '(progn
	   ;; (evil-define-key 'normal dired-mode-map
	     ;; "y" nil ;; prefix
	     ;; "yy" 'dired-ranger-copy
	     ;; "yP" 'dired-ranger-move
	     ;; "yp" 'dired-ranger-paste
	     ;; "`" nil ;; prefix
	     ;; "``" 'l/dired-ranger-bookmark-visit-LRU
	     ;; "`v" 'dired-ranger-bookmark-visit
	     ;; "`m" 'dired-ranger-bookmark))))
    #+end_src

    3. Dired-rsync: Really useful for BIG files, as it does not freeze emacs. Also, progress is shown in the modeline! Some other benefits, like copy-pasting from remote, are not yet explored. Works like normal copying.

    #+begin_src emacs-lisp
    ;; (use-package dired-rsync
      ;; :ensure t
      ;; :after dired
      ;; :init
      ;; (setq dired-rsync-unmark-on-completion nil)
      ;; :config
      ;; (defun l/dired-rsync-to-FAT32 ()
	;; "Change `dired-rsync-options' temporarily to rsync to FAT32 driver."
	;; (interactive)
	;; (let ((dired-rsync-options "-rDz --info=progress2")
	      ;; (dest (read-file-name "rsync to: " (dired-dwim-target-directory)
			      ;; nil nil nil 'file-directory-p)))
	      ;; (dired-rsync dest)))
      ;; (eval-after-load "evil"
	;; '(progn
	   ;; (evil-define-key 'normal dired-mode-map "rr" 'dired-rsync)
	   ;; (evil-define-key 'normal dired-mode-map "rf" 'l/dired-rsync-to-FAT32))))
    #+end_src

**** TODO Simplify keystrokes:
     All this is really nice, but now I have three different keys related to copy-pasting (C, y, r). Maybe I should fix this somehow? I guess I will decide as I use it.

*** DONE Wdired [2/2]
    CLOSED: [2020-04-11 Sat 04:43]

**** DONE Renaming functions
     CLOSED: [2020-04-11 Sat 03:59]
     #+begin_src emacs-lisp
     ;; (defun l/evil-wdired-append-to-filename ()
       ;; "Renaming helper for `wdired'. Append to filename before the extension."
       ;; (interactive)
       ;; (move-end-of-line nil)
       ;; (search-backward ".")
       ;; (evil-insert 1))

     ;; (defun l/evil-wdired-change-filename ()
       ;; "Renaming helper for `wdired'. Change the filename but keep the extension."
       ;; (interactive)
       ;; (move-end-of-line nil)
       ;; (search-backward ".")
       ;; (kill-region 1 (point))
       ;; (evil-insert 1))

     ;; (defun l/evil-wdired-change-extension ()
       ;; "Renaming helper for `wdired'. Change file's extension."
       ;; (interactive)
       ;; (move-end-of-line nil)
       ;; (set-mark-command nil)
       ;; (search-backward ".")
       ;; (forward-char)
       ;; (kill-region (point) (mark))
       ;; (evil-insert 1))
     #+end_src

**** DONE Wdired hook
     CLOSED: [2020-04-11 Sat 03:59]

     Just display a message when entering wdired!

     #+begin_src emacs-lisp
     ;; (eval-after-load "evil"
       ;; '(progn
	  ;; (evil-define-key 'normal wdired-mode-map
	    ;; (kbd "C-r w") 'l/evil-wdired-change-filename
	    ;; (kbd "C-r a") 'l/evil-wdired-append-to-filename
	    ;; (kbd "C-r x") 'l/evil-wdired-change-extension)))
     #+end_src

*** DONE Dired rainbow
    CLOSED: [2020-04-11 Sat 04:53]

    Prettier dired. I haven't really tweaked anything, it's just some defaults from their github page.

    #+begin_src emacs-lisp
    ;; (use-package dired-rainbow
      ;; :ensure t
      ;; :config
      ;; (progn
	;; (dired-rainbow-define-chmod directory "#6cb2eb" "d.*")
	;; (dired-rainbow-define html "#eb5286" ("css" "less" "sass" "scss" "htm" "html" "jhtm" "mht" "eml" "mustache" "xhtml"))
	;; (dired-rainbow-define xml "#f2d024" ("xml" "xsd" "xsl" "xslt" "wsdl" "bib" "json" "msg" "pgn" "rss" "yaml" "yml" "rdata"))
	;; (dired-rainbow-define document "#9561e2" ("docm" "doc" "docx" "odb" "odt" "pdb" "pdf" "ps" "rtf" "djvu" "epub" "odp" "ppt" "pptx"))
	;; (dired-rainbow-define markdown "#ffed4a" ("org" "etx" "info" "markdown" "md" "mkd" "nfo" "pod" "rst" "tex" "textfile" "txt"))
	;; (dired-rainbow-define database "#6574cd" ("xlsx" "xls" "csv" "accdb" "db" "mdb" "sqlite" "nc"))
	;; (dired-rainbow-define media "#de751f" ("mp3" "mp4" "MP3" "MP4" "avi" "mpeg" "mpg" "flv" "ogg" "mov" "mid" "midi" "wav" "aiff" "flac"))
	;; (dired-rainbow-define image "#f66d9b" ("tiff" "tif" "cdr" "gif" "ico" "jpeg" "jpg" "png" "psd" "eps" "svg"))
	;; (dired-rainbow-define log "#c17d11" ("log"))
	;; (dired-rainbow-define shell "#f6993f" ("awk" "bash" "bat" "sed" "sh" "zsh" "vim"))
	;; (dired-rainbow-define interpreted "#38c172" ("py" "ipynb" "rb" "pl" "t" "msql" "mysql" "pgsql" "sql" "r" "clj" "cljs" "scala" "js"))
	;; (dired-rainbow-define compiled "#4dc0b5" ("asm" "cl" "lisp" "el" "c" "h" "c++" "h++" "hpp" "hxx" "m" "cc" "cs" "cp" "cpp" "go" "f" "for" "ftn" "f90" "f95" "f03" "f08" "s" "rs" "hi" "hs" "pyc" ".java"))
	;; (dired-rainbow-define executable "#8cc4ff" ("exe" "msi"))
	;; (dired-rainbow-define compressed "#51d88a" ("7z" "zip" "bz2" "tgz" "txz" "gz" "xz" "z" "Z" "jar" "war" "ear" "rar" "sar" "xpi" "apk" "xz" "tar"))
	;; (dired-rainbow-define packaged "#faad63" ("deb" "rpm" "apk" "jad" "jar" "cab" "pak" "pk3" "vdf" "vpk" "bsp"))
	;; (dired-rainbow-define encrypted "#ffed4a" ("gpg" "pgp" "asc" "bfe" "enc" "signature" "sig" "p12" "pem"))
	;; (dired-rainbow-define fonts "#6cb2eb" ("afm" "fon" "fnt" "pfb" "pfm" "ttf" "otf"))
	;; (dired-rainbow-define partition "#e3342f" ("dmg" "iso" "bin" "nrg" "qcow" "toast" "vcd" "vmdk" "bak"))
	;; (dired-rainbow-define vc "#0074d9" ("git" "gitignore" "gitattributes" "gitmodules"))
	;; (dired-rainbow-define-chmod executable-unix "#38c172" "-.*x.*")
	;; ))
    #+end_src

*** DONE Dired icons
    CLOSED: [2020-04-11 Sat 04:56]

    Pretty icons for Dired!

    #+begin_src emacs-lisp
    ;; (use-package all-the-icons-dired
      ;; :ensure t
      ;; :delight
      ;; :after dired all-the-icons
      ;; :config
      ;; (add-hook 'dired-mode-hook 'all-the-icons-dired-mode))
    #+end_src

** PDF TOOLS

   Pdf-tools cannot handle an update.
   #+begin_src emacs-lisp
     ;; (use-package pdf-tools
       ;; :ensure t
       ;; :pin manual ;; don't reinstall on updates
       ;; :init
       ;; (pdf-tools-install))

     ;; (add-to-list 'load-path "~/.source/pdf-tools")
     ;; (require 'pdf-tools)
     ;; (eval-after-load "pdf-tools"
       ;; (pdf-tools-install))
   #+end_src

** DIARY AND CALENDAR

   It made sense for these two to be configured together.

   I want to make diary/calendar mode my default scheduling application.
   The diary will show upon entering emacs, and all the diary entries will be shown in the calendar.
   
   #+begin_src emacs-lisp
   ;; default diary file
   (setq diary-file "~/.personal/diary")

   ;; default entries shown in the diary
   (setq diary-number-of-entries 7)

   ;; date style
   (calendar-set-date-style 'european)

   ;; calendar-diary integration
   (setq calendar-view-diary-initially-flag t)
   (setq calendar-mark-diary-entries-flag t)

   ;; launch diary on startup
   (diary)
   #+end_src
   
*** TODO Future improvements
    - External notifications using dunst
    - Add/remove entries easily (org-capture?)
    - Archive old entries, keep clean file (maybe)
    - Integration with org-agenda

** VTERM

   A new friend in the family! I am pretty excited about this,
after testing it seems to be a viable option for a terminal emulator
inside of emacs.

#+begin_src emacs-lisp
(use-package vterm
  :load-path "~/.source/emacs-libvterm"
  :init
  (setq vterm-kill-buffer-on-exit t)
  (setq vterm-clear-scrollback t))
#+end_src

** ORG-MODE
*** Ensure org-plus-contrib

    #+begin_src emacs-lisp
    (unless (package-installed-p 'org-plus-contrib)
      (package-refresh-contents)
      (package-install 'org-plus-contrib))
    #+end_src

*** Org-mode misc options

    #+begin_src emacs-lisp
    ;; prettify
    (setq org-hide-leading-stars t)

    ;; tables
    (define-key org-mode-map (kbd "C-x ,") 'org-table-toggle-column-width)

    ;; src options
    (require 'org-tempo)

    (setq org-src-fontify-natively t)
    (setq org-src-tab-acts-natively t)
    (setq org-confirm-babel-evaluate nil)
    (setq org-edit-src-content-indentation 0)

    (setq org-special-ctrl-a/e t)
    (setq org-src-window-setup 'current-window)
    ;; export options -- for mail html export (fix it locally!)
    ;;    (setq org-export-with-toc nil)
    ;;  (setq org-export-with-section-numbers nil)

    ;; links
    (setq org-link-search-must-match-exact-headline nil)
    #+end_src

*** Org-mode capture and agenda

    #+begin_src emacs-lisp
    ;; files
    (setq org-directory "~/.personal")
    (setq org-default-notes-file (concat org-directory "/organizer.org"))

    ;; include diary entries in agenda
    (setq org-agenda-include-diary t)

    ;; TODOs
    (setq org-log-done 'time)
    (setq org-log-into-drawer 'LOGBOOK)
    (setq org-clock-into-drawer t)


    ;; bindings
    (global-set-key (kbd "C-c l") 'org-store-link)
    (global-set-key (kbd "C-c a") 'org-agenda)
    (global-set-key (kbd "C-c c") 'org-capture)
    (global-set-key (kbd "C-c C-x C-z") 'org-resolve-clocks)

    ;; some capture functions from Zamansky's configuration
    (defadvice org-capture-finalize
	(after delete-capture-frame activate)
      "Advise capture-finalize to close the frame"
      (if (equal "capture" (frame-parameter nil 'name))
	  (delete-frame)))

    (defadvice org-capture-destroy
	(after delete-capture-frame activate)
      "Advise capture-destroy to close the frame"
      (if (equal "capture" (frame-parameter nil 'name))
	  (delete-frame)))

    (defun make-capture-frame ()
      "Create a new frame and run org-capture."
      (interactive)
      (make-frame '((name . "capture")))
      (select-frame-by-name "capture")
      (delete-other-windows))
    #+end_src

*** Org-capture templates

    #+begin_src emacs-lisp
    (setq org-capture-templates
	  '(("t" "Todo" entry (file+headline "" "Tasks")
	     "* TODO %?\n  %i\n  %a")

	    ("j" "Journal" entry (file+datetree "journal.org")
	     "* %^{entry title}%^G\n%U\n  %?\n")

	    ("p" "Logs for photographic process")

	    ("pd" "Darkroom log" entry (file+datetree "darkroom-log.org")
	     "* %U :darkroom:%^g\n%?" :clock-in t)

	    ("r" "Rempetika lyrics" entry (file+headline "~/stixoi.org" "Στίχοι ρεμπέτικα")
	     "* %^{ΤΙΤΛΟΣ}\n%^{ΤΡΑΓΟΥΔΙΣΤΗΣ}p%^{ΣΥΝΘΕΤΗΣ}p%^{ΡΥΘΜΟΣ}p%^{ΔΡΟΜΟΣ}p%^{ΤΟΝΟΣ}p\n%x")

	    ;; ("B" "Web purchase" entry (file+headline "web-stuff.org" "Purchases")
	    ;;  "* ORDERED %^{item desc.}\n\n%x\n\nEst. delivery: %?\n\nOrder placed on: %U")

	    ;; ("l" "Link" entry (file+headline "web-stuff.org" "Links")
	    ;;  "* %x %^g\n %?\n%U")

	    ;; ("b" "Bibliography reference" entry (file "bib-references.org")
	    ;;  "* @%^{.bib entry}: %^{description} %^g\n %^{page(s)} %?\n%U")

	    ("c" "Contact" entry (file "contacts.org")
	     "* %^{NICKNAME}\n%^{EMAIL}p\n:END:")
	    ))
    #+end_src

*** Org-contacts

    #+begin_src emacs-lisp
    (use-package org-contacts
      :ensure nil
      :after org mu4e
      :custom (org-contacts-files '("~/.personal/contacts.org"))
      :bind  ("C-x M-." . 'org-contacts-view-send-email))
    #+end_src

*** org-msg
    #+begin_src emacs-lisp
    (use-package org-msg
      :ensure t
      :after org mu4e
      :bind
      (:map mu4e-compose-mode-map ("M-c" . 'org-msg-edit-mode)))
    #+end_src

*** org-general

    Temporary fix. Later to be declared in use-package.

    #+begin_src emacs-lisp
    (evil-leader-org
       :keymaps 'org-mode-map
       :states 'normal
       "p" 'org-set-property)
    #+end_src

** LATEX

   #+begin_src emacs-lisp
   (setq TeX-parse-self t)
   (setq-default TeX-master nil)

   ;; === run xelatex on save for latex mode
   (defun latex-save-compile ()
     "Compile file after saving in latex mode. Using Xelatex."
     (when (eq major-mode 'latex-mode)
       (when (memq this-command '(save-buffer))
	 (shell-command-to-string (format "xelatex %s" buffer-file-name)))))

   (add-hook 'after-save-hook #'latex-save-compile)
   #+end_src

** MU4E
*** mu4e basic setup

    #+begin_src emacs-lisp
    (add-to-list 'load-path "/usr/local/share/emacs/site-lisp/mu4e")
    (require 'mu4e)

    (global-set-key (kbd "C-x m") 'mu4e)

    ;; some interface options
    (setq mu4e-confirm-quit nil) ;; do not confirm quitting
    (setq mail-user-agent 'mu4e-user-agent) ;; make mu4e the default for email
    (setq message-kill-buffer-on-exit t) ;; kill message buffer on exit
    (setq mu4e-index-update-in-background t) ;; do not show me the update process
    (setq mu4e-hide-index-messages t)
    (setq mu4e-headers-include-related nil)
    (setq mu4e-compose-dont-reply-to-self nil)
    (setq mu4e-compose-signature-auto-include nil)
    (setq mu4e-sent-messages-behavior 'sent)
    (setq mu4e-change-filenames-when-moving t)
    (setq mu4e-attachment-dir "~/Downloads")
    (setq mu4e-view-show-addresses t)
    (setq mu4e-headers-visible-columns 60)
    (setq mu4e-split-view 'vertical) ;; should write a function: if height is longer than width, split horizontally
    ;; this one does not work out of the box. Emacs needs to be compiled with imagemagick support. Will look into this
    (setq mu4e-show-images t)
    (when (fboundp 'imagemagick-register-types)
      (imagemagick-register-types))

    (add-to-list 'mu4e-view-actions '("ViewInBrowser" . mu4e-action-view-in-browser) t)

    (setq mu4e-user-mail-address-list '("loukas.bass@gmx.com"
					"dakodeon@hotmail.com"
					"freehuggs701@gmail.com"
					"luc.bassoukos@gmail.com"))
    #+end_src

*** mu4e (smtp setup)

    #+begin_src emacs-lisp
    (require 'smtpmail)

    (setq message-send-mail-function 'smtpmail-send-it
	  smtpmail-default-smtp-server "mail.gmx.com"
	  smtpmail-smtp-server "mail.gmx.com"
	  smtpmail-smtp-user "loukas.bass@gmx.com"
	  smtpmail-stream-type 'starttls
	  smtpmail-smtp-service 587
	  smtpmail-debug-info t)
    #+end_src

*** mu4e sync mail

    #+begin_src emacs-lisp
    (setq mu4e-get-mail-command "mbsync -c ~/.config/mbsyncrc -a") ;; default location of mbsyncrc is in ~
    (setq mu4e-html2text-command "w3m -T text/html")
    (setq mu4e-update-interval nil) ;; do not auto-update, this is done with cronjob
    (setq mu4e-headers-auto-update t)
    #+end_src

*** mu4e directories

    #+begin_src emacs-lisp
    (setq mu4e-maildir (expand-file-name "~/.personal/Mail"))

    ;; default directories
    (setq mu4e-drafts-folder "/loukas.bass/Drafts")
    (setq mu4e-sent-folder "/loukas.bass/Sent")
    (setq mu4e-trash-folder "/loukas.bass/Trash")

    ;; maildirs shortcuts
    (setq mu4e-maildir-shortcuts
	  '( ("/Inbox" . ?i)
	     ("/loukas.bass/Inbox" . ?l)
	     ("/loukas.bass/Sent" . ?s)
	     ("/loukas.bass/Trash" . ?t)
	     ("/loukas.bass/Drafts" . ?D)
	     ("/gmail/Inbox" . ?g)
	     ("/gmail_luc/Inbox" . ?G)
	     ("/dakodeon/Inbox" . ?d)))
    #+end_src

*** mu4e contexts

    #+begin_src emacs-lisp
    (setq mu4e-contexts
	  `( ,(make-mu4e-context
	       :name "loukas.bass"
	       :match-func (lambda (msg)
			     (when msg
			       (mu4e-message-contact-field-matches msg
								   :to "loukas.bass@gmx.com")))
	       :vars '((smtpmail-smtp-user . "loukas.bass@gmx.com")
		       (smtpmail-default-smtp-server . "mail.gmx.com")
		       (smtpmail-smtp-server . "mail.gmx.com")
		       (user-mail-address . "loukas.bass@gmx.com")
		       (user-full-name . "loukas bass")
		       (mu4e-sent-folder . "/loukas.bass/Sent")
		       (mu4e-drafts-folder . "/loukas.bass/Drafts")
		       (mu4e-trash-folder . "/loukas.bass/Trash")))

	     ,(make-mu4e-context
	       :name "gmail_luc"
	       :match-func (lambda (msg)
			     (when msg
			       (mu4e-message-contact-field-matches msg
								   :to "luc.bassoukos@gmail.com")))
	       :vars '((smtpmail-smtp-user . "luc.bassoukos@gmail.com")
		       (smtpmail-default-smtp-server . "smtp.gmail.com")
		       (smtpmail-smtp-server . "smtp.gmail.com")
		       (user-mail-address . "luc.bassoukos@gmail.com")
		       (user-full-name . "freexon")
		       (mu4e-sent-folder . "/gmail_luc/[Gmail]/Sent Mail")
		       (mu4e-drafts-folder . "/gmail_luc/Drafts")
		       (mu4e-trash-folder . "/gmail_luc/Trash")))

	     ,(make-mu4e-context
	       :name "gmail"
	       :match-func (lambda (msg)
			     (when msg
			       (mu4e-message-contact-field-matches msg
								   :to "freehuggs701@gmail.com")))
	       :vars '((smtpmail-smtp-user . "freehuggs701@gmail.com")
		       (smtpmail-default-smtp-server . "smtp.gmail.com")
		       (smtpmail-smtp-server . "smtp.gmail.com")
		       (user-mail-address . "freehuggs701@gmail.com")
		       (user-full-name . "freexon")
		       (mu4e-sent-folder . "/gmail/[Gmail]/Sent Mail")
		       (mu4e-drafts-folder . "/gmail/Drafts")
		       (mu4e-trash-folder . "/gmail/Trash")))

	     ,(make-mu4e-context
	       :name "dakodeon"
	       :match-func (lambda (msg)
			     (when msg
			       (mu4e-message-contact-field-matches msg
								   :to "dakodeon@hotmail.com")))
	       :vars '((smtpmail-smtp-user . "dakodeon@hotmail.com")
		       (smtpmail-default-smtp-server . "smtp.office365.com")
		       (smtpmail-smtp-server . "smtp.office365.com")
		       (user-mail-address . "dakodeon@hotmail.com")
		       (user-full-name . "loukas b")
		       (mu4e-sent-folder . "/dakodeon/Sent")
		       (mu4e-drafts-folder . "/dakodeon/Drafts")
		       (mu4e-trash-folder . "/dakodeon/Trash")))))

    (setq mu4e-context-policy 'pick-first)

    ;; it is useful for a lot of queries to have a list of contexts

    (defvar l/mu4e-context-names
      (mapcar (lambda (x) (car x))
	      (cl-map 'list (lambda (context)
			      (cons (mu4e-context-name context) context))
		      mu4e-contexts)))
    #+end_src

*** mu4e bookmarks

    #+begin_src emacs-lisp
    ;; get only the last received message
    (defun l/mu4e-fetch-last-received-msg ()
      "Shows the last received message in mu4e"
      (interactive)
      (let* ((query (string-trim (format "%s" (mapcar (lambda (x) (concat "maildir:/" x "/Inbox OR ")) l/mu4e-context-names)) "(" " OR )")))
	(mu4e-headers-search (concat "msgid:" (string-trim (shell-command-to-string (concat "mu find -n 1 --fields \"i\" --sortfield=date --reverse " query)) nil "\n")))))

    (eval-after-load "evil"
      '(progn
	(evil-define-key 'normal mu4e-main-mode-map
	  "gl" 'l/mu4e-fetch-last-received-msg)
	(evil-define-key 'normal mu4e-headers-mode-map
	  "gl" 'l/mu4e-fetch-last-received-msg)))


    ;; brazenly stolen from the manual, then changed to fit my contexts
    ;; Asks for how many days' messages to show
    (defun l/mu4e-bookmark-num-days-old-query (days-old)
      (interactive (list (read-number "How many days? " 2)))
      (let ((start-date (subtract-time (current-time) (days-to-time days-old)))
	    (maildirquery (string-trim (format "%s" (mapcar (lambda (x) (concat "maildir:/" x "/Inbox OR ")) l/mu4e-context-names)) "(" " OR )")))
	(concat "(" maildirquery ") AND date:"
		(format-time-string "%Y%m%d" start-date))))

    (setq mu4e-bookmarks
	  `( ,(make-mu4e-bookmark
	       :name "Unread messages"
	       :query "flag:unread AND NOT flag:trashed"
	       :key ?u)
	     ,(make-mu4e-bookmark
	       :name "Today's messages"
	       :query "date:today..now"
	       :key ?t)
	     ,(make-mu4e-bookmark
	       :name "Messages from last [x] days"
	       :query (lambda () (call-interactively 'l/mu4e-bookmark-num-days-old-query))
	       :key ?w)))			;; TODO: fetch messages of the last x minutes

    #+end_src

*** mu4e open in headers of specific account

    #+begin_src emacs-lisp
    (defun mu4e-open-in-headers (account)
      "Open mu4e in account's Inbox"
      (interactive)
      (mu4e~start)
      (if (get-buffer "*mu4e-headers*" )
	  (switch-to-buffer "*mu4e-headers*"))
      (mu4e-headers-search (concat "maildir:/" account "/Inbox")))
    #+end_src

*** mu4e open directly in unread messages

    #+begin_src emacs-lisp
    (defun l/mu4e-open-unread ()
      "Open mu4e in unread messages."
      (interactive)
      (mu4e-headers-search "flag:unread AND NOT flag:trashed"))
    #+end_src

*** mu4e change split depending on window dimensions

    #+begin_src emacs-lisp
    (defun l/mu4e-view-change-split-advice ()
      "Used to advice `mu4e-headers-view-message'.
    Changes the way windows split when viewing a message depending on current window size.
    If height is greater than width, split horizontally. Else, split vertically"
      (if (> (window-pixel-height) (window-pixel-width))
	  (setq mu4e-split-view 'horizontal)
	(setq mu4e-split-view 'vertical)))

    (advice-add 'mu4e-headers-view-message :before #'l/mu4e-view-change-split-advice)

    #+end_src

*** mu4e external notifications (for i3blocks)

    #+begin_src emacs-lisp
    (add-hook 'mu4e-index-updated-hook
	      (defun mu4e-signal-i3blocks ()
		(shell-command "pkill -RTMIN+2 i3blocks")))

    (add-hook 'mu4e-view-mode-hook 'mu4e-signal-i3blocks)
    #+end_src

*** Contacts management

Manage contacts with org-contacts

#+begin_src emacs-lisp
(setq mu4e-org-contacts-file "~/.personal/contacts.org")

(add-to-list 'mu4e-headers-actions
	     '("org-contact-add" . mu4e-action-add-org-contact) t)

(add-to-list 'mu4e-view-actions
	     '("org-contact-add" . mu4e-action-add-org-contact) t)
#+end_src

*** Start mu4e

Auto start mu4e on emacs startup

    #+begin_src emacs-lisp
    (mu4e~start)
    (mu4e-update-mail-and-index t)
    #+end_src
*** mu4e general

    Temporary fix. Later to be declared in use-package

    #+begin_src emacs-lisp
    (evil-leader 'normal
      "m" 'l/mu4e-open-unread)
    #+end_src
** CUSTOM FILE SHORTCUTS

   #+begin_src emacs-lisp
   ;; (defun goto-file-or-dir (f)
     ;; "Find the given file. If file is a directory, run dired"
     ;; (if (file-directory-p f)
	 ;; (helm-find-files-1 f)
       ;; (if (file-exists-p f)
	   ;; (find-file f))))

   ;; create a prefix
   (define-prefix-command 'z-map)
   (global-set-key (kbd "C-x g") 'z-map)

   (define-key z-map (kbd "E") (lambda () (interactive) (find-file "~/.emacs.d/init.el")))
   (define-key z-map (kbd "e") (lambda () (interactive) (find-file "~/.emacs.d/my-config.org")))
   (define-key z-map (kbd "i") (lambda () (interactive) (find-file "~/.config/i3/i3.conf")))
   (define-key z-map (kbd "r") (lambda () (interactive) (find-file "~/.config/ranger/rc.conf")))
   (define-key z-map (kbd "x") (lambda () (interactive) (find-file "~/.Xresources")))
   (define-key z-map (kbd "z") (lambda () (interactive) (find-file "~/.zshrc")))
   (define-key z-map (kbd "h") (lambda () (interactive) (find-file "~/")))
   (define-key z-map (kbd "P") (lambda () (interactive) (find-file "~/Pictures/")))
   (define-key z-map (kbd "p") (lambda () (interactive) (find-file "~/.personal/")))
   (define-key z-map (kbd "C") (lambda () (interactive) (find-file "~/.config/")))
   (define-key z-map (kbd "D") (lambda () (interactive) (find-file "~/Downloads/")))
   (define-key z-map (kbd "d") (lambda () (interactive) (find-file "~/Documents/")))
   (define-key z-map (kbd "!") (lambda () (interactive) (find-file "~/.source/dotfiles/")))
   (define-key z-map (kbd "S") (lambda () (interactive) (find-file "~/.local/bin/")))
   #+end_src
 
** GAMES
*** SNAKE
    
    #+begin_src emacs-lisp
    (eval-after-load "evil"
      '(progn
	 (evil-set-initial-state 'snake-mode 'normal)
	 (evil-define-key 'normal snake-mode-map
	   "h" 'snake-move-left
	   "j" 'snake-move-down
	   "k" 'snake-move-up
	   "l" 'snake-move-right
	   "p" 'snake-pause-game
	   "q" 'quit-window
	   "N" 'snake-start-game)))
    #+end_src
*** 2048

    #+begin_src emacs-lisp
    (use-package 2048-game
      :ensure t)
    #+end_src


