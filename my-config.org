* EMACS CONFIG

Emacs configuration managed with org-mode and use-package.

The code snippets are loaded by =init.el=, which also loads =use-package=.

** INTERFACE
*** Try packages

    #+begin_src emacs-lisp
    (use-package try
      :ensure t)
    #+end_src

*** Defaults

    #+begin_src emacs-lisp
    (setq inhibit-splash-screen t)       ;; disable the splash screen
    (setq initial-scratch-message nil)   ;; disable scratch message
    (tool-bar-mode -1)                   ;; all bars off
    (menu-bar-mode -1)
    (scroll-bar-mode -1)
    (blink-cursor-mode -1)
    (column-number-mode 1)               ;; show cursor position
    (global-visual-line-mode t)          ;; visual line mode everywhere
    (global-hl-line-mode t)              ;; highlight active line
    ;; (set-face-background ('hl-line) "#202020")
    (fset 'yes-or-no-p 'y-or-n-p)        ;; ask me for y or n
    (setq select-enable-clipboard t)     ;; use the clipboard for yanking
    (setq save-interprogram-paste-before-kill t)
    (setq help-window-select t)          ;; always focus on help windows
    (setq sentence-end-double-space nil) ;; better sentence navigation
    (delete-selection-mode 1)            ;; typing deletes selected text
    (set-language-environment "UTF-8")   ;; always use UTF-8 encoding
    (set-default-coding-systems 'utf-8)
    #+end_src

*** Enable some disabled features

    #+begin_src emacs-lisp
    (put 'downcase-region 'disabled nil) ;; binds to 'C-x C-l'
    (put 'upcase-region 'disabled nil) ;; binds to 'C-x C-u'
    (put 'narrow-to-region 'disabled nil) ;; binds to 'C-x n n'
    #+end_src

*** Font size

    #+begin_src emacs-lisp
    (global-set-key (kbd "C-<next>") 'text-scale-increase)
    (global-set-key (kbd "C-<prior>") 'text-scale-decrease)
    #+end_src

*** Line numbering

    #+begin_src emacs-lisp
    (display-line-numbers-mode t)

    (use-package linum-relative
      :ensure t
      :after org
      :init
      (setq linum-relative-current-symbol "")
      :bind ("C-x M-l" . linum-relative-toggle))
    #+end_src

*** Darkroom mode

    A nice mode for reading and writing, similar to vim's goyo
    Does it make sense to configure follow-mode here? Maybe.

    #+begin_src emacs-lisp
    (use-package darkroom
      :ensure t
      :init
      (setq darkroom-text-scale-increase 0.8)
      :bind
      (("C-M-_" . darkroom-decrease-margins)
       ("C-x M-D" . darkroom-tentative-mode)))

    (global-set-key (kbd "C-x M-L") 'follow-mode)
    #+end_src

*** Rainbow mode

    #+begin_src emacs-lisp
    (use-package rainbow-mode
      :ensure t
      :hook prog-mode)
    #+end_src

*** Load theme

    #+begin_src emacs-lisp
    (use-package color-theme-sanityinc-tomorrow
      :ensure t)

    (color-theme-sanityinc-tomorrow--define-theme bright)
    #+end_src

*** Which key

    #+begin_src emacs-lisp
    (use-package which-key
      :ensure t
      :config (which-key-mode))
    #+end_src
*** Default files

    Change the way that emacs keeps backups, also some default files, like custom

    #+begin_src emacs-lisp
    ;; use separate custom file
    (setq custom-file "~/.emacs.d/custom.el")
    (load custom-file)

    ;; backup files
    (setq backup-directory-alist `(("." . "~/.emacs.d/backups")))
    (setq backup-by-copying t) ;; this is to ensure all edited files keep their inodes
    #+end_src

** FUNCTIONALITY
*** Whole buffer evaluation

    #+begin_src emacs-lisp
    (global-set-key (kbd "C-x C-S-e") 'eval-buffer)
    #+end_src

*** Toggle comments

    #+begin_src emacs-lisp
    (global-set-key (kbd "C-;") 'comment-line)
    (global-set-key (kbd "C-M-;") 'comment-or-uncomment-region)
    #+end_src

*** Parentheses

    #+begin_src emacs-lisp
    (use-package smartparens-config
      :ensure smartparens
      :init
      (smartparens-global-mode 1)
      (show-smartparens-global-mode 1)
      (sp-local-pair 'emacs-lisp-mode "'" nil :actions nil)
      :bind
      ("M-s" . sp-splice-sexp))

    (use-package rainbow-delimiters
      :ensure t
      :init
      (add-hook 'prog-mode-hook #'rainbow-delimiters-mode))

    #+end_src

*** Expand region

    #+begin_src emacs-lisp
    (use-package expand-region
      :ensure t
      :bind
      (("C-=" . er/expand-region)
       ("C-c =" . er/expand-region)
       ("C--" . er/contract-region)
       ("C-c -" . er/contract-region)))
    #+end_src

*** Smarter move to beginning of line
    
    Part of Prelude

    #+begin_src emacs-lisp
    (defun smarter-move-beginning-of-line (arg)
      "Move point back to indentation of beginning of line.

    Move point to the first non-whitespace character on this line.
    If point is already there, move to the beginning of the line.
    Effectively toggle between the first non-whitespace character and
    the beginning of the line.

    If ARG is not nil or 1, move forward ARG - 1 lines first.  If
    point reaches the beginning or end of the buffer, stop there."
      (interactive "^p")
      (setq arg (or arg 1))

      ;; Move lines first
      (when (/= arg 1)
	(let ((line-move-visual nil))
	  (forward-line (1- arg))))

      (let ((orig-point (point)))
	(back-to-indentation)
	(when (= orig-point (point))
	  (move-beginning-of-line 1))))

    (global-set-key [remap move-beginning-of-line] 'smarter-move-beginning-of-line)
    #+end_src

    Kill the whole line

    #+begin_src emacs-lisp
    (global-set-key (kbd "C-S-k") 'kill-whole-line)   
    #+end_src

*** Duplicate line

    #+begin_src emacs-lisp
    (defun duplicate-line()
      "Duplicates a line."
      (interactive)
      (move-beginning-of-line 1)
      (kill-line)
      (yank)
      (open-line 1)
      (next-line 1)
      (yank))

    (global-set-key (kbd "C-c d") 'duplicate-line)
    #+end_src

*** Windows movement and resizing
  
    This would be good if my damn keyboard worked correctly. I think I should use vim keys or sth

    #+begin_src emacs-lisp
    (windmove-default-keybindings) ;; use arrow keys ot navigate

    ;; resize shortcuts
    (global-set-key (kbd "S-C-<left>") 'shrink-window-horizontally)
    (global-set-key (kbd "S-C-<right>") 'enlarge-window-horizontally)
    (global-set-key (kbd "S-C-<down>") 'shrink-window)
    (global-set-key (kbd "S-C-<up>") 'enlarge-window)
    #+end_src

*** Auto-evaluate init file
    
    Auto-evaluate the init.el file when saving this org file. A must have!

    Got the general idea from https://www.reddit.com/r/emacs/comments/8hpyp5/tip_how_to_execute_a_bash_function_when_saving_a/

    #+begin_src emacs-lisp

    (defun louk/reload-emacs ()
      "Reload the init file"
      (interactive)
      (load-file "~/.emacs.d/init.el"))

    (defun my/cmd-after-saved-file ()
      "Evaluate the init file automatically"
	(when (string= (buffer-file-name) (expand-file-name "~/.emacs.d/my-config.org"))
	  (louk/reload-emacs)))

    (add-hook 'after-save-hook 'my/cmd-after-saved-file)

    ;; also makes sense to bind a "refresh" key, similar to the i3 config
    (global-set-key (kbd "C-M-S-r") 'louk/reload-emacs)
    #+end_src

** WINDOW MANAGEMENT
*** Ace-window

    #+begin_src emacs-lisp
    (use-package ace-window
      :ensure t
      :bind
      (("C-x o" . ace-window)
       ("C-x M-o" . ace-swap-window)))
    #+end_src

*** Split windows and follow

    #+begin_src emacs-lisp
    (defun split-and-follow-horizontally ()
      "Split and follow container horizontally."
      (interactive)
      (split-window-below)
      (balance-windows)
      (other-window 1))

    (defun split-and-follow-vertically ()
      "Split and follow container vertically."
      (interactive)
      (split-window-right)
      (balance-windows)
      (other-window 1))

    (global-set-key (kbd "C-x 2") 'split-and-follow-horizontally)
    (global-set-key (kbd "C-x 3") 'split-and-follow-vertically)

    #+end_src

*** Toggle window split

    #+begin_src emacs-lisp
    (defun toggle-window-split ()
      "Switch between horizontal and vertical split when using two windows."
      (interactive)
      (if (= (count-windows) 2)
	  (let* ((this-win-buffer (window-buffer))
		 (next-win-buffer (window-buffer (next-window)))
		 (this-win-edges (window-edges (selected-window)))
		 (next-win-edges (window-edges (next-window)))
		 (this-win-2nd (not (and (<= (car this-win-edges)
					     (car next-win-edges))
					 (<= (cadr this-win-edges)
					     (cadr next-win-edges)))))
		 (splitter
		  (if (= (car this-win-edges)
			 (car (window-edges (next-window))))
		      'split-window-horizontally
		    'split-window-vertically)))
	    (delete-other-windows)
	    (let ((first-win (selected-window)))
	      (funcall splitter)
	      (if this-win-2nd (other-window 1))
	      (set-window-buffer (selected-window) this-win-buffer)
	      (set-window-buffer (next-window) next-win-buffer)
	      (select-window first-win)
	      (if this-win-2nd (other-window 1))))))

    (global-set-key (kbd "C-x |") 'toggle-window-split)
    #+end_src

*** Swap windows

    #+begin_src emacs-lisp
    (global-set-key (kbd "C-x \\") 'window-swap-states)
    #+end_src

** HELM
*** Basics
   #+begin_src emacs-lisp
   (use-package helm-config
     :ensure helm
     :defer 1
     :init
     (setq helm-follow-mode-persistent t)
     (setq  helm-split-window-inside-p t)
     :config
     (helm-mode 1)
     :bind
     ("M-x" . helm-M-x)
     ("C-x C-f" . helm-find-files)
     ("M-y" . helm-show-kill-ring)
     ([remap switch-to-buffer] . helm-buffers-list))
   #+end_src
   
*** Helm-swoop
    #+begin_src emacs-lisp
    (use-package helm-swoop
      :ensure t
      :after helm evil
      :init
      (setq helm-swoop-speed-or-color t)
      ;; pre-input disabled or marked word
      (setq helm-swoop-pre-input-function
	  (lambda ()
	    (if mark-active
		(buffer-substring-no-properties (mark) (point)) "")))
      :bind
      ("M-i" . 'helm-swoop)
      ("C-M-i" . 'helm-multi-swoop)
      ("M-I" . 'helm-swoop-back-to-last-point)
      (:map helm-swoop-map
	    ("M-i" . 'helm-multi-swoop-all-from-helm-swoop))
      (:map isearch-mode-map
	    ("M-i" . 'helm-swoop-from-isearch))
      (:map evil-motion-state-map
	    ("M-i" . 'helm-swoop-from-evil-search)))

    #+end_src
** AUTOCOMPLETE
   
   Maybe use another option, like company. I have to check it out.

   #+begin_src emacs-lisp
   (use-package auto-complete
     :ensure t
     :init
     (ac-config-default)
     (global-auto-complete-mode t)
     (setq ac-sources (append ac-sources '(ac-sources-filename)))
     (setq ac-ignore-case nil))
   #+end_src

** MULTIPLE CURSORS

   It seems that the mc package is not really needed. Maybe everything it does can be achieved by using replacement methods and/or macros. Not to mention vim's =:g= command, or helm-swoop.

   #+begin_src emacs-lisp
   (use-package multiple-cursors
     :ensure t
     :bind
     ("C-s-c C-s-c" . mc/edit-lines)
     ("C->" . mc/mark-next-like-this)
     ("C-<" . mc/mark-previous-like-this)
     ("C-c C-<" . mc/mark-all-like-this)
     ("C-<down-mouse-1>" . mc/add-cursor-on-click)
     ("C-!" . mc/insert-numbers))

   (use-package mc-extras
     :ensure t
     :after multiple-cursors)

   (use-package ace-mc
     :ensure t
     :after mc-extras
     :bind
     ("C-c )" . ace-mc-add-multiple-cursors)
     ("C-M-)" . ace-mc-add-single-cursor))
   #+end_src

** DIRED
*** Dired-x
    #+begin_src emacs-lisp
    (use-package dired-x
      :ensure nil
      :after dired
      :config
      (setq dired-omit-files (concat dired-omit-files "\\|^\\..+$\\|xmp$\\|srt$")))
    #+end_src
*** Some useful functions
**** Attatch marked files to email
 Using dired, as found [[https://emacs.stackexchange.com/questions/14652/attach-multiple-files-from-the-same-directory-to-an-email-message][here]].

 Open a dired buffer, mark some files and run the command. If there's an open message buffer use it, else create new message

 #+begin_src emacs-lisp
   (defun compose-attach-marked-files ()
     "Compose mail and attach all the marked files from a dired buffer. Uses `compose-mail', (or `org-msg-attach-attach' if org-msg is enabled -- this is not true yet)."
     (interactive)
     (let ((files (dired-get-marked-files)))
       (compose-mail nil nil nil t)
       (dolist (file files)
	     (if (file-regular-p file)
		 (mml-attach-file file
				  (mm-default-file-encoding file)
				  nil "attachment")
	       (message "skipping non-regular file %s" file)))))
 #+end_src

**** Get files size
     Source: https://www.emacswiki.org/emacs/dired-extension.el
     #+begin_src emacs-lisp
     (defun dired-get-size ()
       "Get total size of marked files with `du' command.
     If not marked any files, default is current file or directory."
       (interactive)
       (let ((files (dired-get-marked-files)))
	 (with-temp-buffer
	   (apply 'call-process "/usr/bin/du" nil t nil "-sch" files)
	   (message "Size of all marked files: %s"
		    (progn
		      (re-search-backward "\\(^[0-9.,]+[A-Za-z]+\\).*\\(total\\|总用量\\)$")
		      (match-string 1))))))
     #+end_src

**** Go to first/last directory
 Instead of going to the beginning of the buffer, go to the first directory line. Going to the last directory line is used for consistency.
 Source: https://www.emacswiki.org/emacs/dired-extension.el

 #+begin_src emacs-lisp
 (defun dired-goto-first-file ()
   "Move cursor to first file of dired."
   (interactive)
   (goto-char (point-min))
   (while (not (dired-move-to-filename))
     (call-interactively 'dired-next-line)))

 (defun dired-goto-last-file ()
   "Move cursor to last file of dired."
   (interactive)
   (goto-char (point-max))
   (while (not (dired-move-to-filename))
     (call-interactively 'dired-previous-line)))
 #+end_src

*** Dired custom maps
    #+begin_src emacs-lisp
    (define-prefix-command 'louk/dired-nav-map)

    (define-key louk/dired-nav-map (kbd "h") (lambda () (interactive) (dired "~/")))
    (define-key louk/dired-nav-map (kbd "D") (lambda () (interactive) (dired "~/Downloads/")))
    (define-key louk/dired-nav-map (kbd "d") (lambda () (interactive) (dired "~/Documents/")))
    (define-key louk/dired-nav-map (kbd "p") (lambda () (interactive) (dired "~/Pictures/")))
    (define-key louk/dired-nav-map (kbd "M") (lambda () (interactive) (dired "~/Music/")))
    (define-key louk/dired-nav-map (kbd "v") (lambda () (interactive) (dired "~/Videos/")))
    (define-key louk/dired-nav-map (kbd "m") (lambda () (interactive) (dired "/run/media/louk/")))
    (define-key louk/dired-nav-map (kbd "C") (lambda () (interactive) (dired "~/.config/")))
    (define-key louk/dired-nav-map (kbd "E") (lambda () (interactive) (dired "~/.emacs.d/")))
    (define-key louk/dired-nav-map (kbd "!") (lambda () (interactive) (dired "~/dotfiles/")))
    #+end_src

*** Dired defaults
    #+begin_src emacs-lisp
    (setq dired-dwim-target t)
    (setq dired-listing-switches "-alh") ;; add human-readable sizes

    (add-hook 'dired-mode-hook
	      (lambda ()
		(dired-hide-details-mode)
		(dired-omit-mode)))

    (remove-hook 'dired-mode-hook 'ranger-set-dired-key) ;; this stupid bug...
    #+end_src 
    
*** Image dired
    #+begin_src emacs-lisp
      (setq image-dired-thumb-width 250)
      (setq image-dired-thumbs-per-row 4)
      (setq image-dired-external-viewer "sxiv")
    #+end_src
    
*** Dired keybindings
Changing some default keybindings
    #+begin_src emacs-lisp
    (define-key dired-mode-map "G" 'revert-buffer)
    (define-key dired-mode-map "g" 'louk/dired-nav-map)
    (define-key dired-mode-map "z" 'dired-omit-mode)
    (define-key dired-mode-map (kbd "C-x M-.") 'compose-attach-marked-files)
    (define-key dired-mode-map (kbd "M-<") 'dired-goto-first-file)
    (define-key dired-mode-map (kbd "M->") 'dired-goto-last-file)
    #+end_src
    
*** Dired evil bindings

   Loading the whole evil-collection proved cumbersome for me, there was some trouble with my custom keybindings (eg. I couldn't use 'r' as a prefix key, even when binding it to nil after loading evil-collection). Might be sth that I did wrong, but anyhow...

   #+begin_src emacs-lisp
   ;; this is from evil-collection with some changes
   (eval-after-load "evil"
     '(progn
	(evil-define-key 'normal dired-mode-map
	  ;; basics
	  "q" 'quit-window
	  ;; basic movement
	  "j" 'dired-next-line
	  "k" 'dired-previous-line
	  "h" 'dired-up-directory
	  "l" 'dired-find-file
	  ">" 'dired-next-dirline
	  "<" 'dired-prev-dirline
	  "gg" 'dired-goto-first-file
	  "G" 'dired-goto-last-file
	  ;; basic functions
	  "A" 'dired-do-find-regexp
	  "B" 'dired-do-byte-compile
	  "C" 'dired-do-copy
	  "D" 'dired-do-delete
	  ;; dired-do-chgrp
	  "H" 'dired-do-hardlink
	  "L" 'dired-do-load
	  "M" 'dired-do-chmod
	  "O" 'dired-do-chown
	  "P" 'dired-do-print
	  "Q" 'dired-do-find-regexp-and-replace
	  "R" 'dired-do-rename
	  "S" 'dired-do-symlink
	  "T" 'dired-do-touch
	  "Z" 'dired-do-compress
	  "c" 'dired-do-compress-to
	  "!" 'dired-do-shell-command
	  "&" 'dired-do-async-shell-command
	  "=" 'dired-diff
	  ;; regexp operations
	  "%" nil ;; prefix
	  "%u" 'dired-upcase
	  "%l" 'dired-downcase
	  "%d" 'dired-flag-files-regexp
	  "%g" 'dired-mark-files-containing-regexp
	  "%m" 'dired-mark-files-regexp
	  "%C" 'dired-do-copy-regexp
	  "%H" 'dired-do-hardlink-regexp
	  "%R" 'dired-do-rename-regexp
	  "%S" 'dired-do-symlink-regexp
	  "%&" 'dired-flag-garbage-files
	  ;; marks & flags
	  "U" 'dired-unmark-all-marks
	  "u" 'dired-unmark
	  "m" 'dired-mark
	  " " 'dired-mark
	  "t" 'dired-toggle-marks
	  "d" 'dired-flag-file-deletion
	  "x" 'dired-do-flagged-delete
	  (kbd "* <delete>") 'dired-unmark-backward
	  (kbd "<delete>") 'dired-unmark-backward
	  "*" nil ;; prefix
	  "**" 'dired-mark-executables
	  "*/" 'dired-mark-directories
	  "*@" 'dired-mark-symlinks
	  "*%" 'dired-mark-files-regexp
	  "*(" 'dired-mark-sexp
	  "*." 'dired-mark-extension
	  "*O" 'dired-mark-omitted
	  "*c" 'dired-change-marks
	  "*s" 'dired-mark-subdir-files
	  "*?" 'dired-unmark-all-files
	  "*!" 'dired-unmark-all-marks
	  ;; encryption-decryption (epa-dired)
	  ";d" 'epa-dired-do-decrypt
	  ";v" 'epa-dired-do-verify
	  ";s" 'epa-dired-do-sign
	  ";e" 'epa-dired-do-encrypt
	  ;; unsorted
	  "z" 'dired-omit-mode
	  "g" 'louk/dired-nav-map
	  "gr" 'revert-buffer
	  "gR" 'dired-do-redisplay
	  "I" 'dired-maybe-insert-subdir
	  "i" 'dired-toggle-read-only
	  "J" 'dired-goto-file
	  "K" 'dired-do-kill-lines
	  "a" 'dired-find-alternate-file
	  "gy" 'dired-show-file-type
	  "Y" 'dired-copy-filename-as-kill
	  "+" 'dired-create-directory
	  (kbd "S-<return>") 'dired-find-file-other-window
	  (kbd "RET") 'dired-find-file
	  (kbd "M-<return>") 'browse-url-of-dired-file
	  "o" 'dired-sort-toggle-or-edit
	  "(" 'dired-hide-details-mode
	  "g?" 'dired-summary
	  "?" 'dired-get-size)

	(add-hook 'dired-mode-hook 'evil-normalize-keymaps)))
   #+end_src
    
*** Dired subtree
    #+begin_src emacs-lisp
    (use-package dired-subtree
      :ensure t
      :after dired
      :config
      (evil-define-key 'normal dired-mode-map (kbd "TAB") 'dired-subtree-toggle))
    #+end_src
*** Peep dired
    Peep dired sounds naughty!
**** Peepy-fied dired functions
     Some functions for a more consistent peeping experience.

     #+begin_src emacs-lisp
     (defun louk/peep-dired-up-directory ()
       "Peep first file when moving up directory."
       (interactive)
       (dired-up-directory)
       (peep-dired-display-file-other-window))

     (defun louk/peep-dired-find-file ()
       "Peep first file when entering a subdirectory. If the selection is a file, just go to the peeped window."
       (interactive)
       (if (file-directory-p (dired-file-name-at-point))
	   (progn
	     (dired-find-file)
	     (peep-dired-display-file-other-window))
	 (other-window 1)))

     (defun louk/peep-dired-prev-dirline ()
       "Peep previous dirline."
       (interactive)
       (dired-prev-dirline 1)
       (peep-dired-display-file-other-window))

     (defun louk/peep-dired-next-dirline ()
       "Peep next dirline."
       (interactive)
       (dired-next-dirline 1)
       (peep-dired-display-file-other-window))

     (defun louk/peep-dired-goto-first-file ()
       "Go to first file line and peep there. Uses `dired-goto-first-file'"
       (interactive)
       (dired-goto-first-file)
       (peep-dired-display-file-other-window))

     (defun louk/peep-dired-goto-last-file ()
       "Go to last file line and peep there. Uses `dired-goto-last-file'"
       (interactive)
       (dired-goto-last-file)
       (peep-dired-display-file-other-window))
     #+end_src 

**** Load Peep
    #+begin_src emacs-lisp
    (use-package peep-dired
      :ensure t
      :after dired-x
      :init
      ;; is this that creates an error? -- Yes, do not use it, or fix it
      ;; (setq peep-dired-cleanup-eagerly t)
      (setq peep-dired-ignored-extensions '("mkv" "mp4" "avi" "mov" "mp3" "wav" "iso"))
      :config
      ;; evil integration
      (eval-after-load "evil"
	'(progn
	   (evil-define-key 'normal peep-dired-mode-map (kbd "<SPC>") 'peep-dired-scroll-page-down
	     (kbd "<C-SPC>") 'peep-dired-scroll-page-up
	     (kbd "<backspace>") 'peep-dired-scroll-page-up
	     (kbd "j") 'peep-dired-next-file
	     (kbd "<down>") 'peep-dired-next-file
	     (kbd "k") 'peep-dired-prev-file
	     (kbd "<up>") 'peep-dired-prev-file
	     (kbd "h") 'louk/peep-dired-up-directory
	     (kbd "<left>") 'louk/peep-dired-up-directory
	     (kbd "l") 'louk/peep-dired-find-file
	     (kbd "<right>") 'louk/peep-dired-find-file
	     (kbd ">") 'louk/peep-dired-next-dirline
	     (kbd "<") 'louk/peep-dired-prev-dirline
	     (kbd "g g") 'louk/peep-dired-goto-first-file
	     (kbd "G") 'louk/peep-dired-goto-last-file)
	   (evil-define-key 'normal dired-mode-map (kbd "p") 'peep-dired)
	   (add-hook 'peep-dired-hook 'evil-normalize-keymaps)))
      :bind
      (:map dired-mode-map
	    ("p" . 'peep-dired)))
    #+end_src

*** Dired hacks
Testing ground
#+begin_src emacs-lisp
(use-package dired-narrow
  :ensure t
  :after dired evil
  :config
  (evil-define-key 'normal dired-mode-map (kbd "f") 'dired-narrow)
  :bind
  (:map dired-mode-map
	("f" . 'dired-narrow)))

(use-package dired-ranger
  :ensure t
  :after dired
  :config
  (eval-after-load "evil"
    '(progn
       (evil-define-key 'normal dired-mode-map
	 "y" nil ;; prefix
	 "yy" 'dired-ranger-copy
	 "yd" 'dired-ranger-move
	 "yp" 'dired-ranger-paste))))
#+end_src

*** Dired rainbow

 Prettier dired
 #+begin_src emacs-lisp
 (use-package dired-rainbow
   :ensure t
   :config
   (progn
     (dired-rainbow-define-chmod directory "#6cb2eb" "d.*")
     (dired-rainbow-define html "#eb5286" ("css" "less" "sass" "scss" "htm" "html" "jhtm" "mht" "eml" "mustache" "xhtml"))
     (dired-rainbow-define xml "#f2d024" ("xml" "xsd" "xsl" "xslt" "wsdl" "bib" "json" "msg" "pgn" "rss" "yaml" "yml" "rdata"))
     (dired-rainbow-define document "#9561e2" ("docm" "doc" "docx" "odb" "odt" "pdb" "pdf" "ps" "rtf" "djvu" "epub" "odp" "ppt" "pptx"))
     (dired-rainbow-define markdown "#ffed4a" ("org" "etx" "info" "markdown" "md" "mkd" "nfo" "pod" "rst" "tex" "textfile" "txt"))
     (dired-rainbow-define database "#6574cd" ("xlsx" "xls" "csv" "accdb" "db" "mdb" "sqlite" "nc"))
     (dired-rainbow-define media "#de751f" ("mp3" "mp4" "MP3" "MP4" "avi" "mpeg" "mpg" "flv" "ogg" "mov" "mid" "midi" "wav" "aiff" "flac"))
     (dired-rainbow-define image "#f66d9b" ("tiff" "tif" "cdr" "gif" "ico" "jpeg" "jpg" "png" "psd" "eps" "svg"))
     (dired-rainbow-define log "#c17d11" ("log"))
     (dired-rainbow-define shell "#f6993f" ("awk" "bash" "bat" "sed" "sh" "zsh" "vim"))
     (dired-rainbow-define interpreted "#38c172" ("py" "ipynb" "rb" "pl" "t" "msql" "mysql" "pgsql" "sql" "r" "clj" "cljs" "scala" "js"))
     (dired-rainbow-define compiled "#4dc0b5" ("asm" "cl" "lisp" "el" "c" "h" "c++" "h++" "hpp" "hxx" "m" "cc" "cs" "cp" "cpp" "go" "f" "for" "ftn" "f90" "f95" "f03" "f08" "s" "rs" "hi" "hs" "pyc" ".java"))
     (dired-rainbow-define executable "#8cc4ff" ("exe" "msi"))
     (dired-rainbow-define compressed "#51d88a" ("7z" "zip" "bz2" "tgz" "txz" "gz" "xz" "z" "Z" "jar" "war" "ear" "rar" "sar" "xpi" "apk" "xz" "tar"))
     (dired-rainbow-define packaged "#faad63" ("deb" "rpm" "apk" "jad" "jar" "cab" "pak" "pk3" "vdf" "vpk" "bsp"))
     (dired-rainbow-define encrypted "#ffed4a" ("gpg" "pgp" "asc" "bfe" "enc" "signature" "sig" "p12" "pem"))
     (dired-rainbow-define fonts "#6cb2eb" ("afm" "fon" "fnt" "pfb" "pfm" "ttf" "otf"))
     (dired-rainbow-define partition "#e3342f" ("dmg" "iso" "bin" "nrg" "qcow" "toast" "vcd" "vmdk" "bak"))
     (dired-rainbow-define vc "#0074d9" ("git" "gitignore" "gitattributes" "gitmodules"))
     (dired-rainbow-define-chmod executable-unix "#38c172" "-.*x.*")
     )) 
 #+end_src

** PDF TOOLS
   #+begin_src emacs-lisp
   (use-package pdf-tools
     :ensure t
     :init
     (pdf-tools-install))
   #+end_src
** DIARY AND CALENDAR
*** Default diary file
    #+begin_src emacs-lisp
    (setq diary-file "~/.personal/diary")
    #+end_src
*** Preferred time format
    #+begin_src emacs-lisp
    (calendar-set-date-style 'european)
    #+end_src
*** Start diary
    #+begin_src emacs-lisp
    (diary)
    #+end_src
** ORG-MODE
*** Ensure org-plus-contrib

    #+begin_src emacs-lisp
    (unless (package-installed-p 'org-plus-contrib)
      (package-refresh-contents)
      (package-install 'org-plus-contrib))
    #+end_src

*** Org-mode misc options

    #+begin_src emacs-lisp
    ;; prettify
    (setq org-hide-leading-stars t)

    ;; src options
    (require 'org-tempo)

    (setq org-src-fontify-natively t)
    (setq org-src-tab-acts-natively t)
    (setq org-confirm-babel-evaluate nil)
    (setq org-edit-src-content-indentation 0)

    ;; export options -- for mail html export (fix it locally!)
;;    (setq org-export-with-toc nil)
  ;;  (setq org-export-with-section-numbers nil)

    ;; links
    (setq org-link-search-must-match-exact-headline nil)
    #+end_src

*** Org-mode capture and agenda

    #+begin_src emacs-lisp
    ;; files
    (setq org-directory "~/.personal")
    (setq org-default-notes-file (concat org-directory "/organizer.org"))

    ;; include diary entries in agenda
    (setq org-agenda-include-diary t)

    ;; TODOs
    (setq org-log-done 'time)
    (setq org-log-into-drawer 'LOGBOOK)
    (setq org-clock-into-drawer t)


    ;; bindings
    (global-set-key (kbd "C-c l") 'org-store-link)
    (global-set-key (kbd "C-c a") 'org-agenda)
    (global-set-key (kbd "C-c c") 'org-capture)
    (global-set-key (kbd "C-c C-x C-z") 'org-resolve-clocks)

    ;; some capture functions from Zamansky's configuration
    (defadvice org-capture-finalize 
	(after delete-capture-frame activate)  
      "Advise capture-finalize to close the frame"  
      (if (equal "capture" (frame-parameter nil 'name))  
	  (delete-frame)))

    (defadvice org-capture-destroy 
	(after delete-capture-frame activate)  
      "Advise capture-destroy to close the frame"  
      (if (equal "capture" (frame-parameter nil 'name))  
	  (delete-frame)))  

    (defun make-capture-frame ()
      "Create a new frame and run org-capture."
      (interactive)
      (make-frame '((name . "capture")))
      (select-frame-by-name "capture")
      (delete-other-windows))
    #+end_src

*** Org-capture templates

    #+begin_src emacs-lisp
    (setq org-capture-templates
	  '(("t" "Todo" entry (file+headline "" "Tasks")
	     "* TODO %?\n  %i\n  %a")

	    ("j" "Journal" entry (file+datetree "journal.org")
	     "* %^{entry title}%^G\n%U\n  %?\n")

	    ("p" "Logs for photographic process")

	    ("pd" "Darkroom log" entry (file+datetree "darkroom-log.org")
	     "* %U :darkroom:%^g\n%?" :clock-in t)

	    ;; ("B" "Web purchase" entry (file+headline "web-stuff.org" "Purchases")
	    ;;  "* ORDERED %^{item desc.}\n\n%x\n\nEst. delivery: %?\n\nOrder placed on: %U")

	    ;; ("l" "Link" entry (file+headline "web-stuff.org" "Links")
	    ;;  "* %x %^g\n %?\n%U")

	    ;; ("b" "Bibliography reference" entry (file "bib-references.org")
	    ;;  "* @%^{.bib entry}: %^{description} %^g\n %^{page(s)} %?\n%U")

	    ;; ("c" "Contact" entry (file "contacts.org")
	    ;;  "* %^{nickname}\n:PROPERTIES:\n:NAME: %^{name}\n:EMAIL: [[%^{email}]]\n:END:")
	    ))
    #+end_src
    
*** Org-contacts
    
    #+begin_src emacs-lisp
    (use-package org-contacts
      :ensure nil
      :after org mu4e
      :custom (org-contacts-files '("~/.personal/contacts.org"))
      :bind  ("C-x M-." . 'org-contacts-view-send-email))
    #+end_src

*** org-msg
    #+begin_src emacs-lisp
    (use-package org-msg
      :ensure t
      :after org mu4e
      :bind
      (:map mu4e-compose-mode-map ("M-c" . 'org-msg-edit-mode)))
    #+end_src

** LATEX

   #+begin_src emacs-lisp
   (setq TeX-parse-self t)
   (setq-default TeX-master nil)

   ;; === run xelatex on save for latex mode
   (defun latex-save-compile ()
     "Compile file after saving in latex mode. Using Xelatex."
     (when (eq major-mode 'latex-mode)
       (when (memq this-command '(save-buffer))
	 (shell-command-to-string (format "xelatex %s" buffer-file-name)))))

   (add-hook 'after-save-hook #'latex-save-compile)
   #+end_src
   
** MU4E
*** mu4e basic setup

    #+begin_src emacs-lisp
    (add-to-list 'load-path "/usr/local/share/emacs/site-lisp/mu4e")
    (require 'mu4e)

    (global-set-key (kbd "C-x m") 'mu4e)

    ;; some interface options
    (setq mu4e-confirm-quit nil) ;; do not confirm quitting
    (setq mail-user-agent 'mu4e-user-agent) ;; make mu4e the default for email
    (setq message-kill-buffer-on-exit t) ;; kill message buffer on exit
    (setq mu4e-index-update-in-background t) ;; do not show me the update process
    (setq mu4e-hide-index-messages t)
    (setq mu4e-headers-include-related nil)
    (setq mu4e-compose-dont-reply-to-self nil)
    (setq mu4e-compose-signature-auto-include nil)
    (setq mu4e-sent-messages-behavior 'sent)
    (setq mu4e-change-filenames-when-moving t)
    (setq mu4e-attachment-dir "~/Downloads")
    (setq mu4e-view-show-addresses t)
    ;; this one does not work out of the box. Emacs needs to be compiled with imagemagick support. Will look into this
    (setq mu4e-show-images t)
    (when (fboundp 'imagemagick-register-types)
      (imagemagick-register-types))

    (add-to-list 'mu4e-view-actions '("ViewInBrowser" . mu4e-action-view-in-browser) t)

    (setq mu4e-user-mail-address-list '("loukas.bass@gmx.com"
					"dakodeon@hotmail.com"
					"freehuggs701@gmail.com"))
    #+end_src

*** mu4e (smtp setup)

    #+begin_src emacs-lisp
    (require 'smtpmail)

    (setq message-send-mail-function 'smtpmail-send-it
	  smtpmail-default-smtp-server "mail.gmx.com"
	  smtpmail-smtp-server "mail.gmx.com"
	  smtpmail-smtp-user "loukas.bass@gmx.com"
	  smtpmail-stream-type 'starttls
	  smtpmail-smtp-service 587
	  smtpmail-debug-info t)
    #+end_src

*** mu4e sync mail

    #+begin_src emacs-lisp
    (setq mu4e-get-mail-command "mbsync -a")
    (setq mu4e-html2text-command "w3m -T text/html")
    (setq mu4e-update-interval nil) ;; do not auto-update, this is done with cronjob
    (setq mu4e-headers-auto-update t)
    #+end_src

*** mu4e directories

    #+begin_src emacs-lisp
    (setq mu4e-maildir (expand-file-name "~/.personal/Mail"))

    ;; default directories
    (setq mu4e-drafts-folder "/loukas.bass/Drafts")
    (setq mu4e-sent-folder "/loukas.bass/Sent")
    (setq mu4e-trash-folder "/loukas.bass/Trash")

    ;; maildirs shortcuts
    (setq mu4e-maildir-shortcuts
	  '( ("/Inbox" . ?i)
	     ("/loukas.bass/Inbox" . ?l)
	     ("/loukas.bass/Sent" . ?s)
	     ("/loukas.bass/Trash" . ?t)
	     ("/loukas.bass/Drafts" . ?D)
	     ("/gmail/Inbox" . ?g)
	     ("/dakodeon/Inbox" . ?d)))
    #+end_src

*** mu4e contexts

    #+begin_src emacs-lisp
    (setq mu4e-contexts
	  `( ,(make-mu4e-context
	       :name "loukas.bass"
	       :match-func (lambda (msg)
			     (when msg
			       (mu4e-message-contact-field-matches msg
								   :to "loukas.bass@gmx.com")))
	       :vars '((smtpmail-smtp-user . "loukas.bass@gmx.com")
		       (smtpmail-default-smtp-server . "mail.gmx.com")
		       (smtpmail-smtp-server . "mail.gmx.com")
		       (user-mail-address . "loukas.bass@gmx.com")
		       (user-full-name . "loukas bass")
		       (mu4e-sent-folder . "/loukas.bass/Sent")
		       (mu4e-drafts-folder . "/loukas.bass/Drafts")
		       (mu4e-trash-folder . "/loukas.bass/Trash")))

	     ,(make-mu4e-context
	       :name "gmail"
	       :match-func (lambda (msg)
			     (when msg
			       (mu4e-message-contact-field-matches msg
								   :to "freehuggs701@gmail.com")))
	       :vars '((smtpmail-smtp-user . "freehuggs701@gmail.com")
		       (smtpmail-default-smtp-server . "smtp.gmail.com")
		       (smtpmail-smtp-server . "smtp.gmail.com")
		       (user-mail-address . "freehuggs701@gmail.com")
		       (user-full-name . "freexon")
		       (mu4e-sent-folder . "/gmail/[Gmail]/Sent Mail")
		       (mu4e-drafts-folder . "/gmail/Drafts")
		       (mu4e-trash-folder . "/gmail/Trash")))

	     ,(make-mu4e-context
	       :name "dakodeon"
	       :match-func (lambda (msg)
			     (when msg
			       (mu4e-message-contact-field-matches msg
								   :to "dakodeon@hotmail.com.com")))
	       :vars '((smtpmail-smtp-user . "dakodeon@hotmail.com")
		       (smtpmail-default-smtp-server . "smtp.office365.com")
		       (smtpmail-smtp-server . "smtp.office365.com")
		       (user-mail-address . "dakodeon@hotmail.com")
		       (user-full-name . "loukas b")
		       (mu4e-sent-folder . "/dakodeon/Sent")
		       (mu4e-drafts-folder . "/dakodeon/Drafts")
		       (mu4e-trash-folder . "/dakodeon/Trash")))))

    (setq mu4e-context-policy 'pick-first)
    #+end_src

*** mu4e open in headers of specific account
   
    #+begin_src emacs-lisp
    (defun mu4e-open-in-headers (account)
      "Open mu4e in account's Inbox"
      (interactive)
      (mu4e~start)
      (if (get-buffer "*mu4e-headers*" )
	  (switch-to-buffer "*mu4e-headers*"))
      (mu4e-headers-search (concat "maildir:/" account "/Inbox")))
    #+end_src

*** mu4e external notifications (for i3blocks)

    #+begin_src emacs-lisp
    (add-hook 'mu4e-index-updated-hook
	      (defun mu4e-signal-i3blocks ()
		(shell-command "pkill -RTMIN+2 i3blocks")))

    (add-hook 'mu4e-view-mode-hook 'mu4e-signal-i3blocks)
    #+end_src

*** Contacts management

Manage contacts with org-contacts

#+begin_src emacs-lisp
(setq mu4e-org-contacts-file "~/.personal/contacts.org")

(add-to-list 'mu4e-headers-actions
	     '("org-contact-add" . mu4e-action-add-org-contact) t)

(add-to-list 'mu4e-view-actions
	     '("org-contact-add" . mu4e-action-add-org-contact) t)
#+end_src

*** Start mu4e

Auto start mu4e on emacs startup

    #+begin_src emacs-lisp
    (mu4e~start)
    (mu4e-update-mail-and-index t)
    #+end_src

** EVIL COLLECTION
   A bunch of evil bindings

   #+begin_src emacs-lisp
   ;;    (use-package evil-collection
   ;;      :after evil
   ;;      :ensure t
   ;;      :config
   ;;      (evil-collection-init))
   ;; ;;     (evil-collection-define-key 'normal 'dired-mode-map "r" nil))

   #+end_src

** EVIL
   
   It's good to have vim's normal-state to move around, change words, search etc, but for a true combination of emacs and vim, I replaced insert-state with emacs-state. The best of two worlds!

   -- Note: there's a bunch of bindings in normal-state beause of the visual-line-mode that I use. I have to get rid of that at some point.

   #+begin_src emacs-lisp
   (use-package evil
     :ensure t
     :init
     (setq evil-move-cursor-back nil)
     (setq evil-want-C-u-scroll t)
     (setq evil-want-fine-undo t)
     (setq evil-normal-state-cursor 'box)
     (setq evil-emacs-state-cursor 'bar)
     (setq evil-replace-state-cursor 'hbar)
     (setq evil-want-integration t)
     (setq evil-want-keybinding nil)
     (setq evil-find-skip-newlines t)
     :config 
     (evil-mode 1)
     (evil-set-initial-state 'Info-mode 'emacs)
     (evil-set-initial-state 'org-capture-mode 'emacs)
     (evil-set-initial-state 'mu4e-compose-mode 'emacs)
     (evil-set-initial-state 'org-msg-mode 'emacs)
     (evil-set-initial-state 'package-menu-mode 'emacs)
     (evil-define-state emacs
       "Emacs used as insert state in evil."
       :tag " <EE> "
       :message "-- EMACS INSERT --"
       :input-method t)
     (defadvice evil-insert-state (around emacs-state-instead-of-insert-state activate) (evil-emacs-state))
     :bind
     (:map evil-normal-state-map
	   ("j" . 'evil-next-visual-line)
	   ("k" . 'evil-previous-visual-line)
	   ("^" . 'evil-beginning-of-visual-line)
	   ("$" . 'evil-end-of-visual-line)
	   ("g ^" . 'evil-beginning-of-line)
	   ("g $" . 'evil-end-of-line)
	   ([down] . 'evil-next-visual-line)
	   ([up] . 'evil-previous-visual-line)
	   (";" . 'evil-repeat-find-char)
	   :map evil-emacs-state-map
	   ([escape] . 'evil-normal-state)
	   :map evil-motion-state-map
	   (":" . 'evil-ex)))

    #+end_src

** CUSTOM FILE SHORTCUTS

   #+begin_src emacs-lisp
   (defun goto-file-or-dir (f)
     "Find the given file. If file is a directory, do helm-find-file there"
     (if (file-directory-p f)
	 (helm-find-files-1 f)
       (if (file-exists-p f)
	   (find-file f))))

   ;; create a prefix
   (define-prefix-command 'z-map)
   (global-set-key (kbd "C-x g") 'z-map)

   (define-key z-map (kbd "E") (lambda () (interactive) (goto-file-or-dir "~/.emacs.d/init.el")))
   (define-key z-map (kbd "e") (lambda () (interactive) (goto-file-or-dir "~/.emacs.d/my-config.org")))
   (define-key z-map (kbd "i") (lambda () (interactive) (goto-file-or-dir "~/.config/i3/i3.conf")))
   (define-key z-map (kbd "r") (lambda () (interactive) (goto-file-or-dir "~/.config/ranger/rc.conf")))
   (define-key z-map (kbd "x") (lambda () (interactive) (goto-file-or-dir "~/.Xresources")))
   (define-key z-map (kbd "z") (lambda () (interactive) (goto-file-or-dir "~/.zshrc")))
   (define-key z-map (kbd "h") (lambda () (interactive) (goto-file-or-dir "~/")))
   (define-key z-map (kbd "P") (lambda () (interactive) (goto-file-or-dir "~/Pictures/")))
   (define-key z-map (kbd "p") (lambda () (interactive) (goto-file-or-dir "~/.personal/")))
   (define-key z-map (kbd "C") (lambda () (interactive) (goto-file-or-dir "~/.config/")))
   (define-key z-map (kbd "D") (lambda () (interactive) (goto-file-or-dir "~/Downloads/")))
   (define-key z-map (kbd "d") (lambda () (interactive) (goto-file-or-dir "~/Documents/")))
   (define-key z-map (kbd "c") (lambda () (interactive) (goto-file-or-dir "~/dotfiles/")))
   (define-key z-map (kbd "S") (lambda () (interactive) (goto-file-or-dir "~/.config/scripts/")))
   #+end_src
