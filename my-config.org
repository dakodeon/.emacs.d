#+TITLE: My Emacs configuration
#+AUTHOR: dakodeon

#+TODO: TODO WORKING | DONE REJECTED

* INTRODUCTION

** Overview

   This document is both my personal configuration for Emacs and the
   documentation for it at the same time, with the use of some org-mode
   magic. That is the ability to include code snippets in the document (the
   blocks defined by the =#+begin_src emacs-lisp= and =#+end_src= tags) and
   then, by calling =org-babel-load-file= from [[file:init.el][my init.el file]], write those
   in a .el file and load this file.

   I decided to write the whole configuration using only =use-package=
   declarations. This gives a cleaner config, with more concise syntax,
   while at the same time keeping track and maintaining all the packages
   that I use. The =:ensure= keyword will fetch a package from the repos if
   it is missing.

   When configuring general emacs options, I use =emacs= as a package name.
   Also note the omission of the =:ensure= keyword on those packages as well
   as on others that are parts of emacs by default, like [[DIRED][dired]] or [[ORG MODE][org]].

** The contents of the init.el file

   This file is normally where emacs reads its configuration from. In a
   configuration like this, however, it does three things:

   1. Sets up the =package= package and the =package-archives=
   2. Bootstraps =use-package=. If it is not installed, it installs it.
   3. Calls =org-babel-load-file= pointing to this file.

** Emacs / Linux / Evil: a retrospective

   This is some kind of journal, concerning the steps that got me into all
   these stuff.
   
   I was introduced to Emacs by [[https://iani.github.io/][Iannis Zannos]], Professor of Computer Music
   in the Audio Visual Arts departemnet of the Ionian University, around
   2011-12. At the time, even the concept of it as a program was alien to
   me. I started using it for some projects for the university, but for the
   time being and for a long time more, I was using it more or less like a
   normal text editor (with some very strange keybindings.)
   
   Around the same time I made the jump to Linux, dual booting Linux Mint
   and Windows 7. I was finally to the point that I was feeling "at home"
   in Linux and, if not for the "necessary evils" of Adobe Photoshop and
   Lightroom, I would not even bother to run Windows.

   One or two years later, I was introduced to the concept of "tiling
   window managers", specifically [[https://i3wm.org/][i3wm]], by watching the content of [[https://lukesmith.xyz/][Luke
   Smith]] on YouTube. This happened at a time that I was very frustrated
   with the mess that a "normal" desktop environment can get into, with all
   those windows one on top of another, with no easy way to manage them,
   all those icons in those messy desktops (although I think that's on
   me...) and the general lack of any real customisation. That, and it also
   looked cool. Let's be honest. Fun aside, it was something that I missed
   and didn't even know that existed.

   What naturally comes next is the concept of "CLI programs" and "vim
   bindings".
   
   Vim bindings... Modal editing... What an interesting concept! Although
   at this point in time I had already made some projects using Emacs and
   the Linux terminal (mostly SSHing to a Raspberry Pi), I felt that there
   is something elegant about modal editing, something that I was missing
   from my experience with the, rather counter-intuitive, Emacs
   keybindings. Having said that, I just couldn't take the step and drop
   Emacs for Vim, and, considering the vim motion keys, I rarely used them.
   Even in i3, I moslty used the arrow keys, like some primitive caveman.

   Well, if you don't have any money and an old laptop that sits in a
   kitchen for way too long, a lot of things can happen, especially things
   involving a glass of water and the keyboard... It was still functional
   as a machine even after that, but my keyboard broke in a very
   inrteresting way: the arrow keys were not functioning correctly any
   more! So I was more or less forced to use those vim keys! That was a
   challenge at the beginning, but after getting used to it, I started
   accidentaly hitting vim keys inside of Emacs, filling the line with h
   and l... And that is the point that I started to consider Evil mode.
   
   After that, there is an open road. Emacs is HUGE, and there is always
   something to learn. Very helpful in this matter was the content put up by [[https://cestlaz.github.io/][Mike
   Zamansky]], which pushed me to start writing my config in org-mode with
   use-package declarations, as well as to dwelve into mu4e configuration,
   and, more recently, the content put up by [[https://protesilaos.com/][Protesilaos Stavrou]], which
   expanded on the aforementioned org-mode/use-package "alliance" and
   helped me with a lot of obscure issues and functionality lurking into
   the dark corners of Emacs.

* THE ACTUAL CONFIGURATION

** EVIL

   Evil mode is the Extensible VI Layer for Emacs. It is the basis of my
   Emacs build, so various keys will be defined having that in mind. I
   still define normal Emacs keys, but not for everything.

   I also use Evil collection. This is a package with preconfigured
   evil-bindings for many emacs packages, like mu4e and org-mode. I dont
   enable evil collection for all packages. For example, I define custom
   bindings for dired, due to some buggy behaviour (for some reason I was
   unable to rebind a key bound by evil collection).

*** Evil collection

     #+begin_src emacs-lisp
     (use-package evil-collection
       :after evil
       :ensure t
       :config
       (evil-collection-init 'mu4e)
       (evil-collection-init 'image-dired)
       (evil-collection-init 'outline)
       (evil-collection-init 'calendar)
       (evil-collection-init 'help)
       (evil-collection-init 'man)
       (evil-collection-init 'package-menu)
       (evil-collection-init 'pdf)
       (evil-collection-init 'tetris)
       (evil-collection-init '2048-game))
     #+end_src

*** Evil mode

    #+begin_src emacs-lisp
    (use-package evil
      :ensure t
      :custom
      (evil-move-cursor-back t)
      (evil-move-beyond-eol nil)
      (evil-respect-visual-line-mode t)
      (evil-want-C-u-scroll nil)
      (evil-want-fine-undo t)
      (evil-normal-state-cursor 'box)
      (evil-emacs-state-cursor 'bar)
      (evil-replace-state-cursor 'hbar)
      (evil-want-integration t)
      (evil-want-keybinding nil)
      :config
      (evil-mode 1)
      (evil-set-initial-state 'Info-mode 'insert)
      (evil-set-initial-state 'org-capture-mode 'insert)
      (evil-set-initial-state 'mu4e-compose-mode 'insert)
      (evil-set-initial-state 'org-msg-mode 'insert)
      (evil-set-initial-state 'special-mode 'insert)
      ;; Use emacs state instead of insert state
      ;; (evil-define-state emacs
      ;;   "Emacs used as insert state in evil."
      ;;   :tag " <EE> "
      ;;   :message "-- EMACS INSERT --"
      ;;   :input-method t)
      ;; (defadvice evil-insert-state
      ;;     (around emacs-state-instead-of-insert-state activate)
      ;;   "Emacs instead of Insert."
      ;;   (evil-emacs-state))
      :bind
      (:map evil-normal-state-map
	    ("g^" . 'evil-first-non-blank)
	    ("C-S-o" . 'evil-jump-forward)
	    ("*" . nil) ;;prefix
	    ("*w" . 'evil-search-word-forward))
      (:map evil-emacs-state-map
	    ([escape] . 'evil-normal-state)))
    #+end_src

*** Some vim-like packages

    Various packages that port vim features to evil.

**** Evil surround

     While using vim, I discovered the beauty of surround. Now this is
     ported here.

     #+begin_src emacs-lisp
     (use-package evil-surround
       :ensure t
       :config
       (global-evil-surround-mode 1))
     #+end_src

**** Evil commentary

     While the defaults of emacs work fairly well with evil, this here will
     provide commenting using motions and operators. Nice!

     #+begin_src emacs-lisp
     (use-package evil-commentary
       :ensure t
       :delight
       :config
       (evil-commentary-mode))
     #+end_src

*** TODO TODO list [1/3]

**** TODO Dired evil collection

     Figure out the bug with dired. I could use the basis of
     evil-collection's bindings and expand upon them.

**** DONE Visual line
     CLOSED: [2020-05-01 Fri 12:32]

     This is not really related to evil mode, but I put it here as it kinda
     messes with evil bindings. In general, when you switch to
     visual-line-mode, emacs reflects this switch on the related functions
     (eg beginning-of-line becomes beginning-of-visual-line and so forth).
     Evil-mode does not do that. One might argue that it should, but this
     made me think about the necessity of running such a mode in the first
     place. Recently I ended up using fill-paragraph more and more, so I
     think I should switch to using fill-mode.

**** TODO Better understnding of evil-ex

     There is a lack of documentation when it comes to the evil-ex command.
     It would be useful to dwelve into this so that I can manipulate it and
     customize it some more.

** GENERAL

   General provides a universal way of binding keys, which integrates both
   define-key and evil-define-key. It also offers a way to immitate vim's
   leader key functionality. It also provides a keyword for use-package
   declarations, which, as it seems, is the only way to define evil keys in
   a graceful manner in use-package.

   I decided not to use it for all my keys, but only for my evil bindings,
   although it would make for a more consistent syntax, because I prefered
   the syntax of the default =:bind= keyword. I might rethink about this.

   One thing that I decided not to use at all is the
   =general-create-definer= that functions essentially as a vim leader key.
   The reason is that I did not need an extra way to define stuff while I
   could eventually do everything that I wanted by defining a prefix command
   and assigning it to the evil-normal keymap. I might have missed some
   crazy-awesome feature of this way of defining, but, up until now, I don't
   feel that I miss anything. This is what the [[POOR MAN'S LEADER KEYS]]
   section later on is all about.

    #+begin_src emacs-lisp
    (use-package general
      :ensure t
      :after evil
      :bind
      ("C-h G" . 'general-describe-keybindings))
    #+end_src

*** TODO TODO list [0/2]

**** TODO General's general usage

     General is a package that can completely replace other key bindings'
     definitions. This has the plus of syntax consistency, but I am not
     convinced to use it e.g instead of the :bind key in use-package. For
     sure the create-definer function is very useful.

**** TODO Local definers

     Figure out a way to bind local definers.

** IMPORTANT LOCATIONS

   Here are some places that I often visit. Finding these files or
   directories will happen via a custom keymap, accessible both globally and
   in dired.

   The list of locations will be stored in a variable and then some
   functions will use this variable to access these locations.

   This idea comes from my [[https://ranger.github.io/][Ranger]] days, also from Luke Smith's approach to
   the same matter.

   #+begin_src emacs-lisp
   (use-package emacs
     :config
     (defvar l/locations
       '((home . "~/")
	 (pictures-dir . "~/Pictures/")
	 (music-dir . "~/Music/")
	 (rebet-dir . "~/Music/Ρεμπέτικα/")
	 (video-dir . "~/Videos/")
	 (documents-dir . "~/Documents/")
	 (downloads-dir . "~/Downloads/")
	 (media-dir . "/media/")
	 (personal-dir . "~/.personal")
	 (dotfiles-dir . "~/.source/dotfiles/")
	 (repos-dir . "~/.source/")
	 (emacs-dir . "~/.emacs.d/")
	 (config-dir . "~/.config/")
	 (scripts-dir . "~/.local/bin/")
	 (webserver-dir . "/var/www/lukesrv/")
	 ;;files
	 (emacs-conf . "~/.emacs.d/my-config.org")
	 (emacs-init . "~/.emacs.d/init.el")
       (i3-conf . "~/.config/i3/i3.conf")
       (ranger-conf . "~/.config/ranger/rc.conf")
       (zshrc . "~/.config/zsh/.zshrc")
       (xresources . "~/.Xresources"))
       "All the useful locations, files and directories.")

     ;; functions for each and every one of them...
     (defun find-home () (interactive) (find-file (cdr (assq 'home l/locations))))
     (defun find-pictures-dir () (interactive) (find-file (cdr (assq 'pictures-dir l/locations))))
     (defun find-music-dir () (interactive) (find-file (cdr (assq 'music-dir l/locations))))
     (defun find-rebet-dir () (interactive) (find-file (cdr (assq 'rebet-dir l/locations))))
     (defun find-video-dir () (interactive) (find-file (cdr (assq 'video-dir l/locations))))
     (defun find-documents-dir () (interactive) (find-file (cdr (assq 'documents-dir l/locations))))
     (defun find-downloads-dir () (interactive) (find-file (cdr (assq 'downloads-dir l/locations))))
     (defun find-media-dir () (interactive) (find-file (cdr (assq 'media-dir l/locations))))
     (defun find-personal-dir () (interactive) (find-file (cdr (assq 'personal-dir l/locations))))
     (defun find-dotfiles-dir () (interactive) (find-file (cdr (assq 'dotfiles-dir l/locations))))
     (defun find-repos-dir () (interactive) (find-file (cdr (assq 'repos-dir l/locations))))
     (defun find-emacs-dir () (interactive) (find-file (cdr (assq 'emacs-dir l/locations))))
     (defun find-config-dir () (interactive) (find-file (cdr (assq 'config-dir l/locations))))
     (defun find-scripts-dir () (interactive) (find-file (cdr (assq 'scripts-dir l/locations))))
     (defun find-webserver-dir () (interactive) (find-file (cdr (assq 'webserver-dir l/locations))))
     (defun find-emacs-conf () (interactive) (find-file (cdr (assq 'emacs-conf l/locations))))
     (defun find-emacs-init () (interactive) (find-file (cdr (assq 'emacs-init l/locations))))
     (defun find-i3-conf () (interactive) (find-file (cdr (assq 'i3-conf l/locations))))
     (defun find-ranger-conf () (interactive) (find-file (cdr (assq 'ranger-conf l/locations))))
     (defun find-zshrc () (interactive) (find-file (cdr (assq 'zshrc l/locations))))
     (defun find-xresources () (interactive) (find-file (cdr (assq 'xresources l/locations))))

     ;; the keymap
     (define-prefix-command 'locations-map)
     :bind
     ("C-x g" . locations-map)
     (:map locations-map
	   ("h" . find-home)
	   ("P" . find-pictures-dir)
	   ("V" . find-video-dir)
	   ("M" . find-music-dir)
	   ("R" . find-rebet-dir)
	   ("d" . find-documents-dir)
	   ("D" . find-downloads-dir)
	   ("m" . find-media-dir)
	   ("p" . find-personal-dir)
	   ("!" . find-dotfiles-dir)
	   ("@" . find-repos-dir)
	   ("E" . find-emacs-dir)
	   ("C" . find-config-dir)
	   ("S" . find-scripts-dir)
	   ("W" . find-webserver-dir)
	   ("e" . find-emacs-conf)
	   ("i" . find-i3-conf)
	   ("z" . find-zshrc)
	   ("X" . find-xresources)))
   #+end_src

*** TODO TODO list [0/1]

**** TODO Universal locations

     This should be ported into a separate file, which will be
     auto-generated by a universal list of locations, so that there is some
     consistency system-wide (eg shell).

** POOR MAN'S LEADER KEYS

   This is my own, rather crude, attempt to immitate vim's leader key
   functionality, just by defining prefix commands and assigning them to the
   evil-normal-state-map.

   I decided not to use any external packages for this task (like [[GENERAL][General]]),
   as I don't want to mess with extra definitions and such. Also, what I
   need is really basic.

   Here are the definitions of the keymaps, they are populated later in the
   document in their relevant parts.

   List of the leader keys:

   1. Main leader key, it will be assigned to =SPC=
   2. Org leader key, it will be assigned to =*= in org-mode only
   3. Other window leader key, it will be assigned to =o= as a part of the
      main leader key (eg. =SPC f= will call =find-file=, while =SPC o f=
      will call =find-file-other-window=)
   4. Leader key for agenda-calendar-diary, bound to the main leader map.

   #+begin_src emacs-lisp
   (use-package emacs
     :config
     (define-prefix-command 'leader)
     (define-prefix-command 'leader-org)
     (define-prefix-command 'otherwin)
     (define-prefix-command 'cal-agenda)

     ;; (eval-after-load "evil"
       ;; (evil-define-key 'normal org-mode-map "*" leader-org))

     :general
     (:keymaps 'org-mode-map :states '(normal visual)
	       "*" 'leader-org)
     (:states '(normal visual)
	      "SPC" 'leader)
     :bind
     (:map leader
	   ("o" . otherwin)
	   ("c" . cal-agenda)
	   ("g" . locations-map)))
   #+end_src

** AUTOCOMPLETE

   I switched to Company!

*** Company Mode

   Possibly a better option than auto-complete...
   Needs some tweaking however.

   #+begin_src emacs-lisp
   (use-package company
     :ensure t
     :delight
     :init
     (add-hook 'after-init-hook 'global-company-mode)
     :bind
     ("C-<tab>" . company-files))
   #+end_src

*** Company Quickhelp

   Company-quickhelp will add a popup window to view a help message.
   #+begin_src emacs-lisp
   (use-package company-quickhelp
     :init
     (setq company-quickhelp-delay 0.2)
     (company-quickhelp-mode))
   #+end_src

*** TODO TODO list [0/1]

**** TODO Configure sources

     While company behaves better than auto-complete, some things need to
     change:
     - In ELISP, I don't get all the candidates for completion, I think
       depending on the context. While this is a cool feature, it is not
       desirable as, for exapmle, the =use-package= declarations use a
       differnt syntax.
     - Completion with words of the buffer is obtrusive.

** NAVIGATION WITH IVY
*** Ivy-mode

     Ivy is a narrowing and completion fraqmework for emacs. I switched to
     it from helm, because it was a lot easier to customize.

     Together with counsel, ivy provides alternatives to emacs commands,
     like switch-buffer, find-file, M-x etc. It also interfaces with some
     external tools, like fzf, ripgrep and wmctrl, which is great.

     I wrote some custom functions for Ivy to improve upon the existing
     functionality of inserting in the minibuffer text from the current
     buffer. However, these were rendered obsolete by a somewhat hidden
     feature of Ivy (ivy-next-history-element), which does exactly that, but
     better. I still keep those, but I will soon [[REJECTED PACKAGES][reject]] them.

    #+begin_src emacs-lisp
    (use-package ivy
      :ensure t
      :delight
      :init
      (setq ivy-use-virtual-buffers t)
      (setq ivy-count-format "(%d/%d) ")
      (setq ivy-use-selectable-prompt t)
      :config
      ;; better word and symbol yanking in the minibuffer
      ;; UPDATE: -- I just learned that M-n calls `ivy-next-history-element', which does exactly what I want,
      ;; it yanks to the minibuffer the symbol or the word at point, or the active region, so...
      (defun l/ivy-yank-word ()
	"Pull word at point from buffer into search string."
	(interactive)
	(let (text)
	  (with-ivy-window
	    (setq text (thing-at-point 'word 'no-properties)))
	  (when text
	    (insert (replace-regexp-in-string
		     "  +" " "
		     (ivy--yank-handle-case-fold text)
		     t t)))))

      (defun l/ivy-yank-symbol ()
	"Pull symbol at point from buffer into search string."
	(interactive)
	(let (text)
	  (with-ivy-window
	    (setq text (thing-at-point 'symbol 'no-properties)))
	  (when text
	    (insert (replace-regexp-in-string
		     "  +" " "
		     (ivy--yank-handle-case-fold text)
		     t t)))))
      :bind
      (:map ivy-minibuffer-map
      ("M-w" . l/ivy-yank-word)
      ("M-s" . l/ivy-yank-symbol)))
    #+end_src
*** Counsel

     Counsel is essentially the frontend of ivy. It packs all the useful
     ivy-enriched commands.

     Some of the functionality I use:

     - counsel-fzf: [[https://github.com/junegunn/fzf][Fzf]] is a fuzzy finder for files. Great tool! I added
       functionality from [[https://protesilaos.com/dotemacs][prot's configuration]] that enables us to switch
       root directory for a search (although I simplified it, as I still
       don't use counsel-rg). I also wrote a wrapper around the default
       function so that I can search for marked text if the region is
       active. I also added a modified version of the counsel-fzf function,
       which returns the result as text. Useful when you want to find a
       file name and use it for something else.
     - cousel-outline: Navigate an org file by searching it's headers. Also
       great! Just for customization's sake, I wrote an action to begin a
       fzf search with selected candidate, inspired by the way Prot handles
       switching from fzf to rg and vice-versa.
     - l/counsel-sufraw (to be renamed): [[https://gitlab.com/surfraw/Surfraw][Surfraw]] is a tool for searching the
       web from the command line. It provides a set of scripts (they are
       called elvi) which correspond each to a search engine (eg. Google,
       DuckDuckGo etc). Although there is already a package that integrates
       surfraw with ivy ([[https://github.com/jws85/counsel-surfraw/blob/master/counsel-surfraw.el][counsel-surfraw]]) I wrote my own, just for practice
       and for the sake of it! I ended up using some code from this package
       though. I also took an extra step (just for the bling!) and took the
       elvi's descriptions and passed them to ivy-rich (see next section).

    #+begin_src emacs-lisp
    (use-package counsel
      :ensure t
      :delight
      :config

      (defun l/counsel-fzf-as-text (&optional prompt dir)
	"Calls a mini version of `counsel-fzf' which returns the full
    path of the candidate as a string. PROMPT, if set is the prompt
    argument. If DIR is set, it is used as the base directory for the
    search, else `default-directory' is used."
	(interactive)
	(let* ((counsel--fzf-dir (if dir (expand-file-name dir)
				   default-directory))
	       (cand (ivy-read (or prompt ">>> ")
			       #'counsel-fzf-function
			       :require-match t
			       :initial-input
			       (if mark-active
				   (buffer-substring-no-properties
				    (region-beginning) (region-end)))
			       :re-builder #'ivy--regex-fuzzy
			       :dynamic-collection t
			       :action nil
			       :caller 'l/counsel-fzf-as-text)))
	  ;; (if (string-match-p counsel--fzf-dir cand)
	  (expand-file-name cand)
	    ;; (expand-file-name (concat counsel--fzf-dir "/" cand)))
	  ))

      (defun l/counsel-fzf ()
	"Wraps around `counsel-fzf' to allow input from marked region."
	(interactive)
	(let (text)
	  (if mark-active
	      (setq text (buffer-substring-no-properties
			  (region-beginning) (region-end))))
	  (counsel-fzf text)))

      ;; based on code by prot
      (defun l/counsel-fzf-dir (arg)
	"Specify root directory for `counsel-fzf'."
	(counsel-fzf ivy-text
		     (read-directory-name
		      (concat (car (split-string counsel-fzf-cmd))
			      " in directory: "))))

      (ivy-add-actions 'counsel-fzf
		       '(("r" l/counsel-fzf-dir "change root directory")))

    ;; from counsel-outline to fzf -- I should split these.
    (defun l/counsel-fzf-from-outline (arg)
      "Search for outline header with fzf."
      (counsel-fzf (car (last (split-string (substring-no-properties
					     (ivy-state-current ivy-last)) "/")))))

    (ivy-add-actions 'counsel-outline
		     '(("f" l/counsel-fzf-from-outline "search with fzf")))

      ;; surfraw frontend
      (defvar l/surfraw-elvi-list
	(mapcar (lambda (x) (split-string x "\t+-- "))
		(seq-remove
		 (lambda (str) (not (string-match-p "--" str)))
		 (split-string (shell-command-to-string "surfraw -elvi") "\n")))
	"An association list of elvi. Used by `l/ivy-surfraw'")

      (defun l/ivy-rich--ivy-surfraw-describe-elvi (elvi)
	(car (cdr (assoc elvi l/surfraw-elvi-list))))

      (defun l/ivy-surfraw ()
	"Search the web with surfraw. If region is active, search for that."
	(interactive)
	(let (text)
	  (if mark-active
	      (setq text (buffer-substring-no-properties (mark) (point)))
	    (setq text (read-string "What u wanna search? ")))
	  (ivy-read "Select search engine: "
		    (mapcar (lambda (entry) (car entry)) l/surfraw-elvi-list)
		    :action
		    (lambda (x)
		      (let ((engine (replace-regexp-in-string " +.*$" "" x)))
			(shell-command
			 (concat "surfraw " engine " " (shell-quote-argument text)))))
		    :caller 'l/ivy-surfraw)))
      (ivy-mode 1)
      :bind
      ("M-x" . counsel-M-x)
      ("C-h f" . counsel-describe-function)
      ("C-h v" . counsel-describe-variable)
      ("C-c f" . l/counsel-fzf)
      ("C-c g" . counsel-rg)
      ("C-c b" . l/ivy-surfraw)
      (:map leader-org
	    ("*" . counsel-outline)))
    #+end_src

*** Other functionality

     Here is some extra packages for ivy/counsel/swiper:

***** AMX

      AMX is a rating system for selection candidates. Most rated
      candidates are more likely to appear fisrt when using ivy.

     #+begin_src emacs-lisp
     (use-package amx
       :ensure t
       :after ivy
       :custom
       (amx-backend 'auto)
       (amx-save-file "~/.emacs.d/amx-items")
       :config
       (amx-mode 1))
     #+end_src

***** Ivy-rich

      Ivy-rich provides help strings to be displayed alongside ivy
      candidates. Really useful for some quick reference.

      I added functionality for my ivy-surfraw function.

     #+begin_src emacs-lisp
     (use-package ivy-rich
       :ensure t
       :config
       (plist-put ivy-rich-display-transformers-list
		'l/ivy-surfraw '(:columns
				 ((ivy-rich-candidate (:width 20))
				  (l/ivy-rich--ivy-surfraw-describe-elvi)
				  )))
       (setcdr (assq t ivy-format-functions-alist) #'ivy-format-function-line)
       (ivy-rich-mode 1))
     #+end_src

***** Ivy-posframe

      Ivy-posframe provides custom positioning of the minibuffer
      depending on which function is called.

      The way I set it up is essentially copied from Prot's
      configuration. The default is for the minibuffer to be displayed
      as a box in the center of the frame, but for some functions, like
      swiper for example, it is best to be kept in the traditional
      position.

 #+begin_src emacs-lisp
 (use-package ivy-posframe
   :ensure t
   :delight
   :custom
   (ivy-posframe-display-functions-alist
    '((complete-symbol . ivy-posframe-display-at-point)
      (counsel-describe-function . nil)
      (counsel-describe-variable . nil)
      (swiper . nil)
      (swiper-isearch . nil)
      (t . ivy-posframe-display-at-frame-center)))
   :config
   (ivy-posframe-mode 1))
     #+end_src

*** TODO TODO list [0/6]

**** TODO Swiper

     I haven't touch this yet, but I should. It is very useful.

**** TODO Pack l/ivy-surfraw

     The code revolving around this function could be separated from the
     config. I am not sure yet, but it could be it's own package.

**** TODO Configure ivy-posframe

     Posframe allows for every ivy frame to be positioned differently. I
     should standardize which frames I want to be in the classical position
     on the bottom of the frame and which I want popping up. Additionally, I
     should work out what happens with a smaller emacs frame (fix dimensions
     etc)

**** TODO Configure counsel-rg

     Counsel-rg is great for searching text in a bunch of files. I should
     configure it a bit more (check out prot's dotfiles).

**** TODO Configure counsel-wmctrl

     This is a very useful tool. It allows to focus on a different program
     by choosing it from an ivy list. I should expand on this functionality.
     Actually, this could be implemented system-wise, with dmenu
     (off-topic).

**** TODO Configure occur

     Again, check prot's dotfiles to configure what happens with the occur
     buffer from ivy candidates.

** DIRED

   Dired, the DIRectory EDitor, is the default file manager inside emacs. It
   uses ls with ls switches to generate an editable buffer of files lists,
   in which you can do whatever you would normally do in any file manager,
   and maybe more.

   I customized dired up to the point that I am very happy with the workflow
   achieved. This is a really long config, so I guess it is best to document
   it along the way.

*** Defaults

    Here I define some defaults for dired. These include the default ls
    switches that generate the dired buffer, the use of dwim (do what I
    mean) while copying and moving (meaning that when performing a copy or
    move action the default target is the dired buffer in the other window,
    if existing), also adding hide-details-mode to the hook, to omit
    displaying all the info that the '-l' flag produces, as well as fixing a
    bug caused by a package no longer existent (something like the digital
    equivalent of a ghost limb).

    One drastic change I made to the defaults is the way dired shows up in
    the modeline. Delight does not work for dired, as its modeline output
    changes every time the ls flags change. This clutters the modeline as,
    for example, one flag that I use is '--group-directories-first'... I
    discovered the culprit: it was the function 'dired-sort-set-mode-line'.
    So, I completely redefined the function to output my custom names
    instead (note -- I know I should just advise the function, not
    completely redefine it, but at the time I was not familiar enough with
    advising. I might look into it soon).

   #+begin_src emacs-lisp
   (use-package dired
     :delight ""
     :init
     (setq dired-dwim-target t)
     (setq dired-listing-switches "-Alh --group-directories-first") ;; human-readable sizes, also omit . and .., dirs first
     (setq large-file-warning-threshold nil) ;; disable warnings when opening large files -- messes with openwith
     :config
     ;; This hook seems to be added automatically to my 'custom.el' file
     ;; and breaks dired. I have to find out where it comes from. It was
     ;; a part of the `ranger' package, which I have deleted.
     (remove-hook 'dired-mode-hook 'ranger-set-dired-key)

     (add-hook 'dired-mode-hook 'dired-hide-details-mode) ;; list only filenames

     ;; modeline hack -- should replace this with advice
     (defun dired-sort-set-mode-line ()
       ;; Set mode line display according to dired-actual-switches.
       ;; Mode line display of "by name" or "by date" guarantees the user a
       ;; match with the corresponding regexps.  Non-matching switches are
       ;; shown literally.
       (when (eq major-mode 'dired-mode)
	 (setq mode-name
	       (let (case-fold-search)
		 (cond ((string-match-p
			 (concat (regexp-quote "-Alh --group-directories-first") "\\(\\s-\\|$\\)")
			 dired-actual-switches)
			"")
		       ((string-match-p
			 (concat (regexp-quote "-Alht") "\\(\\s-\\|$\\)")
			 dired-actual-switches)
			"⇓D")
		       ((string-match-p
			 (concat (regexp-quote "-AlhS") "\\(\\s-\\|$\\)")
			 dired-actual-switches)
			"⇓S")
		       ((string-match-p
			 (concat (regexp-quote "-AlhX") "\\(\\s-\\|$\\)")
			 dired-actual-switches)
			"⇓X")
		       (t
			"⇓?"))))
	 (if (not (string-match-p
		   (regexp-quote " --group-directories-first")
		   dired-actual-switches))
	     (setq mode-name (concat mode-name "⋮"))
	   (setq mode-name (replace-regexp-in-string "⋮" "" mode-name)))
	 (force-mode-line-update))))
   #+end_src

*** Some basic customization

    Some tweaks of basic behaviour that I felt were missing:

    - The default behaviour when moving to the beginning / end of the buffer
      is to treat it like a normal buffer, instead I wanted to move to the
      first / last line in the file list. I found these code snippets code
      snippets from a file called [[https://www.emacswiki.org/emacs/dired-extension.el][dired-extension]] that was posted in
      emacswiki.
    - The default behaviour when marking a file is to mark and move forward.
      This makes it really easy to mark a bunch of consecutive files. But
      what about in reverse? Let's define a function to do exactly that!
    - The ability to kill lines of a dired buffer so that you can narrow
      down the files you're working on is very useful. More useful is to be
      able to do it on a selection of files.
    - After I started using emacs as my mail client, I thought it would be
      great to use dired to attach files to an email. Apparently someone
      else also thought about this in [[https://emacs.stackexchange.com/questions/14652/attach-multiple-files-from-the-same-directory-to-an-email-message][this]] question in stackexchange. This
      is the provided function, with the ability to attach all marked files.
      /NOTE: this does not always work as intended, and anyways I don't use
      it as much. It is worth checking out however./

    #+begin_src emacs-lisp
    (use-package emacs
      :config
      ;; go to first / last file line
      (defun dired-goto-first-file ()
	   "Move cursor to first file of dired."
	   (interactive)
	   (goto-char (point-min))
	   (while (not (dired-move-to-filename))
	     (call-interactively 'dired-next-line)))

      (defun dired-goto-last-file ()
	"Move cursor to last file of dired."
	(interactive)
	(goto-char (point-max))
	(while (not (dired-move-to-filename))
	  (call-interactively 'dired-previous-line)))

      ;; mark and move backwards
      (defun l/dired-mark-backwards ()
	"Mark file at point and move backwards."
	(interactive)
	(if (dired-move-to-filename)
	    (progn
	      (dired-mark 1)
	      (dired-previous-line 2))))

      ;; narrow to marked files
      (defun l/dired-narrow-to-marked-files ()
	"Show only marked files in dired buffer."
	(interactive)
	(let ((files (dired-get-marked-files)))
	  (unless (eq (length files) 1)
	    (dired-toggle-marks)
	    (dired-do-kill-lines))))

      ;; attach marked files to email
      (defun compose-attach-marked-files ()
	"Compose mail and attach all the marked files from a dired
    buffer."
	(interactive)
	(let ((files (dired-get-marked-files)))
	  (compose-mail nil nil nil t)
	  (dolist (file files)
	    (if (file-regular-p file)
		(mml-attach-file file
				 (mm-default-file-encoding file)
				 nil "attachment")
	      (message "skipping non-regular file %s" file))))))
    #+end_src

*** Sorting functions

    Although the use of ls switches can be very useful for diferent sorting
    options, dired by default does not provide this kind of functionality.
    Here I define some functions to switch between sorting by name, by date,
    by size and by extension. Also, as toggle functions grouping of
    directories first and reverse order.

    #+begin_src emacs-lisp
    (use-package dired
      :config
      ;; sort by
      (defun l/dired-sort-by (sw)
	"Sort dired buffer by given switches and go to first line. If
    the switches provided are the same with the current switches, do
    nothing"
	(let ((switches dired-actual-switches))
	  (unless (string= sw switches)
	    (dired-sort-other sw)
	    (dired-goto-first-file))))

      ;; callable functions
      ;; by name
      (defun l/dired-sort-by-name ()
	"Sort by name. Calls `l/dired-sort-by'."
	(interactive)
	(l/dired-sort-by "-Alh"))

      ;; by date
      (defun l/dired-sort-by-date ()
	"Sort by date. Calls `l/dired-sort-by'."
	(interactive)
	(l/dired-sort-by "-Alht"))

      ;; by size
      (defun l/dired-sort-by-size ()
	"Sort by size. Calls `l/dired-sort-by'."
	(interactive)
	(l/dired-sort-by "-AlhS"))

      ;; by extension
      (defun l/dired-sort-by-ext ()
	"Sort by extension. Calls `l/dired-sort-by'."
	(interactive)
	(l/dired-sort-by "-AlhX"))

      ;; toggle directories first
      (defun l/dired-sort-dirs-first ()
	"Toggles grouping directories first."
	(interactive)
	(let ((switches dired-actual-switches))
	  (if (string-match-p (regexp-quote " --group-directories-first") switches)
	      (setq switches (replace-regexp-in-string " --group-directories-first" "" switches))
	    (setq switches (concat switches " --group-directories-first")))
	  (dired-sort-other switches))
	(dired-goto-first-file))

      (defun l/dired-sort-toggle-reverse ()
	"Toggles reverse ordering in dired buffer."
	(interactive)
	(let ((switches dired-actual-switches))
	  (if (string-match-p (regexp-quote " --reverse") switches)
	      (setq switches (replace-regexp-in-string " --reverse" "" switches))
	    (setq switches (concat switches " --reverse")))
	  (dired-sort-other switches))
	(dired-goto-first-file)))
    #+end_src

*** External programs

   Definitions of some "external" functions. These are functions that act on
   files or lists of files using some external tool. Those include:

   - dired-get-size: calls du and outputs the size on the minibuffer. I got
     this from [[https://www.emacswiki.org/emacs/dired-extension.el][this]] post on emacswiki, from the same package called
     dired-extension mentioned previously. I also left the chinese text
     inside! A new addition: show also the number of selected files.
   - l/unmount-drive: if called on a mountpoint, it unmounts the drive
     mounted there. Really simple function, as I rarely use it, and only for
     this, quickly unmount a drive if I am already there.
   - l/atool-pack and unpack: atool is a script for managing file archives.
     I tried the existing [[https://github.com/HKey/dired-atool][dired-atool]] package from github, but I didn't like
     it, so I wrote my own functions with modified code from this project. I
     prefered something simpler and with nice output.
   - l/get-subtitles: uses sublime, a command-line tool to download
     subtitles written in python. Although the implementation is mine, I got
     some basic ideas from [[http://ergoemacs.org/emacs/elisp_call_shell_command.html][this post about 'start-process']] on ergoemacs and
     [[https://stackoverflow.com/questions/17075920/passing-list-to-rest-args?rq=1][this one about 'apply']] on stackoverflow.
   - l/change-desktop-background: uses my wallset script to set the
     wallpaper. Some options should be added to position the image as well
     as selecting from all images in a directory with sxiv.

   #+begin_src emacs-lisp
   (use-package dired
     :config
     ;; get filesize
     (defun dired-get-size ()
       "Get total size of marked files with `du' command.
	If not marked any files, default is current file or directory."
       (interactive)
       (let ((files (dired-get-marked-files)))
	 (with-temp-buffer
	   (apply 'call-process "/usr/bin/du" nil t nil "-sch" files)
	   (message "%s, %s file(s)"
		    (progn
		      (re-search-backward "\\(^[0-9.,]+[A-Za-z]+\\).*\\(total\\|总用量\\)$")
		      (match-string 1))
		    (length files)))))

     ;; unmount drive from mountpoint
     (defun l/unmount-drive ()
       "Unmount selected directories, if they correspond to mountpoints."
       (interactive)
       (let ((dirs (dired-get-marked-files)))
	 (dired-do-shell-command "mountpoint -q ? && sudo umount ? && sudo rmdir ?" nil dirs)
	 (revert-buffer)))

     ;; pack and unpack
     (defun l/atool-pack ()
       "Use the `atool' program to pack some files."
       (interactive)
       (when (eq major-mode 'dired-mode)
	 (let ((files (dired-get-marked-files t))
	       (archive (expand-file-name
			 (read-file-name "Pack files as:" nil nil nil)))
	       (process-connection-type nil))
	   (if (get-buffer "*atool-pack*")
	       (kill-buffer "*atool-pack*"))
	   (apply 'start-process
		  (append (list "atool-pack" "*atool-pack*" "atool" "--explain" archive "-a") files))
	   (switch-to-buffer-other-window "*atool-pack*")
	   (special-mode))))

     (defun l/atool-unpack ()
       "Use the `atool' program to unpack some archives."
       (interactive)
       (when (eq major-mode 'dired-mode)
	 (let ((files (dired-get-marked-files t))
	       (dest (expand-file-name
		      (read-directory-name "Unpack files to:"
					   (dired-dwim-target-directory) nil nil)))
	       (process-connection-type nil))
	   (if (get-buffer "*atool-unpack*")
	       (kill-buffer "*atool-unpack*"))
	   (if (not (file-directory-p dest))
	       (make-directory dest))
	   (apply 'start-process
		  (append (list "atool-unpack" "*atool-unpack*" "atool" "--explain" "-X" dest) files))
	   (switch-to-buffer-other-window "*atool-unpack*")
	   (special-mode))))

     ;; get subtitles
     (defun l/get-subtitles ()
       "Get subtitles for marked files while in a dired buffer. Depends on subliminal, so it has to be on your system."
       (interactive)
       (when (eq major-mode 'dired-mode)
	 (let* ((lang-list '("en" "gr"))
		(lang (completing-read "Select language: " lang-list nil t))
		(files (dired-get-marked-files))
		(process-connection-type nil))
	   (if (get-buffer "*get-subtitles*")
	       (kill-buffer "*get-subtitles*"))
	   (apply 'start-process
		  (append (list "get-subtitles" "*get-subtitles*" "subliminal" "download" "-l" lang) files))
	   (switch-to-buffer-other-window "*get-subtitles*")
	   (special-mode))))

     ;; change desktop background
     ;; (defun l/change-desktop-background ()
       ;; "Change the desktop background using feh."
       ;; (interactive)
       ;; (let ((fit-type (completing-read "Select fit: " '("scale" "center" "fill" "max") nil t))
	     ;; (entry (shell-quote-argument (expand-file-name (dired-file-name-at-point))))
	     ;; (targetfile (shell-quote-argument (expand-file-name "~/.config/.wallpaper.jpg"))))
	 ;; (setq cpcmd (concat "cp " entry " " targetfile))
	 ;; (setq fehcmd (concat "feh --bg-" fit-type " " targetfile))
	 ;; (setq cmd (concat cpcmd " && " fehcmd))
     ;; (shell-command cmd)))

     ;; change desktop background -- I should add options to position the image and select from multiple images
     (defun l/change-desktop-background ()
       "Change desktop background using my custom script, wallset."
       (interactive)
       (shell-command (concat "wallset "
			      (shell-quote-argument
			       (expand-file-name (dired-filename-at-point))))))

     (defun l/view-images ()
       "View images externally with sxiv, using my script, sxivdir"
       (interactive)
       (let ((files (dired-get-marked-files)))
	 (apply 'start-process
		(append (list "sxivdir" nil "sxivdir" "-1")
			files)))))

   (defun l/open-externally ()
     "Use xdg-open to open files from dired"
     (interactive)
     (let ((file (dired-file-name-at-point)))
       (shell-command (concat "xdg-open " (shell-quote-argument (expand-file-name file))))))
   #+end_src

*** Keybindings

    In this section I define all the keybindings for dired. The list is
    long...

    #+begin_src emacs-lisp
    (use-package dired
      :config
      ;; defining separate maps for different sets of functions
      ;; Helps keeping tidier config
      (define-prefix-command 'l/dired-mark-map) ;; will bind to *
      (define-prefix-command 'l/dired-regexp-map) ;; will bind to %
      (define-prefix-command 'l/dired-sorting-map) ;; will bind to o
      (define-prefix-command 'l/dired-my-ext-cmds) ;; will bind to X

      (add-hook 'dired-mode-hook 'evil-normalize-keymaps)

      :general
      (:keymaps 'dired-mode-map :states 'normal
		"q" 'quit-window
		;; basic movement
		"j" 'dired-next-line
		"k" 'dired-previous-line
		"h" 'dired-up-directory
		"l" 'dired-find-file
		">" 'dired-next-dirline
		"<" 'dired-prev-dirline
		"gg" 'dired-goto-first-file
		"G" 'dired-goto-last-file
		;; basic functions
		"A" 'dired-do-find-regexp
		"B" 'dired-do-byte-compile
		"C" 'dired-do-copy
		"D" 'dired-do-delete
		;; dired-do-chgrp
		"H" 'dired-do-hardlink
		"L" 'dired-do-load
		"M" 'dired-do-chmod
		"O" 'dired-do-chown
		"P" 'dired-do-print
		"Q" 'dired-do-find-regexp-and-replace
		"R" 'dired-do-rename
		"S" 'dired-do-symlink
		"T" 'dired-do-touch
		"Z" 'dired-do-compress
		"c" 'dired-do-compress-to
		"!" 'dired-do-shell-command
		"&" 'dired-do-async-shell-command
		"=" 'dired-diff
		;; regexp operations
		"%" 'l/dired-regexp-map ;; prefix
		;; marks & flags
		"U" 'dired-unmark-all-marks
		"u" 'dired-unmark
		"m" 'dired-mark
		"n" 'l/dired-mark-backwards
		"t" 'dired-toggle-marks
		"d" 'dired-flag-file-deletion
		"x" 'dired-do-flagged-delete
		(kbd "<delete>") 'dired-unmark-backward
		"*" 'l/dired-mark-map ;; prefix
		;; encryption-decryption (epa-dired)
		";d" 'epa-dired-do-decrypt
		";v" 'epa-dired-do-verify
		";s" 'epa-dired-do-sign
		";e" 'epa-dired-do-encrypt
		;; unsorted
		"X" 'l/dired-my-ext-cmds
		"gr" 'revert-buffer
		"gR" 'dired-do-redisplay
		"I" 'dired-maybe-insert-subdir
		"i" 'dired-toggle-read-only
		"J" 'dired-goto-file
		"K" 'dired-do-kill-lines
		"a" 'dired-find-alternate-file
		"gy" 'dired-show-file-type
		"Y" 'dired-copy-filename-as-kill
		"+" 'dired-create-directory
		(kbd "S-<return>") 'dired-find-file-other-window
		(kbd "RET") 'dired-find-file
		(kbd "C-<return>") 'l/open-externally
		;; sorting
		"o" 'l/dired-sorting-map ;; prefix -- was dired-sort-toggle-or-edit
		"(" 'dired-hide-details-mode
		"?" 'dired-summary)

      :bind
      (:map leader
	    ("D" . dired))
      (:map otherwin
	    ("D" . dired-other-window))
      (:map dired-mode-map
	    ("G" . revert-buffer)
	    ("g" . l/dired-nav-map)
	    ("C-x M-." . compose-attach-marked-files)
	    ("M-<" . dired-goto-first-file)
	    ("M->" . dired-goto-last-file))
      (:map l/dired-mark-map
	    ("*" . dired-mark-executables)
	    ("/" . dired-mark-directories)
	    ("@" . dired-mark-symlinks)
	    ("%" . dired-mark-files-regexp)
	    ("(" . dired-mark-sexp)
	    ("." . dired-mark-extension)
	    ("O" . dired-mark-omitted)
	    ("c" . dired-change-marks)
	    ("s" . dired-mark-subdir-files)
	    ("?" . dired-unmark-all-files)
	    ("!" . dired-unmark-all-marks)
	    ("f" . l/dired-narrow-to-marked-files)
	    ("<delete>" . dired-unmark-backward))
      (:map l/dired-regexp-map
	    ("u" . dired-upcase)
	    ("l" . dired-downcase)
	    ("d" . dired-flag-files-regexp)
	    ("g" . dired-mark-files-containing-regexp)
	    ("m" . dired-mark-files-regexp)
	    ("C" . dired-do-copy-regexp)
	    ("H" . dired-do-hardlink-regexp)
	    ("R" . dired-do-rename-regexp)
	    ("S" . dired-do-symlink-regexp)
	    ("&" . dired-flag-garbage-files))
      (:map l/dired-sorting-map
	    ("o" . l/dired-sort-by-name)
	    ("d" . l/dired-sort-by-date)
	    ("s" . l/dired-sort-by-size)
	    ("x" . l/dired-sort-by-ext)
	    ("D" . l/dired-sort-dirs-first)
	    ("R" . l/dired-sort-toggle-reverse))
      (:map l/dired-my-ext-cmds
	    ("s" . l/get-subtitles)
	    ("?" . dired-get-size)
	    ("B" . l/change-desktop-background)
	    ("u" . l/unmount-drive)
	    ("zz" . l/atool-pack)
	    ("zx" . l/atool-unpack)))


    #+end_src

*** Dired-x

    Dired-X provides some extra functionality for dired.

    For now, I use it only for the omit-mode that it offers, which hides
    non-interesting files by regexp or by extension.

    However, there are other useful features which I should check, like
    shell command guessing.

    #+begin_src emacs-lisp
    (use-package dired-x
      :delight dired-omit-mode
      :after dired
      :init
      (setq dired-omit-verbose nil)
      :config
      ;; files to be ommited: beginning with one or more dots, beginning with $ (some files that come from Windows), ending with xmp (eg darktable data files), ending with srt, sub (I don't want to see subtitle files)
      (setq dired-omit-files (concat dired-omit-files "\\|^\\..+$\\|^\\$"))
      (setq dired-omit-extensions
	    (append dired-omit-extensions '("xmp" "srt" "sub")))

      (add-hook 'dired-mode-hook 'dired-omit-mode)

      :general
      (:keymaps 'dired-mode-map :states 'normal
		"z" 'dired-omit-mode)
      :bind
      (:map dired-mode-map
	    ("z" . 'dired-omit-mode))
      (:map leader
	    ("d" . dired-jump))
      (:map otherwin
	    ("d" . dired-jump-other-window)))
    #+end_src

*** Wdired

    Wdired (Writable dired) is a way to manipulate the file listing like a
    text file. This means super-easy renaming.

    #+begin_src emacs-lisp
    (use-package wdired
      :after dired)
    #+end_src

*** Image dired

    Image dired provides functionality to view images in emacs. Nothing too
    fancy, just some sane defaults.

    #+begin_src emacs-lisp
    (use-package image-dired
      :after dired
      :init
      (setq image-dired-thumb-width 250)
      (setq image-dired-thumbs-per-row 4)
      (setq image-dired-external-viewer "sxiv"))
    #+end_src

*** Peep dired

    Peep dired is a minor mode for dired which offers a preview of the file
    at point on another window. Very useful. It provides an experience
    similar to file managers like Ranger.

    However, some features where missing imho, also some functions caused
    abnormal behaviour. So, I cloned the project from the [[https://github.com/asok/peep-dired][original repo]],
    tweaked it, added some extra functions and run it... It still needs
    maintenance, some stuff should be reimplemented, but it will do for now.
    My fork can be found [[https://github.com/dakodeon/peep-dired][here]].

    #+begin_src emacs-lisp
    (use-package peep-dired
      :load-path "~/.source/peep-dired"
      :delight (peep-dired " ")
      :after dired
      :init
      (setq peep-dired-cleanup-eagerly t)
      (setq peep-dired-ignored-extensions '("mkv" "mp4" "avi" "mov" "wav" "iso"))
      :config
      ;; custom dired functions customized further for peep. Maybe use advice?
      (defun l/peep-dired-goto-first-file ()
	"Go to first file line and peep there. Uses `dired-goto-first-file'"
	(interactive)
	(dired-goto-first-file)
	(peep-dired-display-file-other-window))

      (defun l/peep-dired-goto-last-file ()
	"Go to last file line and peep there. Uses `dired-goto-last-file'"
	(interactive)
	(dired-goto-last-file)
	(peep-dired-display-file-other-window))

      (defun l/peep-dired-mark-backwards ()
	"Mark and peep backwards."
	(interactive)
	(l/dired-mark-backwards)
	(peep-dired-display-file-other-window))

      (add-hook 'peep-dired-hook 'evil-normalize-keymaps)
  
      :general
      (:keymaps 'peep-dired-mode-map :states 'normal
		"C-j" 'peep-dired-scroll-page-down
		"C-k" 'peep-dired-scroll-page-up
		"j" 'peep-dired-next-file
		"<down>" 'peep-dired-next-file
		"k" 'peep-dired-prev-file
		"<up>" 'peep-dired-prev-file
		"h" 'peep-dired-up-directory
		"<left>" 'peep-dired-up-directory
		"l" 'peep-dired-find-file
		"<right>" 'peep-dired-find-file
		">" 'peep-dired-next-dirline
		"<" 'peep-dired-prev-dirline
		"g g" 'l/peep-dired-goto-first-file
		"G" 'l/peep-dired-goto-last-file
		"C-SPC" 'l/peep-dired-mark-backwards)
      (:keymaps 'dired-mode-map :states 'normal
		"p" 'peep-dired)

      :bind
      (:map dired-mode-map
	    ("p" . 'peep-dired)))

    #+end_src

*** Some extra pieces of functionality

    Here are some packages that offer a little bit of extra functionality.
    Small things really, but they make a better experience.

**** Dired subtree

     This package makes directories open in the same buffer like
     subtrees.

     #+begin_src emacs-lisp
     (use-package dired-subtree
       :ensure t
       :after dired
       :general
       (:keymaps 'dired-mode-map :states 'normal
		 "TAB" 'dired-subtree-toggle))
     #+end_src

**** Dired narrow

     Narrows down what is shown in the dired buffer by filtering
     filenames. Really useful for quickly finding something.

     #+begin_src emacs-lisp
     (use-package dired-narrow
       :ensure t
       :delight (dired-narrow-mode " >⋅<")
       :after dired
       :init
       (setq dired-narrow-exit-when-one-left t)
       :general
       (:keymaps 'dired-mode-map :states 'normal
		 "f" 'dired-narrow)
       :bind
       (:map dired-mode-map
	     ("f" . 'dired-narrow)))
     #+end_src

**** Dired ranger

     Dired-ranger ports some of the functionality from the ranger file
     manager. Specifically it implements the copying/moving mechanism
     and the bookmark mechanism.

     The way it handles copying and moving can be useful from time to
     time. Instead of knowing beforehand where you want to put the
     file, you can perform the 'yank' and then paste it in whichever
     directory you want.

     Bookmarks is also a useful feature for quick navigation. You can
     quickly set and visit a bookmark, while a custom function that I
     wrote, handles moving to the last visited place. Note that these
     bookmarks are not persistent, they will be lost upon exiting
     emacs.

     #+begin_src emacs-lisp
     (use-package dired-ranger
       :ensure t
       :after dired
       :init
       (setq dired-ranger-bookmark-reopen 'always)
       :config
       ;; function to visit previous directory
       (defun l/dired-ranger-bookmark-visit-LRU ()
	 "Go to last visited directory."
	 (interactive)
	 (dired-ranger-bookmark-visit dired-ranger-bookmark-LRU))

       :general
       (:keymaps 'dired-mode-map :states 'normal
		 "y" nil ;; prefix
		 "yy" 'dired-ranger-copy
		 "yP" 'dired-ranger-move
		 "yp" 'dired-ranger-paste
		 "`" nil ;; prefix
		 "``" 'l/dired-ranger-bookmark-visit-LRU
		 "`v" 'dired-ranger-bookmark-visit
		 "`m" 'dired-ranger-bookmark))
     #+end_src

**** Dired rsync

     Rsync functionality for dired. Really useful for BIG files, as it does not freeze emacs while busy. Progress is also shown in the modeline.

 One note though, while trying to copy to a FAT32 device, I discovered that there is some problem concerning the permissions. This has nothing to do with dired or emacs, it is a rsync thing. The workaround is to choose different flags for the rsync command, so I wrote a function to do this.

     #+begin_src emacs-lisp
     (use-package dired-rsync
       :ensure t
       :after dired
       :init
       (setq dired-rsync-unmark-on-completion nil)
       :config
       ;; workaround to rsync into FAT32
       (defun l/dired-rsync-to-FAT32 ()
	 "Change `dired-rsync-options' temporarily to rsync to FAT32 driver."
	 (interactive)
	 (let ((dired-rsync-options "-rDz --info=progress2")
	       (dest (read-file-name "rsync to: " (dired-dwim-target-directory)
			       nil nil nil 'file-directory-p)))
	   (dired-rsync dest)))

       :general
       (:keymaps 'dired-mode-map :states 'normal
		 "rr" 'dired-rsync
		 "rf" 'l/dired-rsync-to-FAT32))
     #+end_src

*** Openwith

    Openwith is used to open files with different applications.

    #+begin_src emacs-lisp
    (use-package openwith
      :ensure t
      :after dired
      :custom
      (openwith-associations
	    '(("\\.pdf\\'" "zathura" (file))
	      ("\\.\\(mp3\\|wav\\|flac\\|wmv\\)\\'" "st -e mpv" (file))
	      ("\\.\\(mp4\\|mkv\\|avi\\|mov\\)\\'" "mpv" (file))
	      ("\\.\\(jpe?g\\|tiff?\\|png\\)\\'" "sxiv" (file))))
      :config
      (openwith-mode))
    #+end_src

*** Some bling!

    This section is all about the looks!

**** Dired rainbow

     Colors the output of dired. Haven't tweaked anything, this is just the
     defaults from the github page.

     #+begin_src emacs-lisp
     (use-package dired-rainbow
       :ensure t
       :after dired
       :config
       (progn
	 (dired-rainbow-define-chmod directory "#6cb2eb" "d.*")
	 (dired-rainbow-define html "#eb5286" ("css" "less" "sass" "scss" "htm" "html" "jhtm" "mht" "eml" "mustache" "xhtml"))
	 (dired-rainbow-define xml "#f2d024" ("xml" "xsd" "xsl" "xslt" "wsdl" "bib" "json" "msg" "pgn" "rss" "yaml" "yml" "rdata"))
	 (dired-rainbow-define document "#9561e2" ("docm" "doc" "docx" "odb" "odt" "pdb" "pdf" "ps" "rtf" "djvu" "epub" "odp" "ppt" "pptx"))
	 (dired-rainbow-define markdown "#ffed4a" ("org" "etx" "info" "markdown" "md" "mkd" "nfo" "pod" "rst" "tex" "textfile" "txt"))
	 (dired-rainbow-define database "#6574cd" ("xlsx" "xls" "csv" "accdb" "db" "mdb" "sqlite" "nc"))
	 (dired-rainbow-define media "#de751f" ("mp3" "mp4" "MP3" "MP4" "avi" "mpeg" "mpg" "flv" "ogg" "mov" "mid" "midi" "wav" "aiff" "flac"))
	 (dired-rainbow-define image "#f66d9b" ("tiff" "tif" "cdr" "gif" "ico" "jpeg" "jpg" "png" "psd" "eps" "svg"))
	 (dired-rainbow-define log "#c17d11" ("log"))
	 (dired-rainbow-define shell "#f6993f" ("awk" "bash" "bat" "sed" "sh" "zsh" "vim"))
	 (dired-rainbow-define interpreted "#38c172" ("py" "ipynb" "rb" "pl" "t" "msql" "mysql" "pgsql" "sql" "r" "clj" "cljs" "scala" "js"))
	 (dired-rainbow-define compiled "#4dc0b5" ("asm" "cl" "lisp" "el" "c" "h" "c++" "h++" "hpp" "hxx" "m" "cc" "cs" "cp" "cpp" "go" "f" "for" "ftn" "f90" "f95" "f03" "f08" "s" "rs" "hi" "hs" "pyc" ".java"))
	 (dired-rainbow-define executable "#8cc4ff" ("exe" "msi"))
	 (dired-rainbow-define compressed "#51d88a" ("7z" "zip" "bz2" "tgz" "txz" "gz" "xz" "z" "Z" "jar" "war" "ear" "rar" "sar" "xpi" "apk" "xz" "tar"))
	 (dired-rainbow-define packaged "#faad63" ("deb" "rpm" "apk" "jad" "jar" "cab" "pak" "pk3" "vdf" "vpk" "bsp"))
	 (dired-rainbow-define encrypted "#ffed4a" ("gpg" "pgp" "asc" "bfe" "enc" "signature" "sig" "p12" "pem"))
	 (dired-rainbow-define fonts "#6cb2eb" ("afm" "fon" "fnt" "pfb" "pfm" "ttf" "otf"))
	 (dired-rainbow-define partition "#e3342f" ("dmg" "iso" "bin" "nrg" "qcow" "toast" "vcd" "vmdk" "bak"))
	 (dired-rainbow-define vc "#0074d9" ("git" "gitignore" "gitattributes" "gitmodules"))
	 (dired-rainbow-define-chmod executable-unix "#38c172" "-.*x.*")
	 ))
     #+end_src

**** Dired icons

     Adds icons in front of file names. Always good to have! Depends on the
     all-the-icons package, which is loaded later in the config.

     #+begin_src emacs-lisp
     (use-package all-the-icons-dired
       :ensure t
       :delight
       :after dired all-the-icons
       :config
       (add-hook 'dired-mode-hook 'all-the-icons-dired-mode))
     #+end_src

**** Cursor and line truncation

     Just make it feel less like a text editor

     #+begin_src emacs-lisp
     (use-package emacs
       :after dired
       :config
       (add-hook 'dired-mode-hook
		 (lambda ()
		   (setq-local cursor-type nil)
		   (setq-local truncate-lines t))))
     #+end_src

*** TODO TODO list [0/2]

**** TODO Fix/organize keybindings [0/3]

     This implementation is a massive improvement, but my keybindings are
     still all over the place.

***** TODO Evil-collection dired bindings

      See [[TODO Dired evil collection][this]] similar concern on evil-collection.

***** TODO More custom keymaps

      One point of improvement could be the definition of custom maps
      for various collections of bindings, for example the sorting
      functions.

***** TODO Keys in the wrong place

      Specifically this: I have bound my custom map for navigation
      under the "g" key. Also, under the "g" key is the command to move
      on the top of the file ("gg"), but it doesn't belong in this map.
      Find a way to fix this.

**** TODO Some more external functions

     Like my mp3-rename-script

** MU4E EMAIL CLIENT

   I use mu4e to manage my emails. mu4e is the emacs front-end for the
   program 'mu' so installing mu on your system brings also mu4e. Depending
   on your system, you might have to build it yourself, e.g from git. Then,
   find the path of mu4e and add it to load-path (in my case it was
   =/usr/local/share/emacs/site-lisp/mu4e=).

*** The layout
**** Parts and components

     Mu4e only manages your emails. You actually need to install a different
     program to download them and store them to your computer. The most
     popular alternatives are [[https://www.offlineimap.org/][offlineimap]] and [[http://isync.sourceforge.net/][isync]] (which provides the
     executable mbsync). I use the latter. Sending email is also provided by
     a different package: the smtp and message packages that are built-in
     within emacs.

     So: the steps to manage and send emails through emacs are:

     1. mbsync downloads the emails
     2. mu updates the maildirs
     3. smtp establishes connection with your email provider
     4. message composes and sends the actual email
     5. mu4e is used as a platform integrating all of the above

     _Disclaimer:_ I do not understand fully all the mechanics involved
     here, so the above explanation might be from over-simplified to
     dead-wrong. However, it works, thanks to all the resources existing on
     the Internet.

     There is separate configuration required for mbsync. It is out of the
     scope of this description, so I will not go into it. There are a lot of
     sample configurations and instructions on the web, as well as a
     well-documented [[https://wiki.archlinux.org/index.php/Isync][archwiki article]]. However, configuring mbsync can be a
     headache. Best of luck!

**** Some info about my config

     Mu4e gives the ability to set an interval on which it's database
     updates. I set this to nil, as I prefer to have a cronjob taking care
     of that. I have set the interval to be 5 minutes. Updating while on
     mu4e happens only manually.

     Another thing to note is that I don't keep all my email info in this
     file. I use a separate file, which is required in the configuration,
     which provides a variable storing a list of all the accounts'
     information that mu4e needs to build te contexts, maildir structure
     etc. This is not about security, I wouldn't store passwords and stuff
     even to this file, it just seems more appropriate not to share all my
     email addresses in a public file. It also makes the config more
     portable, as you can easily implement the same file, the basic
     structure of which can be seen below:

     #+begin_example emacs-lisp
     (defvar l/accounts-info-list
       '(("account-name-1" . ((mail-addr . "my-name@my-provider.com")
			      (smtp-serv-def . "mail.my-provider.com")
			      (smtp-serv . "mail.my-provider.com")
			      (full-name . "my name")
			      (inbox-dir . ("/account-name-1/Inbox" . ?1))
			      (sent-dir . "/account-name-1/Sent")
			      (drafts-dir . "/account-name-1/Drafts")
			      (trash-dir . "/account-name-1/Trash")))
	 ("account-name-2" . ((mail-addr . "my-other-name@my-other-provider.com")
			      (smtp-serv-def . "smtp.my-other-provider.com")
			      (smtp-serv . "smtp.my-other-provider.com")
			      (full-name . "my other name")
			      (inbox-dir . ("/account-name-2/Inbox" . ?2))
			      (sent-dir . "/account-name-2/Sent")
			      (drafts-dir . "/account-name-2/Drafts")
			      (trash-dir . "/account-name-2/Trash")))))

     ;; don't forget to provide the code in the end of the file!
     (provide 'mu4e-sensitive)
     #+end_example

     A little explanation about this format: it is an associative array
     whose car is the account's nickname (i.e the name of the context)
     and whose cdr is again an associative array with key-value pairs
     representing the various options we want to set. So, we have:

     1. mail-addr: the actual email
     2. smtp-serv-def: the value for smtpmail-smtp-default-server.
	Usually the same with the next field
     3. smtp-serv: the value for smtpmail-smtp-server
     4. full-name: the user's full name
     5. inbox-dir: info about the inbox folder. Note that this is again
	an associative array consisting of the actual path and the
	shortcut key for the folder exactly as mu4e expects to read it
     6. sent-dir, drafts-dir, trash-dir: paths for these folders

     Final note, the location of this file should be added to load-path.

*** The actual config
**** SMTP configuration

     SMTP handles the connection with your email provider. It also sets some
     values for the default email account.

     #+begin_src emacs-lisp
     (use-package smtpmail
       :config
       ;; since smtpmail is loaded first we will require here the sensitive file
       (add-to-list 'load-path "~/.personal/personal-scripts")
       (require 'mu4e-sensitive)
       ;; the default value is considered to be the first account on the list
       (let ((first-account (cdr (nth 0 l/accounts-info-list))))
	 (setq smtpmail-smtp-user (cdr (assq 'mail-addr first-account))
	       smtpmail-default-smtp-server (cdr (assq 'smtp-serv-def first-account))
	       smtpmail-smtp-server (cdr (assq 'smtp-serv first-account))))

       ;; these seem to be default everywhere
       (setq smtpmail-stream-type 'starttls
	     smtpmail-smtp-service 587
	     smtpmail-debug-info t))
     #+end_src

**** Message configuration

     Message is the package that does the actual editing of an email
     message. It is configured to use smtpmail to actually send it. It is
     the backend for the mu4e:compose mode.

     #+begin_src emacs-lisp
     (use-package message
       :after smtpmail
       :init
       (setq message-send-mail-function 'smtpmail-send-it)
       (setq message-kill-buffer-on-exit t)
       (setq message-fill-column nil)
       :hook
       (message-mode . visual-line-mode))
     #+end_src

**** Mu4e -- base settings

     The 'main course'. If it goes all together it will be a very big code
     block, so I will break it into several categories.

     Here are the basic settings.

     #+begin_src emacs-lisp
     (use-package mu4e
       :load-path "/usr/local/share/emacs/site-lisp/mu4e"
       :after message
       :custom
       (mu4e-get-mail-command "updatemail") ;; custom script in ~/.local/bin
       (mu4e-maildir (expand-file-name "~/.personal/Mail"))
       (mu4e-org-contacts-file "~/.personal/contacts.org")
       (mu4e-update-interval nil );; cronjob takes care of this
       (mu4e-confirm-quit nil)
       (mu4e-index-update-in-background t)
       (mu4e-hide-index-messages t)
       (mu4e-sent-messages-behavior 'sent)
       (mu4e-change-filenames-when-moving t)
       (mu4e-attachment-dir "~/Downloads")
       (mu4e-html2text-command "w3m -T text/html")
       (mu4e-headers-auto-update t)
       (mu4e-headers-include-related nil)
       (mu4e-headers-visible-columns 60)
       (mu4e-split-view 'vertical)
       (mu4e-view-show-addresses t)
       (mu4e-compose-dont-reply-to-self nil)
       (mu4e-compose-signature-auto-include nil)
       (mu4e-context-policy 'pick-first)
       ;; this one does not work out of the box. Emacs needs to be compiled with
       ;; imagemagick support. Will look into this
       :init
       (setq mu4e-show-images t)
       (when (fboundp 'imagemagick-register-types)
	 (imagemagick-register-types))
       :config
       (setq mail-user-agent 'mu4e-user-agent)
       :hook
       ((mu4e-view-mode mu4e-compose-mode) . visual-line-mode)
       ((mu4e-view-mode mu4e-compose-mode) . emojify-mode)
       ((mu4e-view-mode mu4e-compose-mode) . turn-off-auto-fill)
       :bind
       ("C-x m" . 'mu4e))
     #+end_src

**** Mu4e -- accounts, maildirs and contexts

     In this section, the multiple account structure is established, by
     using the sensitive info file defined earlier. First, the users
     personal email list is built, then the shortcuts for the various
     Inboxes and finally the contexts' definitions.

     Note how portable this is: you can have 2 or 12 email accounts and this
     code will not change. However, also note that only shortcuts for the
     Inboxes are provided. This is to minimize the information stored in the
     info list. Maybe in the future I will come up with a better
     implementation.

     The code is kinda convoluted though... Defining contexts that way was a
     headache, so I am very happy to have figured it out.

     #+begin_src emacs-lisp
     (use-package mu4e
       :config
       ;; building the user's mail address list
       (setq mu4e-user-mail-address-list
	     (mapcar (lambda (entry) (cdr (assq 'mail-addr (cdr entry))))
		     l/accounts-info-list))

       ;; setting up default directories to the first account's directories
       ;; -- just a failsafe, this is normally handled by contexts
       (let ((first-account (cdr (nth 0 l/accounts-info-list))))
	 (setq mu4e-drafts-folder (cdr (assq 'drafts-dir first-account))
	       mu4e-sent-folder (cdr (assq 'sent-dir first-account))
	       mu4e-trash-folder (cdr (assq 'trash-dir first-account))))

       ;; setting up shortcuts for the Inboxes
       (setq mu4e-maildir-shortcuts
	     (mapcar (lambda (entry) (cdr (assq 'inbox-dir (cdr entry))))
		     l/accounts-info-list))

       ;; build contexts
       (cl-loop for entry in l/accounts-info-list do
		(let* ((name (car entry))
		       (info (cdr entry))
		       (mymail (cdr (assq 'mail-addr info)))
		       (fullname (cdr (assq 'full-name info)))
		       (smtpdef (cdr (assq 'smtp-serv-def info)))
		       (smtpserv (cdr (assq 'smtp-serv info)))
		       (mysent (cdr (assq 'sent-dir info)))
		       (mydrafts (cdr (assq 'drafts-dir info)))
		       (mytrash (cdr (assq 'trash-dir info)))
		       (matchfunc `(lambda (msg)
				     (when msg
				       (mu4e-message-contact-field-matches msg :to ,mymail))))
		       (myvars `((smtpmail-smtp-user . ,mymail)
				 (smtpmail-default-smtp-server . ,smtpdef)
				 (smtpmail-smtp-server . ,smtpserv)
				 (user-mail-address . ,mymail)
				 (user-full-name . ,fullname)
				 (mu4e-sent-folder . ,mysent)
				 (mu4e-drafts-folder . ,mydrafts)
				 (mu4e-trash-folder . ,mytrash))))
		  (add-to-list 'mu4e-contexts (make-mu4e-context
					       :name name
					       :match-func matchfunc
					       :vars myvars) t))))
     #+end_src

**** Mu4e -- bookmarks and queries

     In mu4e, when you want to find an email, you perform a search query.
     You rarely go in your inbox folder and start scrolling around. As for
     the queries that you run most of the time, you can define them as
     bookmarks. Bookmarks in mu4e are pre-defined queries, callable with a
     keybinding.

    Mu4e provides some default bookmarks, the most common one to be unread
    messages, but they are not all useful. So I defined my own list:

    1. Unread messages -- by default
    2. Today's messages -- by default
    3. Messages from the last x days, where x is set interactively -- this
       one is based on an example in the manual. I changed some things to
       integrate it with my various contexts.

    There was another query that I wanted to have as a bookmark, but I could
    not, due to some internals of the bookmarks' definition process. This is
    the ability to re-visit the last received message. So, the function that
    perform this specific query is callable from outside the bookmarks'
    scope.

    Another useful feature is to be able to perform a query for unread
    messages globally, meaning outside of mu4e. That way we can quickly jump
    to unread messages directly upon receiving an email. This is useful to
    be implemented system-wise.

    To facilitate definitions of queries that span through all different
    contexts, a variable holding a list of inboxes is also defined here.

    #+begin_src emacs-lisp
    (use-package mu4e
      :config
      ;; TODO - rewrite this variable using my custom list. In the end it will contain inboxes
      (defvar l/mu4e-context-names
	(mapcar (lambda (x) (car x))
		(cl-map 'list (lambda (context)
				(cons (mu4e-context-name context) context))
			mu4e-contexts)))

      ;; get only the last received message
      (defun l/mu4e-fetch-last-received-msg ()
	"Shows the last received message in mu4e"
	(interactive)
	(let* ((query
		(string-trim
		 (format "%s"
			 (mapcar (lambda (x) (concat "maildir:/" x "/Inbox OR "))
				 l/mu4e-context-names)) "(" " OR )")))
	  (mu4e-headers-search
	   (concat "msgid:" (string-trim (shell-command-to-string (concat "mu find -n 1 --fields \"i\" --sortfield=date --reverse " query)) nil "\n")))))

      ;; Asks for how many days' messages to show -- from the manual, edited
      (defun l/mu4e-bookmark-num-days-old-query (days-old)
	(interactive (list (read-number "How many days? " 2)))
	(let ((start-date (subtract-time (current-time) (days-to-time days-old)))
	      (maildirquery (string-trim (format "%s" (mapcar (lambda (x) (concat "maildir:/" x "/Inbox OR ")) l/mu4e-context-names)) "(" " OR )")))
	  (concat "(" maildirquery ") AND date:"
		  (format-time-string "%Y%m%d" start-date))))

      ;; open unread from wherever
      (defun l/mu4e-open-unread ()
	"Open mu4e in unread messages."
	(interactive)
	(mu4e-headers-search "flag:unread AND NOT flag:trashed"))

      ;; bookmarks list
      (setq mu4e-bookmarks
	    `( ,(make-mu4e-bookmark
		 :name "Unread messages"
		 :query "flag:unread AND NOT flag:trashed"
		 :key ?u)
	       ,(make-mu4e-bookmark
		 :name "Today's messages"
		 :query "date:today..now"
		 :key ?t)
	       ,(make-mu4e-bookmark
		 :name "Messages from last [x] days"
		 :query (lambda () (call-interactively 'l/mu4e-bookmark-num-days-old-query))
		 :key ?w)))    ;; TODO: fetch messages of the last x minutes

      ;; keybindings for the functions defined here --maybe move those at the end?
      ;; (define-key leader "m" 'l/mu4e-open-unread)
      :general
      (:states 'normal :keymaps '(mu4e-main-mode-map mu4e-headers-mode-map)
	       "g'" 'l/mu4e-fetch-last-received-msg)
      :bind
      (:map leader
	    ("m" . l/mu4e-open-unread)))
    #+end_src

**** Mu4e -- actions

     Actions are pre-defined actions you can run on a mail message, either
     in headers view, or while visiting it. Mu4e defines some default
     actions, but you have to load them yourself. You can also write your
     own actions, however I haven't done that yet.

     The actions are defined by adding them in the related association list.
     Then, the actions are callable by pressing the actions shortcut ("a")
     and the first letter of the description associated with the action.

     The actions I load for now are:
     - _ViewInBrowser_: opens the message in browser as html
     - _org-contact-add_: adds the message's sender to my org-contacts file
       (for org-contacts see later section.) This action is callable both
       from the headers and from the message views.

     #+begin_src emacs-lisp
     (use-package mu4e
       :config
       (add-to-list 'mu4e-view-actions
		    '("ViewInBrowser" . mu4e-action-view-in-browser) t)
       (add-to-list 'mu4e-view-actions
		    '("org-contacts-add" . mu4e-action-add-org-contact) t)
       (add-to-list 'mu4e-headers-actions
		    '("org-contacts-add" . mu4e-action-add-org-contact) t))


     #+end_src

**** Mu4e -- extra customisation

     Here are some extra pieces of functionality that I put together.

     One is the ability to split the headers view when viewing a message
     according to the current window's dimensions. I have set the default to
     be a vertical split, but, if the window height is larger than the
     window width, then the split will be horizontal. /This is achieved by
     advising the 'mu4e-headers-view-message'/ /function./ -- Not anymore:
     the problem was that 'mu4e-headers-view-message' is called even when
     jumping from one message directly to the next. This caused the advice
     to activate, thus interchanging the split-view value. Instead, I now
     defined an extra function which is called only when opening a message
     from the headers view.

     The other is to update my external mail notifications (I use i3blocks
     and dunst for that) by sending the required signal to i3blocks. This is
     run as a hook after updating the index as well as when viewing a
     message (thus disabling the unread flag).

     All other small pieces of functionality that don't really belong to any
     other section will be put here.

     #+begin_src emacs-lisp
     (use-package mu4e
       :config
       ;; split according to window dimensions

       (defun l/mu4e-headers-init-split-and-view-msg ()
	 "When opening a message from the headers, set the value of
       `mu4e-split-view' according to the headers window dimensions. If the
       width is greater than the height, the split should be vertical, else
       it should be horizontal."
	 (interactive)
	 (if (> (window-pixel-height) (window-pixel-width))
	     (setq mu4e-split-view 'horizontal)
	   (setq mu4e-split-view 'vertical))
	 (mu4e-headers-view-message))

       (evil-define-key 'normal mu4e-headers-mode-map (kbd "RET") 'l/mu4e-headers-init-split-and-view-msg)

       ;; update i3blocks notification when updating manually
       (add-hook 'index-updated-hook
		 (defun mu4e-signal-i3blocks ()
		   (shell-command "pkill -RTMIN+2 i3blocks")))

       ;; also when viewing a message
       (add-hook 'mu4e-view-mode-hook 'mu4e-signal-i3blocks)
       :bind
       (:map mu4e-headers-mode-map
	     ("RET" . l/mu4e-headers-init-split-and-view-msg)))
     #+end_src

** ORG MODE

   Org mode is a note-taking and organizing framework that does much more
   than that. It can evaluate souce code blocks (see this very file), keep
   track of TODO lists, create and calculate datasheets, capture notes on
   the fly, keep an agenda etc... It is really hard to describe all the use
   cases of org-mode.

   Anyhow, this configuration is really, really basic, I haven't even
   scratched the surface: some sensible defaults, the ensurance of
   'org-plus-contrib' for extra functionality, a little bit of capturing
   etc... We 'll see how this goes.

*** Basic configuration

    Defining some defaults. General behaviour etc.

    An important thing here is the ensurance of 'org-plus-contrib'. This
    library is not a part of the main org package, but expands org-mode in a
    lot of useful ways.

   #+begin_src emacs-lisp
   (use-package org
     :delight
     (org-mode "")
     (org-src-mode " SRC")
     :ensure org-plus-contrib
     :custom
     (org-M-RET-may-split-line '((default . nil)))
     (org-directory "~/.perosnal")
     (org-default-notes-file (concat org-directory "/organizer.org"))
     (org-hide-leading-stars t)
     (org-special-ctrl-a/e t)
     (org-link-search-must-match-exact-headline nil)
     (org-src-fontify-natively t)
     (org-src-tab-acts-natively t)
     (org-confirm-babel-evaluate nil)
     (org-edit-src-content-indentation 0)
     (org-src-window-setup 'current-window)
     (org-fontify-whole-block-delimiter-line nil)
     :init
     ;; apparently some packages from org-plus-contrib must be manually
     ;; required
     (require 'org-tempo)
     :config
     (defun l/org-edit-src-code-other-window ()
       "Open code-block for editing in other window"
       (interactive)
       (let ((org-src-window-setup 'other-window))
	 (org-edit-src-code)))
     :general
     (:keymaps 'org-mode-map :states '(normal visual)
	       "^" 'org-beginning-of-line
	       "$" 'org-end-of-line)
     :bind
     ("C-c l" . org-store-link)
     (:map org-mode-map
	   ("RET" . org-return-indent))
     (:map leader-org
	   ("p" . org-set-property)))
   #+end_src

*** Org TODOs

    TODO lists is something org does well. Some basic options defined here,
    like time-logging and behaviour for nested TODO headlines.

    Also, I pasted a function from the info page: this automates the change
    od the TODO state of a header with TODO children.

    All configuration considering clocking and time-management in general
    will be included here as well.

    #+begin_src emacs-lisp
    (use-package org
      :custom
      (org-log-done 'time)
      (org-log-into-drawer 'LOGBOOK)
      (org-clock-into-drawer t)
      (org-enforce-todo-dependencies t)
      (org-enforce-todo-checkbox-dependencies t)
      :config
      ;; This is straight from the info page. I should probably tweak it
      ;; at some point.
      ;; change todo states when all children todos are done
      (defun org-summary-todo (n-done n-not-done)
	"Switch entry to DONE when all subentries are done, to TODO otherwise."
	(let (org-log-done org-log-states)   ; turn off logging
	  (org-todo (if (= n-not-done 0) "DONE" "TODO"))))

      (add-hook 'org-after-todo-statistics-hook 'org-summary-todo)
      :bind
      ("C-c C-x C-z" . org-resolve-clocks))
    #+end_src

*** Org capture

    Org-capture lets you keep notes on the fly in an organized manner, and
    without interrupting your current workflow.

    This is done by pre-defining capture templates, which are then assigned
    to a shortcut key.

    The capture facility uses the 'org-directory' and the
    'org-default-notes-file' to figure out where to store the notes, if not
    specifically stated. These variables are defined in the previous
    section.

    Also, I implemented the idea presented [[https://www.youtube.com/watch?v=gjr9mP01oWE][here]] by Mike Zamansky (apparently
    he got it from somewhere else too, but anyway). It is about creating a
    new frame in org-capture mode and binding it to a keybinding on your
    system. That way you don't have to focus back to emacs if you want to
    take a note, say, while in your browser.

    My note-taking skills are bad at best, so I haven't put much stuff in
    here. I have some defaults that I rarely use, and some templates
    commented out, that I decided to be not useful, but I keep them for
    reference.

    My templates include:

    1. Todo: Specify a TODO headline in the default file, under the headline
       "Tasks". -- from the defaults
    2. Journal: A journal entry in the file "journal.org". I rarely use
       this. -- from the defaults
    3. Darkroom log: My darkroom progress notepad. Also logs time.
    4. Rempetika lyrics: Capture lyrics and save them with info about
       atrist, rhythm etc as properties.
    5. Contacts: Save a contact to "contacts.org"

    #+begin_src emacs-lisp
    (use-package org-capture
      :after org
      :custom
      ;; my capture templates
      (org-capture-templates
	    '(("t" "Todo" entry (file+headline "" "Tasks")
	       "* TODO %?\n  %i\n  %a")

	      ("j" "Journal" entry (file+datetree "journal.org")
	       "* %^{entry title}%^G\n%U\n  %?\n")

	      ("p" "Logs for photographic process")
	      ("pd" "Darkroom log" entry (file+datetree "darkroom-log.org")
	       "* %U :darkroom:%^g\n%?" :clock-in t)

	      ("r" "Rempetika lyrics" entry (file+headline "~/stixoi.org" "Στίχοι ρεμπέτικα")
	       "* %^{ΤΙΤΛΟΣ}\n%^{ΤΡΑΓΟΥΔΙΣΤΗΣ}p%^{ΣΥΝΘΕΤΗΣ}p\n%x")

	      ;; ("B" "Web purchase" entry (file+headline "web-stuff.org" "Purchases")
	      ;;  "* ORDERED %^{item desc.}\n\n%x\n\nEst. delivery: %?\n\nOrder placed on: %U")

	      ;; ("l" "Link" entry (file+headline "web-stuff.org" "Links")
	      ;;  "* %x %^g\n %?\n%U")

	      ;; ("b" "Bibliography reference" entry (file "bib-references.org")
	      ;;  "* @%^{.bib entry}: %^{description} %^g\n %^{page(s)} %?\n%U")

	      ("c" "Contact" entry (file "contacts.org")
	       "* %^{NICKNAME}\n%^{EMAIL}p\n:END:")))
      :config
      ;; Functions used in creating capture frame -- credits to Mike Zamansky
      (defadvice org-capture-finalize
	  (after delete-capture-frame activate)
	"Advise capture-finalize to close the frame"
	(if (equal "capture" (frame-parameter nil 'name))
	    (delete-frame)))

      (defadvice org-capture-destroy
	  (after delete-capture-frame activate)
	"Advise capture-destroy to close the frame"
	(if (equal "capture" (frame-parameter nil 'name))
	    (delete-frame)))

      (defun make-capture-frame ()
	"Create a new frame and run org-capture."
	(interactive)
	(make-frame '((name . "capture")))
	(select-frame-by-name "capture")
	(delete-other-windows))
      :bind
      ("C-c c" . org-capture))
    #+end_src

*** Org agenda

    Org agenda is what it says on the lid... It offers an overview of todos,
    appointments etc from your files in 'org-directory'. Of course, what you
    see is fully customizable. It also offers integration with the diary
    (see next section).

    #+begin_src emacs-lisp
    (use-package org-agenda
      :after org
      :custom
      (org-agenda-include-diary t)
      (org-agenda-start-on-weekday nil)
      (org-agenda-start-day "-3d")
      (org-agenda-span 10)
      :bind
      ("C-c a" . org-agenda)
      (:map cal-agenda
	    ("a" . org-agenda)))
    #+end_src

*** Other tools

    Some other tools that I use, or don't use...

**** Org contacts

     This package works in tandem with mu4e. It stores contacts in a
     contacts file, and offers some functionality on this file (like
     send mail to contact).

     #+begin_src emacs-lisp
     (use-package org-contacts
       :after org
       :custom
       (org-contacts-files '("~/.personal/contacts.org"))
       :bind ("C-x M-." . org-contacts-view-send-email))
     #+end_src

**** Org msg

     Org-msg is a package that is supposed to offer better integration
     of org-mode while composing an email message, so that you can send
     a correctly formatted html email. It is very interesting, but it
     never worked correctly for me, so I will keep it disabled.

     #+begin_src emacs-lisp
     (use-package org-msg
       :ensure t
       :disabled t
       :after org mu4e
       :bind
       (:map mu4e-compose-mode-map ("M-c" . org-msg-edit-mode)))
     #+end_src

*** My extensions

    Some pieces of functionality for org-mode that I put together.

**** Mark header
 
     This proves useful sometimes.

     #+begin_src emacs-lisp
     (use-package emacs
       :after org
       :config
       (defun l/org-mark-header ()
	 "Goes back to the current header and marks it, without leading stars or
     trailing elipses."
	 (interactive)
	 (outline-back-to-heading)
	 (org-beginning-of-line)
	 (push-mark (point) nil t)
	 (org-end-of-line))
       :bind
       (:map leader-org
	     ("<" . l/org-mark-header)))

     #+end_src

**** Org babel load this file

     #+begin_src emacs-lisp
     (use-package emacs
       :after org
       :config
       (defun l/org-babel-load-this-file ()
	 "Run `org-babel-load-file' on the current file"
	 (interactive)
	 (org-babel-load-file (buffer-file-name)))
       :bind
       (:map leader-org
	     ("Bl" . l/org-babel-load-this-file)))
     #+end_src
 
** CALENDAR AND DIARY

   This one can work very well alongside the agenda. Only some basic
   configuration and tweaking.

   #+begin_src emacs-lisp
   (use-package calendar
     :ensure diary-lib
     :custom
     (diary-file "~/.personal/diary")
     (calendar-view-diary-initially-flag t)
     (calendar-mark-diary-entries-flag t)
     :init
     (calendar-set-date-style 'european)
     (add-to-list 'auto-mode-alist
		  `(,(expand-file-name diary-file) . diary-mode))
     :config
     (setq diary-number-of-entries 7)
     ;; (add-hook 'after-init-hook 'diary)
     ;; (add-to-list after-make-frame-functions 'diary)
     :bind
     ("C-x c c" . calendar)
     ("C-x c d" . diary)
     (:map cal-agenda
	   ("c" . calendar)
	   ("d" . diary)))
   #+end_src

*** TODO TODO list [0/5]

**** TODO Appointments

     There are these functions like 'appt-add' etc. Check them out!

**** TODO External notifications

     I really like having these external notifications with dunst. Use
     dunst to display notifications about appointments, maybe setup
     reminders etc.

**** TODO Better handling of the diary file

     I should learn the mechanisms of addig sth to the diary instead of
     going and editing the file manually.

**** TODO Archiving?

     Maybe archive old entries?

**** TODO Integrate with org-agenda

     Easier said than done, coz I should first be familiar with
     org-agenda itself...

** REBET

   Manage my rebetiko collection.

   #+begin_src emacs-lisp
   (use-package rebet
     :load-path "~/.source/rebet"
     :after counsel org dired
     :demand
     :config
     (setq rebet-dirs-list `(,rebet-default-dir "~/Downloads/youtube-downloads"))
     :general
     (:keymaps 'dired-mode-map :states 'normal
	       "##" 'rebet-dired-tags
	       "#*" 'rebet-dired-tag-to-all)
     :bind
     (:map leader-org
	   ("#<" . rebet-tags-to-props)
	   ("#>" . rebet-props-to-tags)
	   ("##" . rebet-tags-to-props-and-back)))
   #+end_src

** ID3-MODE

   Really interesting package, if I was able to understand it, I would
   definitely use it in my rebet package... For now, it is really useful
   for peep, as it displays the mp3 file as a list of ID3 tags!

   #+begin_src emacs-lisp
   (use-package id3
     :load-path "~/.source/id3.el"
     :init
     (setq auto-mode-alist (cons '("\\.mp3" . id3-mode) auto-mode-alist)))
   #+end_src

** SUBTITLE EDITOR

   #+begin_src emacs-lisp
   (use-package subed
     :load-path "~/.source/subed/subed"
     :defer 1
     :disabled
     :config

     (defun l/subed-mpv-frame-step ()
       "Do a frame step in mpv instance (subed mode)."
       (interactive)
       (subed-mpv--client-send `(frame-step)))

     (defun l/subed-mpv-frame-back-step ()
       "Do a frame back step in mpv instance (subed mode)."
       (interactive)
       (subed-mpv--client-send `(frame-back-step)))

     (defun l/subed-mpv-seek ()
       "Move playback position 1 sec forward relative to current position."
       (interactive)
       (subed-mpv-seek 1000))

     (defun l/subed-mpv-seek-back ()
       "Move playback position 1 sec backwards relative to current position."
       (interactive)
       (subed-mpv-seek -1000))

     (defun l/subed-insert-subtitle-at-pos ()
       "Insert a new subtitle at player position."
       (interactive)
       (subed-srt--append-subtitle 0 subed-mpv-playback-position)
       (subed-regenerate-ids))

     :general
     (:states 'normal :keymaps 'subed-mode-map
	      "." 'subed-mpv-toggle-pause
	      "C-." 'l/subed-mpv-frame-step
	      "C-," 'l/subed-mpv-frame-back-step
	      "C-k" 'subed-backward-subtitle-text
	      "C-j" 'subed-forward-subtitle-text
	      "SPC I" 'subed-insert-subtitle
	      "SPC i" 'l/subed-insert-subtitle-at-pos
	      "SPC a" 'subed-insert-subtitle-adjacent
	      "SPC k" 'subed-kill-subtitle
	      "SPC g a" 'subed-jump-to-subtitle-text
	      "SPC g e" 'subed-jump-to-subtitle-end
	      "SPC g g" 'subed-jump-to-subtitle-id
	      "SPC g t a" 'subed-jump-to-subtitle-time-start
	      "SPC g t e" 'subed-jump-to-subtitle-time-stop
	      "[[" 'subed-decrease-start-time
	      "]]" 'subed-increase-start-time
	      "{{" 'subed-decrease-stop-time
	      "}}" 'subed-increase-stop-time
	      "C-S-h" 'subed-move-subtitle-backward
	      "C-S-l" 'subed-move-subtitle-forward
	      "C-<" 'l/subed-mpv-seek-back
	      "C->" 'l/subed-mpv-seek
     )
   )
   #+end_src

** PROGRAMMING

   Everything related to writing code.

*** Web mode

    Mode to write HTML/CSS/JS/PHP etc

    #+begin_src emacs-lisp
    (use-package web-mode
      :ensure t
      :custom
      (web-mode-enable-auto-quoting t)
      (web-mode-enable-auto-pairing t)
      (web-mode-enable-auto-closing t)
      (web-mode-enable-auto-opening t)
      (web-mode-enable-auto-expanding t)
      (web-mode-enable-current-element-highlight t)
      (web-mode-markup-indent-offset 2)
      (web-mode-css-indent-offset 2)
      :config
      (add-to-list 'auto-mode-alist '("\\.css\\'" . web-mode))
      (add-to-list 'auto-mode-alist '("\\.html\\'" . web-mode))
      (add-to-list 'auto-mode-alist '("\\.phtml\\'" . web-mode))
      (add-to-list 'auto-mode-alist '("\\.tpl\\.php\\'" . web-mode))
      (add-to-list 'auto-mode-alist '("\\.[agj]sp\\'" . web-mode))
      (add-to-list 'auto-mode-alist '("\\.as[cp]x\\'" . web-mode))
      (add-to-list 'auto-mode-alist '("\\.erb\\'" . web-mode))
      (add-to-list 'auto-mode-alist '("\\.mustache\\'" . web-mode))
      (add-to-list 'auto-mode-alist '("\\.djhtml\\'" . web-mode)))
    #+end_src
** LaTeX

   If you do not know what LaTeX is, just skip this section. It's OK.

   The most serious package to manage LaTeX documents, except from the
   defaults, is AUCTeX. It's functionality is not fully explored by me, so
   here I will put just some default configuration taken from the info page.

   I will put as well as a function that I wrote while using the default
   LaTeX package. This allows for the LaTeX compiler (in my case XeLaTeX) to
   run automatically when a LaTeX document is saved. Maybe this particular
   issue is covered by some AUCTeX mechanism that I don't know of.

   #+begin_src emacs-lisp
   (use-package tex
     :ensure auctex
     :init
     (setq TeX-auto-save t
	   TeX-parse-self t)
     (setq-default TeX-master nil)
     :config
     ;; === run xelatex on save for latex mode
     (defun latex-save-compile ()
       "Compile file after saving in latex mode. Using Xelatex."
       (when (eq major-mode 'latex-mode)
	 (when (memq this-command '(save-buffer))
	   (shell-command-to-string (format "xelatex %s" buffer-file-name)))))

     (add-hook 'after-save-hook #'latex-save-compile))
   #+end_src

** TERMINAL EMULATOR

   The lack of a decent terminal emulator inside of emacs always bothered
   me. I wouldn't think to use it as my default terminal emulator, but it
   could be useful at times where switching from emacs to another window
   could interrupt your workflow.

   Well, it seems the search is over: enter vterm!

   Vterm is an emacs port of the libvterm library. Without being 100% sure,
   this is a library implementing all the functionality of a terminal
   emulator, but without being tied to a specific frontend. According to the
   github page, it is still in alpha so some buggy behaviour should be
   expected (they also note that, due to its involvement in some low-level
   operations, if it breaks, it breaks badly -- free interpretation),
   however, after building from source and using it, it works almost
   flawlessly. It even manages terminal applications (like mpv) or even
   ncurses applications (like nmtui).

   A drawback (minor one really) is that one part of the configuration is
   done in your shell's config file (in my case zsh), and it consist mostly
   of some cryptic functions and bits of code that you are supposed to
   copy-paste from their github. These would handle some of the
   functionality, like prompt-tracking. As of yet, I haven't fully
   configured the shell side, mainly because of a lack of understanding. For
   now I can live without prompt-tracking, though.

   Overall, I have a very good experience with it. I will always need a
   terminal emulator outside of emacs, but I will try to use vterm as much
   as I can.

*** Vterm -- basics

    #+begin_src emacs-lisp
    (use-package vterm
      :delight ""
      :load-path "~/.source/emacs-libvterm"
      :init
      (setq vterm-kill-buffer-on-exit t
	    vterm-clear-scrollback t)
      :config
      (evil-set-initial-state 'vterm-mode 'emacs)
      (evil-set-initial-state 'vterm-copy-mode 'normal)
      :bind
      (:map leader
	    ("<RET>" . vterm))
      (:map otherwin
	    ("<RET>" . vterm-other-window)))
    #+end_src

*** TODO TODO list [0/2]
**** TODO Install other vterm packages

     There are two useful tools, multi-vterm, to have multiple terminal
     buffers and easily switch between them, and vterm-toggle, which
     allows toggling between working buffer and spawned terminal. Maybe
     get ideas from the implementations.

**** TODO Bring keybindings

     For now, the normal "emacsy" keybindings are defined later, in my
     custom map. Bring them over, after tidying that too.

** WINDOW MANAGEMENT

   Moving around windows efficiently is very important in emacs. In here I
   define some functions to help with that, also with the rearrangement of
   windows in a frame.

*** Basics -- extra functions and bindings

    #+begin_src emacs-lisp
    (use-package emacs
      :config
      ;; (windmove-default-keybindings) ;; this allows for navigation
      ;; using Shift+arrows. I never use it

      ;; the default behaviour is to create a new window and stay on the
      ;; same. I wanted to always switch to the new window.
      (defun split-window-and-follow-below ()
	"Split and follow container horizontally."
	(interactive)
	(split-window-below)
	(balance-windows)
	(other-window 1))

      (defun split-window-and-follow-right ()
	"Split and follow container vertically."
	(interactive)
	(split-window-right)
	(balance-windows)
	(other-window 1))

      ;; a useful feature introduced here: change from a vertical split to
      ;; a horizontal split. Works only for two windows.
      (defun toggle-window-split ()
	"Switch between horizontal and vertical split when using two windows."
	(interactive)
	(if (= (count-windows) 2)
	    (let* ((this-win-buffer (window-buffer))
		   (next-win-buffer (window-buffer (next-window)))
		   (this-win-edges (window-edges (selected-window)))
		   (next-win-edges (window-edges (next-window)))
		   (this-win-2nd (not (and (<= (car this-win-edges)
					       (car next-win-edges))
					   (<= (cadr this-win-edges)
					       (cadr next-win-edges)))))
		   (splitter
		    (if (= (car this-win-edges)
			   (car (window-edges (next-window))))
			'split-window-horizontally
		      'split-window-vertically)))
	      (delete-other-windows)
	      (let ((first-win (selected-window)))
		(funcall splitter)
		(if this-win-2nd (other-window 1))
		(set-window-buffer (selected-window) this-win-buffer)
		(set-window-buffer (next-window) next-win-buffer)
		(select-window first-win)
		(if this-win-2nd (other-window 1))))))

      (global-set-key (kbd "C-x |") 'toggle-window-split)
      :bind
      ("S-C-<left>" . shrink-window-horizontally) 
      ("S-C-<right>" . enlarge-window-horizontally) 
      ("S-C-<down>" . shrink-window) 
      ("S-C-<up>" . enlarge-window)
      ;; ("C-x 2" . split-window-and-follow-below)
      ;; ("C-x 3" . split-window-and-follow-right)
      ("C-x \\" . window-swap-states))
    #+end_src

*** Ace window

    Ace-window allows to switch between windows using a hint key. Useful
    when working with lots of windows and frames.

    #+begin_src emacs-lisp
    (use-package ace-window
      :ensure t
      :init
      (setq aw-keys '(?h ?j ?k ?l ?a ?s ?d ?f ?g))
      :config
      (ace-window-display-mode 1)
      :bind
      ("C-x S-o" . ace-window)
      ("C-x M-S-o" . ace-swap-window))
    #+end_src

*** Winner mode

    Winner mode allows to restore a previous window configuration.

    #+begin_src emacs-lisp
    (use-package winner
      :config
      (winner-mode 1)
      :bind
      (:map leader
	    ("J" . winner-undo)
	    ("K" . winner-redo)))
    #+end_src
*** Custom bindings

    Here I define my custom bindings, using the "poor man's leader key"
    implementation that I devised.

    #+begin_src emacs-lisp
    (use-package emacs
      :bind
      (:map leader
	    ("h" . windmove-left)
	    ("j" . windmove-down)
	    ("k" . windmove-up)
	    ("l" . windmove-right)
	    ("SPC" . other-window)
	    ("S-SPC" . ace-window)
	    ("S-C-SPC" . ace-swap-window)
	    ("0" . delete-window)
	    ("q" . delete-window)
	    ("Q" . kill-buffer-and-window)
	    ("1" . delete-other-windows)
	    ("s" . split-window-right)
	    ("3" . split-window-right)
	    ("v" . split-window-below)
	    ("2" . split-window-below)
	    ("|" . window-swap-states)
	    ("\\" . toggle-window-split))
      (:map evil-normal-state-map
	    ;; resizing has it's own thing going on...
	    ("M-H" . shrink-window-horizontally)
	    ("M-L" . enlarge-window-horizontally)
	    ("M-J" . shrink-window)
	    ("M-K" . enlarge-window)
	    ("M-+" . balance-windows))) ;; plus is the equal sign while holding shift

    #+end_src

*** TODO TODO list [1/2]

**** TODO Tidy up config

     Some defined functions that I won't use, one large code block that
     should be split for readability etc...

**** DONE Winner mode
     CLOSED: [2020-05-01 Fri 12:42]

     Winner mode can keep a history of window states. It could be really
     useful.

** FILES AND BUFFERS NAVIGATION

   I think of a buffer as a sort of container in emacs. Each opened window
   shows the contents of a buffer, which may or may not be assocciated with
   a file. A buffer not assocciated with a file can be saved as one.

   Here are some basic configuration about the way emacs handles files and
   buffers. It mostly consists of my custom bindings, but any other relevant
   config will be placed here as well.

   #+begin_src emacs-lisp
   (use-package emacs
     :bind
     (:map leader
	   ("f" . find-file)
	   ("b" . switch-to-buffer)
	   ("B" . ibuffer)
	   ("," . (lambda () (interactive)
		    (switch-to-buffer "*scratch*")))
	   ("H" . switch-to-prev-buffer)
	   ("L" . switch-to-next-buffer)
	   ("Z" . kill-current-buffer)
	   ("z" . kill-buffer))
     (:map otherwin
	   ("f" . find-file-other-window)
	   ("b" . switch-to-buffer-other-window)
	   ("B" . ibuffer-other-window)
	   ("," . (lambda () (interactive)
		    (switch-to-buffer-other-window "*scratch*"))))
     :general
     (:states 'normal
	      "ZB" 'kill-current-buffer))
   #+end_src

** TEXT EDITING

   Well, this is the whole point, right? Right???

   You know, sometimes the journey is the most important part...

   Here are some configuration considering text editing and coding in
   emacs.

*** Fill text

    I used to be a fan of 'visual-line-mode' which breaks the text into
    'visual lines', much like a WYSIWYG editor. It also changes the default
    'beginning-of-line' and 'end-of-line' with 'beginning-of-visual-line'
    and 'end-of-visual-line', but this causes more problems than it solves.
    For instance, it messes up some functions that require the normal
    functions' definitions, like org-mode's 'org-special-ctrl-a/e'. Also,
    the configuration of evil-mode gets out of hand, as you have to redefine
    some motions.

    So, I decided to finally drop it and start using 'auto-fill-mode'. This
    mode will automatically break the line after a specified number of
    columns. The default number of columns was 70, I changed it to 75.

    #+begin_src emacs-lisp
    (use-package emacs
      :delight auto-fill-function
      :init
      (setq-default fill-column 75)
      :hook (text-mode . (lambda ()
			   (turn-on-auto-fill)
			   (setq adaptive-fill-mode t))))
    #+end_src

*** Languages and encoding

    Always use UTF-8. Also, set the default input method.

    #+begin_src emacs-lisp
    (use-package emacs
      :config
      (set-language-environment "UTF-8")
      (set-default-coding-systems 'utf-8)
      (setq default-input-method "greek"))
    #+end_src

*** Text navigation/manipulation

    Moving around and changing stuff!

**** Defaults

     Various default options considering copying and pasting, text
     replacement, sentence ending points and general text manipulation.

     #+begin_src emacs-lisp
     (use-package emacs
       :config
       ;; copying and pasting
       (setq select-enable-clipboard t)
       (setq save-interprogram-paste-before-kill t)
       (delete-selection-mode 1)
       ;; sentence ends with dot
       (setq sentence-end-double-space nil)

       ;; some useful disabled functions for text manipulation
       (put 'downcase-region 'disabled nil) ;; binds to 'C-x C-l'
       (put 'upcase-region 'disabled nil) ;; binds to 'C-x C-u'
       (put 'narrow-to-region 'disabled nil) ;; binds to 'C-x n n'
       :bind
       ("C-S-k" . kill-whole-line)
       ("C-x M-e" . eval-buffer)
       ("C-;" . comment-line)
       ("C-M-;" . comment-or-uncomment-region)
       ("M-;" . comment-dwim))
     #+end_src

**** Multiple cursors

     A nice package for quick batch text processing in text chunks where
     repeatedness makes it more practical than using a macro.

     Note: I don't know why, these packages could not load correctly
     until I used the =:demand= keyword in their use-package
     declarations Main package. Apparently they don't work well with
     lazy loading.

***** Main

      #+begin_src emacs-lisp
      (use-package multiple-cursors
	:ensure t
	:demand
	:config
	(define-prefix-command 'mc-leader)
	:bind
	("C-. C-e" . mc/edit-lines)
	("C->" . mc/mark-next-like-this)
	("C-<" . mc/mark-previous-like-this)
	("C-. C-<" . mc/mark-all-like-this)
	("C-<down-mouse-1>" . mc/add-cursor-on-click)
	("C-. C-! 1" . mc/insert-numbers)
	("C-. C-! a" . mc/insert-letters)
	(:map leader
	      ("." . mc-leader))
	(:map mc-leader
	      ("C-e" . mc/edit-lines)
	      ("C-a" . mc/mark-all-like-this)
	      ("!1" . mc/insert-numbers)
	      ("!a" . mc/insert-letters)))

      #+end_src

***** Extras

      Extra functionality for the multiple cursors package.

      #+begin_src emacs-lisp
      (use-package mc-extras
	:ensure t
	:after multiple-cursors
	:demand
	:bind
	(:map mc/keymap
	      ("C-. C-d" . mc/remove-current-cursor)
	      ("C-. C-k" . mc/remove-cursors-at-eol)
	      ("C-. d" . mc/remove-duplicated-cursors)
	      ("C-. C-o" . mc/remove-cursors-on-blank-lines)
	      ("C-. ." . mc/move-to-column)))
      #+end_src

***** Ace-mc

      Adds the functionality to add cursors in specific characters
      conditionally.

      #+begin_src emacs-lisp
      (use-package ace-mc
	:ensure t
	:after mc-extras
	:demand
	:bind
	("C-. )" . ace-mc-add-multiple-cursors)
	("C-. C-)" . ace-mc-add-single-cursor)
	(:map mc-leader
	      (")" . ace-mc-add-multiple-cursors)
	      ("C-)" . ace-mc-add-single-cursor)))
      #+end_src

**** Expand region

     Useful tool. Marks text by semantic units.

     #+begin_src emacs-lisp
     (use-package expand-region
       :ensure t
       :init
       (setq expand-region-subword-enabled t)
       (setq expand-region-skip-whitespace t)
       :bind
       ("C-=" . er/expand-region)
       ("C--" . er/contract-region))
     #+end_src

**** Smartparens

     Smartparens inserts pairs of delimiters, like parentheses and quotes.
     It also provides some useful functions for moving between delimiters.

     #+begin_src emacs-lisp
     (use-package smartparens
       :delight " "
       :init
       (require 'smartparens-config)
       :config
       (smartparens-global-mode)
       (show-smartparens-global-mode)
       :general
       (:states 'normal
		"%" nil
		"%%" 'evil-jump-item
		"%(" 'sp-backward-sexp
		"%)" 'sp-forward-sexp
		"%n" 'sp-next-sexp
		"%p" 'sp-previous-sexp
		"%j" 'sp-down-sexp
		"%k" 'sp-up-sexp
		"%h" 'sp-beginning-of-previous-sexp
		"%l" 'sp-beginning-of-next-sexp
		"%t" 'sp-transpose-sexp
		"%a" 'sp-forward-slurp-sexp
		"%A" 'sp-backward-slurp-sexp
		"%b" 'sp-forward-barf-sexp
		"%B" 'sp-backward-barf-sexp
		"%<" 'sp-split-sexp
		"%>" 'sp-join-sexp
		"%?" 'sp-rewrap-sexp
		)
       :bind
       ("M-s" . sp-splice-sexp)
       ("M-," . sp-split-sexp)
       ("M-." . sp-join-sexp)
       ("M-?" . sp-rewrap-sexp))
     #+end_src
*** Readability

    Helpful visual attributes.

**** Some defaults

     #+begin_src emacs-lisp
     (use-package emacs
       :config
       (blink-cursor-mode -1) ;; don't blink!
       (column-number-mode 1) ;; show me where I am
       (global-hl-line-mode t) ;; show me better!

       ;; put rc files in conf-mode for syntax highlighting
       (add-to-list 'auto-mode-alist '("\\.*rc$" . conf-mode))
       :bind
       ;; fonts size
       ("C-<next>" . text-scale-increase)
       ("C-<prior>" . text-scale-decrease)
       ;; show line numbers
       ("C-x l" . display-line-numbers-mode)
       ;; follow-mode works well for long buffers
       ("C-x M-l" . follow-mode))
     #+end_src

**** Rainbow delimiters

     Different colors for parentheses pairs. Extremely useful for
     (((emacs(((lisp)))))), if you know what I mean! So, we hook it to
     prog-mode.

     #+begin_src emacs-lisp
     (use-package rainbow-delimiters
       :ensure t
       :init
       (add-hook 'prog-mode-hook #'rainbow-delimiters-mode))
     #+end_src

**** Rainbow mode

     This minor mode shows the color of a color representing string. Useful
     in configs.

     #+begin_src emacs-lisp
     (use-package rainbow-mode
       :ensure t
       :delight
       :hook prog-mode conf-mode)
     #+end_src

**** Darkroom mode

     No, it has nothing to do with photography.

     It is a nice mode for reading, though. It centers the text, scales it a
     bit up and removes all visual distractions.

     #+begin_src emacs-lisp
     (use-package darkroom
       :ensure t
       :init
       (setq darkroom-text-scale-increase 0.8)
       :bind
       ("C-x M-D" . darkroom-tentative-mode))
     #+end_src

** BETTER DEFAULTS

   Some interface changes that make more sense. Also, some misc options
   that don't fit anywhere else.

   #+begin_src emacs-lisp
   (use-package emacs
     :init
     (setq inhibit-splash-screen t)	; no splash screen
     (setq initial-scratch-message nil)	; scratch buffer starts empty
     (tool-bar-mode -1)			; no toolbar...
     (menu-bar-mode -1)			; no menu bar...
     (scroll-bar-mode -1)			; and no scrollbar!
     (fset 'yes-or-no-p 'y-or-n-p)		; type "y" instead of "yes"
     (setq custom-file "~/.emacs.d/custom.el") ; use separate custom file
     (load custom-file)			    ; load it too
     (setq backup-directory-alist
	   `(("." . "~/.emacs.d/backups"))) ; all backups in the same place
     (setq backup-by-copying t)		 ; at some point this was important
     (setq help-window-select t)		; always focus help windows
     (setq browse-url-browser-function
	   'browse-url-xdg-open)		; use the default browser
     (setq vc-follow-symlinks t)		; don't ask me to follow symlinks
     :hook
     ((help-mode Custom-mode) . visual-line-mode)
     :bind
     (:map special-event-map
	   ("M-SPC" . ignore)))		; ignore my changing layouts key
   #+end_src

** LOOKS AND FEELS

   As we said before, it's all about the bling. Aesthetic choices wich are
   occasionaly functional.

*** Font

    Load a font, duh!

    #+begin_src emacs-lisp
    (use-package emacs
      :config
      (add-to-list 'default-frame-alist
		   '(font . "Hack-10")
		   ;; '(font . "mononoki Nerd Font-10")
		   ;; '(font . "Iosevka Nerd Font Mono-10")
		   ))
    #+end_src
*** Theme

    Now we look sexy!

    I settled on the doom-emacs themes collection, specifically on the
    dark+ theme, with some tweaks here and there, see next section.

    Other themes that I tried worth mentioning: modus-vivendi, gotham, darktooth

    #+begin_src emacs-lisp
    (use-package doom-themes
      :ensure t
      :config
      (load-theme 'doom-dark+ t))
    #+end_src

*** Modeline

    Doom's modeline looks good!

    #+begin_src emacs-lisp
    (use-package doom-modeline
      :ensure t
      ;; :hook (after-init . doom-modeline-mode)
      :custom
      (doom-modeline-icon t)
      :init
      (doom-modeline-mode 1))
    #+end_src
    
*** Some theming tweaks

    I keep all of these here and not in their packages' sections to have a
    better overview of what I have changed, because these colors are
    dependant on the overall theme.

    #+begin_src emacs-lisp
    (use-package emacs
      :config
      (custom-set-faces
	 '(org-block ((t (:extend nil))))
	 '(org-block-begin-line ((t (:extend nil))))
	 '(outline-3 ((t (:foreground "#D6EBF7"))))
	 '(mode-line ((t (:background "#36648B"))))
	 '(mode-line-inactive ((t (:foreground "#36648B" :background "#121212"))))
	 '(doom-modeline-bar ((t (:background "#27408B"))))
	 '(ivy-posframe ((t (:background "#121212"))))
	 '(sp-show-pair-match-face ((t (:background "#B5CEA8" :foreground "#171F24"))))))
    #+end_src

*** Transparency

    I did not know this existed! I tried it, it's fun, but I had some
    problems with some flickering. I keep it here for reference and
    occasional use.

    #+begin_src emacs-lisp
    (use-package emacs
      :config
      ;; (set-frame-parameter (selected-frame) 'alpha '(90 80))
      )
    #+end_src

*** Delight -- hide info from modeline

    This is mainly used via the keyword in use-package declarations. What it
    does is that it completely removes or changes the name of a mode in the
    modeline.

    #+begin_src emacs-lisp
    (use-package delight
      :ensure t
      :config
      (delight 'undo-tree-mode nil 'undo-tree)
      (delight 'eldoc-mode nil 'eldoc)
      (delight 'visual-line-mode " ⏎" 'simple)
      ;; I do not remember why I did this like that, but here is another way
      (add-hook 'emacs-lisp-mode-hook
		(lambda () (setq mode-name ""))))
    #+end_src

*** All the icons

    Adds the capability to insert icons. Takes icons from various icon sets,
    like fontAwesome, octicons, weathericons etc.

    This is mainly used as a base for the 'all-the-icons-dired' package.

    It has a generally buggy behaviour, with various icons overlapping and
    swapping without reason.

    Note: After the first load, run `all-the-icons-install-fonts'

    #+begin_src emacs-lisp
    (use-package all-the-icons
      :ensure t
      :delight)

    #+end_src

    I am not sure if I need this, I think I tried to fix the aforementioned
    buggy behaviour of all-the-icons, but I don't think it did much.

    #+begin_src emacs-lisp
    ;; (use-package font-lock+
    ;; :load-path "~/.source")
    #+end_src

*** Emoji display

    By default emacs does not support emojis. Now it does!

    I do not activate this mode by default, but it should be hooked where it
    makes sense, eg. to the message view of mu4e.

    #+begin_src emacs-lisp
    (use-package emojify
      :ensure t
      :init
      (setq emojify-emoji-styles '(unicode)))
    #+end_src

** EXTRA BITS OF FUNCTIONALITY

   Bits and chunks of useful stuff.

*** Which key

    When starting to type a keybinding, it provides a "cheatsheet" with all
    available options

    #+begin_src emacs-lisp
    (use-package which-key
      :ensure t
      :delight
      :config
      (which-key-mode))
    #+end_src
*** Reload configuration

    Defining keybinding for reloading emacs configuration.

    #+begin_src emacs-lisp
    (use-package emacs
      :config
      (defun l/reload-emacs ()
	"Reload the init file"
	(interactive)
	(load-file "~/.emacs.d/init.el"))
  
      :bind
      ("C-c r" . l/reload-emacs))
    #+end_src
*** Restart emacs

    Restart emacs in place.

    #+begin_src emacs-lisp
    (use-package restart-emacs
      :ensure t
      :bind
      ("C-c C-S-r" . restart-emacs))
    #+end_src

*** Try packages

    Try before buy. With this package you can temporarily install a package.
    It won't be there upon reopening emacs. Occasionally useful.

    #+begin_src emacs-lisp
    (use-package try
      :ensure t)
    #+end_src

*** M-x for crippled keyboard

    Well, my keyboard is a cripple...

    #+begin_src emacs-lisp
    (use-package emacs
      :bind
      (:map leader
	    ("x" . counsel-M-x)))
    #+end_src

** GAMES

   Emacs has games too!

*** Snake

    #+begin_src emacs-lisp
    (use-package snake
      :config
      (evil-set-initial-state 'snake-mode 'normal)
      :general
      (:states 'normal :keymaps 'snake-mode-map
	       "h" 'snake-move-left
	       "j" 'snake-move-down
	       "k" 'snake-move-up
	       "l" 'snake-move-right
	       "p" 'snake-pause-game
	       "q" 'quit-window
	       "N" 'snake-start-game))
    #+end_src

*** 2048

    #+begin_src emacs-lisp
    (use-package 2048-game
      :ensure t)
    #+end_src

* LEARNING CURVE

  I decided to start keeping a log of useful features that I discovered
  while writing this configuration, or elisp in general.
** process-lines                                                      :shell:

   The function =process-lines= returns the result of a shell command as a
   list, separated by line.

   First used in the =rebet= package.

** user-error                                                :error:feedback:

   The =user-error= function allows to break out of a function signaling an
   error. Useful for checks with feedback concerning the reason of failure.

   First used in the =rebet= package

** symbol plists                                :plists:properties:variables:

   The ability to define properties for symbols without setting them as
   variable seems like an approach to objective programming, which might be
   useful in some applications.

   First used in the =rebet= package.

* REJECTED REJECTED PACKAGES

  These are packages and bits of functionality that where rejected, however
  I will keep them here for future reference. They all have =:disabled= in
  their =use-package= declarations.

** REJECTED HELM
   CLOSED: [2020-04-12 Sun 05:52]

   Helm is a powerful completion framework, but I rejected it for ivy.
   The main reason is that I wanted to add custom functionality which was
   not easy to do with helm.

   Ivy is also powerful and it feels more intuitive, both to use and to
   customize.

*** Basics
    #+begin_src emacs-lisp
    (use-package helm-config
      :disabled
      ;; :ensure helm
      :delight helm-mode
      :defer 1
      :init
      (setq helm-follow-mode-persistent t)
      (setq  helm-split-window-inside-p t)
      :config
      (helm-mode 1)
      :bind
      ("M-x" . helm-M-x)
      ("C-x C-f" . helm-find-files)
      ("M-y" . helm-show-kill-ring)
      ([remap switch-to-buffer] . helm-buffers-list))
    #+end_src

*** Helm-swoop
    #+begin_src emacs-lisp
    (use-package helm-swoop
      :disabled
      ;; :ensure t
      :after helm evil
      :init
      (setq helm-swoop-speed-or-color t)
      ;; pre-input disabled or marked word
      (setq helm-swoop-pre-input-function
	  (lambda ()
	    (if mark-active
		(buffer-substring-no-properties (mark) (point)) "")))
      :bind
      ("M-i" . 'helm-swoop)
      ("C-M-i" . 'helm-multi-swoop)
      ("M-I" . 'helm-swoop-back-to-last-point)
      (:map helm-swoop-map
	    ("M-i" . 'helm-multi-swoop-all-from-helm-swoop))
      (:map isearch-mode-map
	    ("M-i" . 'helm-swoop-from-isearch))
      (:map evil-motion-state-map
	    ("M-i" . 'helm-swoop-from-evil-search)))

    #+end_src
** REJECTED PDF TOOLS
   CLOSED: [2020-04-16 Thu 01:31]


   Pdf-tools cannot handle an update. It is really frustrating, because,
   when it works, it works great, but I had too many problems each time I
   performed an update of the package. It broke EVERY SINGLE TIME and it
   broke so bad that it dragged emacs with it. I tried using the =:pin=
   keyword in the use-package declaration but finally I decided to simply
   build it from source. Still, every time an update was performed, I had
   to rebuild the whole package. Finally I got tired of trying, so I
   settled for the default emacs doc-view, or with external viewing. It's a
   pity really!

   #+begin_src emacs-lisp
   (use-package pdf-tools
     :disabled
     ;; :ensure t
     :pin manual ; don't reinstall on updates
     :init
     (pdf-tools-install))

   ;; the manual way - build from source
   (use-package emacs
     :disabled
     :config
     (add-to-list 'load-path "~/.source/pdf-tools")
     (require 'pdf-tools)
     (eval-after-load "pdf-tools"
       (pdf-tools-install)))
   #+end_src

** REJECTED LINUM RELATIVE
   CLOSED: [2020-04-30 Thu 05:08]

   I just ended up never using relative line numbers. I experienced some
   buggy behaviour anyway, so I just dropped it.

   #+begin_src emacs-lisp
   (use-package linum-relative
     :disabled
     ;; :ensure t
     :after org
     :init
     (setq linum-relative-current-symbol "")
     :bind ("C-x M-l" . linum-relative-toggle))
   #+end_src

** REJECTED Smarter move to beginning of line
   CLOSED: [2020-04-30 Thu 04:55]

   Part of Prelude. Useful function, but I can live without it. Maybe I
   will revisit it at some point.

   NOTE TO SELF: I think I tweaked it a little bit at some point to use it
   with visual-line-mode and it didn't work so well. Keep that in mind.

   #+begin_src emacs-lisp
   (use-package emacs
     :disabled
     :config
     (defun smarter-move-beginning-of-line (arg)
       "Move point back to indentation of beginning of line.

   Move point to the first non-whitespace character on this line.
   If point is already there, move to the beginning of the line.
   Effectively toggle between the first non-whitespace character and
   the beginning of the line.

   If ARG is not nil or 1, move forward ARG - 1 lines first.  If
   point reaches the beginning or end of the buffer, stop there."
       (interactive "^p")
       (setq arg (or arg 1))

       Move lines first
       (when (/= arg 1)
	 (let ((line-move-visual nil))
	   (forward-line (1- arg))))

       (let ((orig-point (point)))
	 (back-to-indentation)
	 (when (= orig-point (point))
	   (move-beginning-of-line 1))))

     (global-set-key [remap move-beginning-of-line] 'smarter-move-beginning-of-line))
   #+end_src

** REJECTED Duplicate line
   CLOSED: [2020-04-30 Thu 03:28]

   Since I started to use evil-mode, I no longer used this function.

   #+begin_src emacs-lisp
   (use-package emacs
     :disabled
     :config
     (defun duplicate-line()
       "Duplicates a line."
       (interactive)
       (move-beginning-of-line 1)
       (kill-line)
       (yank)
       (open-line 1)
       (next-line 1)
       (yank))

     (global-set-key (kbd "C-c d") 'duplicate-line))
   #+end_src

** REJECTED Split windows and follow
   CLOSED: [2020-04-18 Sat 12:54]

   The reason of these functions is to always focus the newly created
   window. It makes sense, but I try to get used to the default behaviour,
   which is to retain focus on the current window, and it is not so bad.
   So, I am disabling these until further notice.

   #+begin_src emacs-lisp
   (use-package emacs
     :disabled
     :config
     (defun split-window-and-follow-below ()
       "Split and follow container horizontally."
       (interactive)
       (split-window-below)
       (balance-windows)
       (other-window 1))

     (defun split-window-and-follow-right ()
       "Split and follow container vertically."
       (interactive)
       (split-window-right)
       (balance-windows)
       (other-window 1))

     (global-set-key (kbd "C-x 2") 'split-window-and-follow-below)
     (global-set-key (kbd "C-x 3") 'split-window-and-follow-right)
   )
   #+end_src

** REJECTED mu4e open in headers of specific account
   CLOSED: [2020-04-12 Sun 06:03]

   Back when I didn't grasp the logic behind mu4e, I used this function to
   replicate what was normal for me at the time, which is to open your
   Inbox when you receive an email. I later discovered the joy of managing
   all of my accounts together and replaced this function with viewing the
   unread messages alltogether.

   #+begin_src emacs-lisp
   (use-package mu4e
     :disabled
     :config
     (defun mu4e-open-in-headers (account)
       "Open mu4e in account's Inbox"
       (interactive)
       (mu4e~start)
       (if (get-buffer "*mu4e-headers*" )
	   (switch-to-buffer "*mu4e-headers*"))
       (mu4e-headers-search (concat "maildir:/" account "/Inbox"))))
   #+end_src

** REJECTED Renaming functions (Wdired)
   CLOSED: [2020-04-11 Sat 03:59]

   I don't remember how exactly I intended to use these, but it finally
   didn't make much sense to me. Maybe I will revisit this idea.

   #+begin_src emacs-lisp
   (use-package wdired
     :disabled
     :config
     (defun l/evil-wdired-append-to-filename ()
       "Renaming helper for `wdired'. Append to filename before the extension."
       (interactive)
       (move-end-of-line nil)
       (search-backward ".")
       (evil-insert 1))

     (defun l/evil-wdired-change-filename ()
       "Renaming helper for `wdired'. Change the filename but keep the extension."
       (interactive)
       (move-end-of-line nil)
       (search-backward ".")
       (kill-region 1 (point))
       (evil-insert 1))

     (defun l/evil-wdired-change-extension ()
       "Renaming helper for `wdired'. Change file's extension."
       (interactive)
       (move-end-of-line nil)
       (set-mark-command nil)
       (search-backward ".")
       (forward-char)
       (kill-region (point) (mark))
       (evil-insert 1))
   )
   #+end_src
** REJECTED AUTOCOMPLETE
   CLOSED: [2020-11-30 Mon 14:01]

   This is just a generic autocompletion framework. I haven't tweaked it in
   any way and it only works most of the time. For example, filename
   completion never worked as intended.

   Anyhow, it is still useable, but I guess I will try something like
   company soon.

    #+begin_src emacs-lisp
	(use-package auto-complete
	  :disabled
	  :ensure t
	  :delight
	  :init
	  (ac-config-default)
	  (global-auto-complete-mode t)
	  (setq ac-ignore-case nil)
	  :config
	  (setq ac-sources (append ac-sources ac-source-filename ac-source-files-in-current-dir)))
    #+end_src

*** DONE TODO list [1/1]

**** DONE Switch to company
     CLOSED: [2020-11-26 Thu 12:35]

     After browsing the web, I found out that the autocomplete package is in
     fact unmaintained. So, it makes more and more sense to try company.
