* MY EMACS CONFIGURATION

Emacs configuration managed with org-mode and use-package.

The code snippets are loaded by =init.el=, which also loads =use-package=.

** INTERFACE
*** Try packages

    #+begin_src emacs-lisp
    (use-package try
      :ensure t)
    #+end_src

*** Defaults

    #+begin_src emacs-lisp
    (setq inhibit-splash-screen t)       ;; disable the splash screen
    (setq initial-scratch-message nil)   ;; disable scratch message
    (tool-bar-mode -1)                   ;; all bars off
    (menu-bar-mode -1)
    (scroll-bar-mode -1)
    (blink-cursor-mode -1)
    (column-number-mode 1)               ;; show cursor position
    (global-visual-line-mode t)          ;; visual line mode everywhere
    (global-hl-line-mode t)              ;; highlight active line
    ;; (set-face-background ('hl-line) "#202020")
    (fset 'yes-or-no-p 'y-or-n-p)        ;; ask me for y or n
    (setq select-enable-clipboard t)     ;; use the clipboard for yanking
    (setq save-interprogram-paste-before-kill t)
    (setq help-window-select t)          ;; always focus on help windows
    (setq sentence-end-double-space nil) ;; better sentence navigation
    (delete-selection-mode 1)            ;; typing deletes selected text
    (set-language-environment "UTF-8")   ;; always use UTF-8 encoding
    (set-default-coding-systems 'utf-8)
    #+end_src

*** Enable some disabled features

    #+begin_src emacs-lisp
    (put 'downcase-region 'disabled nil) ;; binds to 'C-x C-l'
    (put 'upcase-region 'disabled nil) ;; binds to 'C-x C-u'
    (put 'narrow-to-region 'disabled nil) ;; binds to 'C-x n n'
    #+end_src

*** Font size

    #+begin_src emacs-lisp
    (global-set-key (kbd "C-<next>") 'text-scale-increase)
    (global-set-key (kbd "C-<prior>") 'text-scale-decrease)
    #+end_src

*** Line numbering

    #+begin_src emacs-lisp
    (display-line-numbers-mode t)

    (use-package linum-relative
      :ensure t
      :after org
      :init
      (setq linum-relative-current-symbol "")
      :bind ("C-x M-l" . linum-relative-toggle))
    #+end_src

*** Darkroom mode

    A nice mode for reading and writing, similar to vim's goyo
    Does it make sense to configure follow-mode here? Maybe.

    #+begin_src emacs-lisp
    (use-package darkroom
      :ensure t
      :init
      (setq darkroom-text-scale-increase 0.8)
      :bind
      (("C-M-_" . darkroom-decrease-margins)
       ("C-x M-D" . darkroom-tentative-mode)))

    (global-set-key (kbd "C-x M-L") 'follow-mode)
    #+end_src

*** Rainbow mode

    #+begin_src emacs-lisp
    (use-package rainbow-mode
      :ensure t
      :delight
      :hook prog-mode)
    #+end_src

*** Load theme

    #+begin_src emacs-lisp
    (use-package color-theme-sanityinc-tomorrow
      :ensure t)

    (color-theme-sanityinc-tomorrow--define-theme bright)
    #+end_src

*** All the icons
Icons for emacs.
#+begin_src emacs-lisp
;; Note: After the first load, run `all-the-icons-install-fonts'
(use-package all-the-icons
  :ensure t
  :delight)
#+end_src

*** Hide info from modeline (delight)

    Normally I use the =:delight= keyword of use package, here are the built-in modes that I want to omit.

    #+begin_src emacs-lisp
    (use-package delight
      :ensure t
      :config
      (delight 'dired-mode "")
      (delight 'undo-tree-mode nil 'undo-tree)
      (delight 'visual-line-mode " ⏎" 'simple)
      (delight 'eldoc-mode nil 'eldoc)
      ;; for some reason, I cannot set this in use-package declaration of smartparens
      (delight 'smartparens-mode " {⬄}" 'smartparens))
    #+end_src

This seems a reasonable way to change modeline info for major modes. Why use delight for that? It also seems to work better for, e.g, this case.

    #+begin_src emacs-lisp
    (add-hook 'emacs-lisp-mode-hook
	  (lambda ()
	    (setq mode-name "ELisp")))
    #+end_src
    
*** Which key

    #+begin_src emacs-lisp
    (use-package which-key
      :ensure t
      :delight
      :config (which-key-mode))
    #+end_src
*** Default files

    Change the way that emacs keeps backups, also some default files, like custom

    #+begin_src emacs-lisp
    ;; use separate custom file
    (setq custom-file "~/.emacs.d/custom.el")
    (load custom-file)

    ;; backup files
    (setq backup-directory-alist `(("." . "~/.emacs.d/backups")))
    (setq backup-by-copying t) ;; this is to ensure all edited files keep their inodes
    #+end_src

** FUNCTIONALITY
*** Whole buffer evaluation

    #+begin_src emacs-lisp
    (global-set-key (kbd "C-x C-S-e") 'eval-buffer)
    #+end_src

*** Toggle comments

    #+begin_src emacs-lisp
    (global-set-key (kbd "C-;") 'comment-line)
    (global-set-key (kbd "C-M-;") 'comment-or-uncomment-region)
    #+end_src

*** Parentheses

    #+begin_src emacs-lisp
    (use-package smartparens-config
      :ensure smartparens
      ;; :delight ('smartparens-mode " \(\)" 'smartparens)
      :init
      (smartparens-global-mode 1)
      (show-smartparens-global-mode 1)
      (sp-local-pair 'emacs-lisp-mode "'" nil :actions nil)
      :bind
      ("M-s" . sp-splice-sexp))

    (use-package rainbow-delimiters
      :ensure t
      :init
      (add-hook 'prog-mode-hook #'rainbow-delimiters-mode))

    #+end_src

*** Expand region

    #+begin_src emacs-lisp
    (use-package expand-region
      :ensure t
      :bind
      (("C-=" . er/expand-region)
       ("C-c =" . er/expand-region)
       ("C--" . er/contract-region)
       ("C-c -" . er/contract-region)))
    #+end_src

*** Smarter move to beginning of line

    Part of Prelude

    #+begin_src emacs-lisp
    (defun smarter-move-beginning-of-line (arg)
      "Move point back to indentation of beginning of line.

    Move point to the first non-whitespace character on this line.
    If point is already there, move to the beginning of the line.
    Effectively toggle between the first non-whitespace character and
    the beginning of the line.

    If ARG is not nil or 1, move forward ARG - 1 lines first.  If
    point reaches the beginning or end of the buffer, stop there."
      (interactive "^p")
      (setq arg (or arg 1))

      ;; Move lines first
      (when (/= arg 1)
	(let ((line-move-visual nil))
	  (forward-line (1- arg))))

      (let ((orig-point (point)))
	(back-to-indentation)
	(when (= orig-point (point))
	  (move-beginning-of-line 1))))

    (global-set-key [remap move-beginning-of-line] 'smarter-move-beginning-of-line)
    #+end_src

    Kill the whole line

    #+begin_src emacs-lisp
    (global-set-key (kbd "C-S-k") 'kill-whole-line)
    #+end_src

*** Duplicate line

    #+begin_src emacs-lisp
    (defun duplicate-line()
      "Duplicates a line."
      (interactive)
      (move-beginning-of-line 1)
      (kill-line)
      (yank)
      (open-line 1)
      (next-line 1)
      (yank))

    (global-set-key (kbd "C-c d") 'duplicate-line)
    #+end_src

*** Auto-evaluate init file

    Auto-evaluate the init.el file when saving this org file. A must have!

    Got the general idea from https://www.reddit.com/r/emacs/comments/8hpyp5/tip_how_to_execute_a_bash_function_when_saving_a/

    #+begin_src emacs-lisp

    (defun l/reload-emacs ()
      "Reload the init file"
      (interactive)
      (load-file "~/.emacs.d/init.el"))

    (defun my/cmd-after-saved-file ()
      "Evaluate the init file automatically"
	(when (string= (buffer-file-name) (expand-file-name "~/.emacs.d/my-config.org"))
	  (l/reload-emacs)))

    (add-hook 'after-save-hook 'my/cmd-after-saved-file)

    ;; also makes sense to bind a "refresh" key, similar to the i3 config
    (global-set-key (kbd "C-M-S-r") 'l/reload-emacs)
    #+end_src

*** Restart emacs
Restart emacs from within emacs (duh!)
#+begin_src emacs-lisp
(use-package restart-emacs
  :ensure t
  :bind ("C-M-S-e" . 'restart-emacs))

#+end_src

*** Syntax highlighting for rc files

    #+begin_src emacs-lisp
    (add-to-list 'auto-mode-alist '("\\.*rc$" . conf-mode))
    #+end_src

** WINDOW MANAGEMENT
*** Windows movement and resizing

    This would be good if my damn keyboard worked correctly. I think I should use vim keys or sth

    #+begin_src emacs-lisp
    (windmove-default-keybindings) ;; use arrow keys ot navigate

    ;; resize shortcuts
    (global-set-key (kbd "S-C-<left>") 'shrink-window-horizontally)
    (global-set-key (kbd "S-C-<right>") 'enlarge-window-horizontally)
    (global-set-key (kbd "S-C-<down>") 'shrink-window)
    (global-set-key (kbd "S-C-<up>") 'enlarge-window)
    #+end_src

*** Ace-window

    Ace-window is a more efficient way to move between windows.

    #+begin_src emacs-lisp
    (use-package ace-window
      :ensure t
      :init
      (setq aw-keys '(?h ?j ?k ?l ?a ?s ?d ?f ?g))
      :bind
      (("C-x o" . ace-window)
       ("C-x M-o" . ace-swap-window)))
    #+end_src

*** Split windows and follow

    The default behaviour after splitting a window is to stay in the initial window. I always want to go to the new one.

    I don't remember from where I got this.

    #+begin_src emacs-lisp
    (defun split-window-and-follow-below ()
      "Split and follow container horizontally."
      (interactive)
      (split-window-below)
      (balance-windows)
      (other-window 1))

    (defun split-window-and-follow-right ()
      "Split and follow container vertically."
      (interactive)
      (split-window-right)
      (balance-windows)
      (other-window 1))

    (global-set-key (kbd "C-x 2") 'split-window-and-follow-below)
    (global-set-key (kbd "C-x 3") 'split-window-and-follow-right)

    #+end_src

*** Toggle window split

    #+begin_src emacs-lisp
    (defun toggle-window-split ()
      "Switch between horizontal and vertical split when using two windows."
      (interactive)
      (if (= (count-windows) 2)
	  (let* ((this-win-buffer (window-buffer))
		 (next-win-buffer (window-buffer (next-window)))
		 (this-win-edges (window-edges (selected-window)))
		 (next-win-edges (window-edges (next-window)))
		 (this-win-2nd (not (and (<= (car this-win-edges)
					     (car next-win-edges))
					 (<= (cadr this-win-edges)
					     (cadr next-win-edges)))))
		 (splitter
		  (if (= (car this-win-edges)
			 (car (window-edges (next-window))))
		      'split-window-horizontally
		    'split-window-vertically)))
	    (delete-other-windows)
	    (let ((first-win (selected-window)))
	      (funcall splitter)
	      (if this-win-2nd (other-window 1))
	      (set-window-buffer (selected-window) this-win-buffer)
	      (set-window-buffer (next-window) next-win-buffer)
	      (select-window first-win)
	      (if this-win-2nd (other-window 1))))))

    (global-set-key (kbd "C-x |") 'toggle-window-split)
    #+end_src

*** Swap windows

    #+begin_src emacs-lisp
    (global-set-key (kbd "C-x \\") 'window-swap-states)
    #+end_src

*** Evil window bindings

    Window functions with evil mode. Also some functions that make sense for me to be configured here, like buffer actions.

    #+begin_src emacs-lisp
    (eval-after-load "evil"
      '(progn
	 (define-key evil-normal-state-map "\\" nil) ;; prefix
	 (define-key evil-normal-state-map "\\0" 'ace-delete-window)
	 (define-key evil-normal-state-map "\\q" 'delete-window)
	 (define-key evil-normal-state-map "\\Q" 'kill-buffer-and-window)
	 (define-key evil-normal-state-map "\\1" 'delete-other-windows)
	 ;; for movement, it made more sense to use "gaming" keys (also because of the prefix key position)
	 (define-key evil-normal-state-map "\\a" 'windmove-left)
	 (define-key evil-normal-state-map "\\s" 'windmove-down)
	 (define-key evil-normal-state-map "\\w" 'windmove-up)
	 (define-key evil-normal-state-map "\\d" 'windmove-right)
	 (define-key evil-normal-state-map "\\s" 'split-window-and-follow-right)
	 (define-key evil-normal-state-map "\\3" 'split-window-and-follow-right)
	 (define-key evil-normal-state-map "\\v" 'split-window-and-follow-below)
	 (define-key evil-normal-state-map "\\2" 'split-window-and-follow-below)
	 (define-key evil-normal-state-map "\\_" 'toggle-window-split)
	 (define-key evil-normal-state-map "\\-" 'window-swap-states)
	 (define-key evil-normal-state-map "\\\\" 'ace-window)
	 (define-key evil-normal-state-map "\\|" 'ace-swap-window)
	 (define-key evil-normal-state-map (kbd "M-H") 'shrink-window-horizontally)
	 (define-key evil-normal-state-map (kbd "M-L") 'enlarge-window-horizontally)
	 (define-key evil-normal-state-map (kbd "M-J") 'shrink-window)
	 (define-key evil-normal-state-map (kbd "M-K") 'enlarge-window)
	 (define-key evil-normal-state-map (kbd "M-+") 'balance-windows)
	 (define-key evil-normal-state-map "\\f" 'find-file)
	 (define-key evil-normal-state-map "\\b" 'switch-to-buffer)
	 (define-key evil-normal-state-map "\\," '(lambda () (interactive) (switch-to-buffer "*scratch*")))
	 (define-key evil-normal-state-map "\\<" 'switch-to-prev-buffer)
	 (define-key evil-normal-state-map "\\>" 'switch-to-next-buffer)
	 (define-key evil-normal-state-map "\\z" 'kill-current-buffer)
	 (define-key evil-normal-state-map "\\D" 'dired)
	 ;; other window
	 (define-key evil-normal-state-map "\\'" nil) ;;prefix
	 (define-key evil-normal-state-map "\\'f" 'find-file-other-window)
	 (define-key evil-normal-state-map "\\'b" 'switch-to-buffer-other-window)
	 (define-key evil-normal-state-map "\\'D" 'dired-other-window)))

    #+end_src

** HELM
*** Basics
   #+begin_src emacs-lisp
   (use-package helm-config
     :ensure helm
     :delight helm-mode
     :defer 1
     :init
     (setq helm-follow-mode-persistent t)
     (setq  helm-split-window-inside-p t)
     :config
     (helm-mode 1)
     :bind
     ("M-x" . helm-M-x)
     ("C-x C-f" . helm-find-files)
     ("M-y" . helm-show-kill-ring)
     ([remap switch-to-buffer] . helm-buffers-list))
   #+end_src

*** Helm-swoop
    #+begin_src emacs-lisp
    (use-package helm-swoop
      :ensure t
      :after helm evil
      :init
      (setq helm-swoop-speed-or-color t)
      ;; pre-input disabled or marked word
      (setq helm-swoop-pre-input-function
	  (lambda ()
	    (if mark-active
		(buffer-substring-no-properties (mark) (point)) "")))
      :bind
      ("M-i" . 'helm-swoop)
      ("C-M-i" . 'helm-multi-swoop)
      ("M-I" . 'helm-swoop-back-to-last-point)
      (:map helm-swoop-map
	    ("M-i" . 'helm-multi-swoop-all-from-helm-swoop))
      (:map isearch-mode-map
	    ("M-i" . 'helm-swoop-from-isearch))
      (:map evil-motion-state-map
	    ("M-i" . 'helm-swoop-from-evil-search)))

    #+end_src
** IVY

   I will try to replace helm with ivy.

   #+begin_src emacs-lisp
   ;; counsel brings ivy
   (use-package counsel
     :ensure t)
   #+end_src
** AUTOCOMPLETE

   Maybe use another option, like company. I have to check it out.

   #+begin_src emacs-lisp
   (use-package auto-complete
     :ensure t
     :delight (auto-complete-mode " ⋯")
     :init
     (ac-config-default)
     (global-auto-complete-mode t)
     (setq ac-sources (append ac-sources '(ac-sources-filename)))
     (setq ac-ignore-case nil))
   #+end_src

** MULTIPLE CURSORS

   It seems that the mc package is not really needed. Maybe everything it does can be achieved by using replacement methods and/or macros. Not to mention vim's =:g= command, or helm-swoop.

   #+begin_src emacs-lisp
   (use-package multiple-cursors
     :ensure t
     :bind
     ("C-s-c C-s-c" . mc/edit-lines)
     ("C->" . mc/mark-next-like-this)
     ("C-<" . mc/mark-previous-like-this)
     ("C-c C-<" . mc/mark-all-like-this)
     ("C-<down-mouse-1>" . mc/add-cursor-on-click)
     ("C-!" . mc/insert-numbers))

   (use-package mc-extras
     :ensure t
     :after multiple-cursors)

   (use-package ace-mc
     :ensure t
     :after mc-extras
     :bind
     ("C-c )" . ace-mc-add-multiple-cursors)
     ("C-M-)" . ace-mc-add-single-cursor))
   #+end_src

** DIRED

   This *IS* my new file manager!
   
*** Dired-x

    #+begin_src emacs-lisp
    (use-package dired-x
      :ensure nil
      :delight dired-omit-mode
      :after dired
      :init
      (setq dired-omit-verbose nil)
      :config
      ;; files to be ommited: beginning with one or more dots, beginning with $ (some files that come from Windows), ending with xmp (eg darktable data files), ending with srt, sub (I don't want to see subtitle files)
      (setq dired-omit-files (concat dired-omit-files "\\|^\\..+$\\|^\\$\\|xmp$\\|srt$\\|sub$")))
    #+end_src

*** Some useful functions

**** Attatch marked files to email:

     Found [[https://emacs.stackexchange.com/questions/14652/attach-multiple-files-from-the-same-directory-to-an-email-message][here]].

     Open a dired buffer, mark some files and run the command. If there's an open message buffer use it, else create new message

     #+begin_src emacs-lisp
     (defun compose-attach-marked-files ()
       "Compose mail and attach all the marked files from a dired buffer. Uses `compose-mail', (or `org-msg-attach-attach' if org-msg is enabled -- this is not true yet)."
       (interactive)
       (let ((files (dired-get-marked-files)))
	 (compose-mail nil nil nil t)
	 (dolist (file files)
	   (if (file-regular-p file)
	       (mml-attach-file file
				(mm-default-file-encoding file)
				nil "attachment")
	     (message "skipping non-regular file %s" file)))))
     #+end_src

**** Go to first/last directory:

     Instead of going to the beginning or end of the buffer, go to the first or last directory line
     
     Source: https://www.emacswiki.org/emacs/dired-extension.el

     #+begin_src emacs-lisp
     (defun dired-goto-first-file ()
       "Move cursor to first file of dired."
       (interactive)
       (goto-char (point-min))
       (while (not (dired-move-to-filename))
	 (call-interactively 'dired-next-line)))

     (defun dired-goto-last-file ()
       "Move cursor to last file of dired."
       (interactive)
       (goto-char (point-max))
       (while (not (dired-move-to-filename))
	 (call-interactively 'dired-previous-line)))
     #+end_src

**** Sorting functions:

     Change the ls flags that dired uses for different sorting options

     #+begin_src emacs-lisp
     ;; sort by
     (defun l/dired-sort-by (sw)
       "Sort dired buffer by given switches and go to first line. If the switches provided are the same with the current switches, do nothing"
       (let ((switches dired-actual-switches))
	 (unless (string= sw switches)
	   (dired-sort-other sw)
	   (dired-goto-first-file))))

     ;; callable functions
     ;; by name
     (defun l/dired-sort-by-name ()
       "Sort by name. Calls `l/dired-sort-by'."
       (interactive)
       (l/dired-sort-by "-alh"))

     ;; by date
     (defun l/dired-sort-by-date ()
       "Sort by date. Calls `l/dired-sort-by'."
       (interactive)
       (l/dired-sort-by "-alht"))

     ;; by size
     (defun l/dired-sort-by-size ()
       "Sort by size. Calls `l/dired-sort-by'."
       (interactive)
       (l/dired-sort-by "-alhS"))

     ;; by extension
     (defun l/dired-sort-by-ext ()
       "Sort by extension. Calls `l/dired-sort-by'."
       (interactive)
       (l/dired-sort-by "-alhX"))

     ;; toggle directories first
     (defun l/dired-sort-dirs-first ()
       "Toggles grouping directories first."
       (interactive)
       (let ((switches dired-actual-switches))
	 (if (string-match-p (regexp-quote " --group-directories-first") switches)
	     (setq switches (replace-regexp-in-string " --group-directories-first" "" switches))
	   (setq switches (concat switches " --group-directories-first")))
	 (dired-sort-other switches))
       (dired-goto-first-file))
     #+end_src

**** Mark and move backwards:

     This was always a missing feature imho.

     #+begin_src emacs-lisp
	  (defun l/dired-mark-backwards ()
	    "Mark file at point and move backwards."
	    (interactive)
	    (if (dired-move-to-filename)
	      (progn
		(dired-mark 1)
		(dired-previous-line 2))))

     #+end_src

**** Narrow to marked files:

     #+begin_src emacs-lisp
     (defun l/dired-narrow-to-marked-files ()
       "Show only marked files in dired buffer."
       (interactive)
       (let ((files (dired-get-marked-files)))
	 (unless (eq (length files) 1)
	   (dired-toggle-marks)
	   (dired-do-kill-lines))))
     #+end_src

*** Some useful (external) functions
    
    Useful functions that use external programs.

    - Mount / unmount (and maybe format) functionality using udiskie (temporarily, till new/better script is written)

**** Get subtitles:

     Use [[https://github.com/Diaoul/subliminal][subliminal]] to find subtitles online. The gist of using 'start-process' comes from [[http://ergoemacs.org/emacs/elisp_call_shell_command.html][here]], and the idea of using 'apply' from [[https://stackoverflow.com/questions/17075920/passing-list-to-rest-args?rq=1][here]].

     #+begin_src emacs-lisp
     (defun get-subtitles ()
       "Get subtitles for marked files while in a dired buffer. Depends on subliminal, so it has to be on your system."
       (interactive)
       (when (eq major-mode 'dired-mode)
	 (let* ((lang-list '("en" "gr"))
		(lang (completing-read "Select language: " lang-list nil t))
		(files (dired-get-marked-files))
		(process-connection-type nil))
	   (if (get-buffer "*get-subtitles*")
	       (kill-buffer "*get-subtitles*"))
	   (apply 'start-process
		  (append (list "get-subtitles" "*get-subtitles*" "subliminal" "download" "-l" lang) files))
	 (switch-to-buffer-other-window "*get-subtitles*")
	 (special-mode))))
     #+end_src

**** Get files size:

     Source: https://www.emacswiki.org/emacs/dired-extension.el

     #+begin_src emacs-lisp
     (defun dired-get-size ()
       "Get total size of marked files with `du' command.
     If not marked any files, default is current file or directory."
       (interactive)
       (let ((files (dired-get-marked-files)))
	 (with-temp-buffer
	   (apply 'call-process "/usr/bin/du" nil t nil "-sch" files)
	   (message "%s"
		    (progn
		      (re-search-backward "\\(^[0-9.,]+[A-Za-z]+\\).*\\(total\\|总用量\\)$")
		      (match-string 1))))))
     #+end_src

**** Change desktop background:

     #+begin_src emacs-lisp
     (defun l/change-desktop-background ()
       "Change the desktop background using feh."
       (interactive)
       (let ((fit-type (completing-read "Select fit: " '("scale" "center" "fill" "max") nil t))
	     (entry (shell-quote-argument (expand-file-name (dired-file-name-at-point))))
	     (targetfile (shell-quote-argument (expand-file-name "~/.config/.wallpaper.jpg"))))
	 (setq cpcmd (concat "cp " entry " " targetfile))
	 (setq fehcmd (concat "feh --bg-" fit-type " " targetfile))
	 (setq cmd (concat cpcmd " && " fehcmd))
	 (shell-command cmd))) 
     #+end_src

**** Unmount drives

     Simple script to unmount drive. Uses 'mountpoint' and 'umount'. If unmounting fails, give some options (todo).

     #+begin_src emacs-lisp
     (defun l/unmount-drive ()
       "Unmount selected directories, if they correspond to mountpoints."
       (interactive)
       (let ((dirs (dired-get-marked-files)))
	 (dired-do-shell-command "mountpoint -q ? && umount ?" nil dirs)
	 (revert-buffer)))
     #+end_src

*** Dired custom maps

    #+begin_src emacs-lisp
    ;; navigation map
    (define-prefix-command 'l/dired-nav-map)

    (define-key l/dired-nav-map "h" (lambda () (interactive) (dired "~/")))
    (define-key l/dired-nav-map "D" (lambda () (interactive) (dired "~/Downloads/")))
    (define-key l/dired-nav-map "d" (lambda () (interactive) (dired "~/Documents/")))
    (define-key l/dired-nav-map "p" (lambda () (interactive) (dired "~/Pictures/")))
    (define-key l/dired-nav-map "M" (lambda () (interactive) (dired "~/Music/")))
    (define-key l/dired-nav-map "v" (lambda () (interactive) (dired "~/Videos/")))
    (define-key l/dired-nav-map "m" (lambda () (interactive) (dired "/run/media/louk/")))
    (define-key l/dired-nav-map "C" (lambda () (interactive) (dired "~/.config/")))
    (define-key l/dired-nav-map "E" (lambda () (interactive) (dired "~/.emacs.d/")))
    (define-key l/dired-nav-map "!" (lambda () (interactive) (dired "~/dotfiles/")))

    ;; external scripts map
    (define-prefix-command 'l/dired-my-ext-cmds)

    (define-key l/dired-my-ext-cmds "s" 'get-subtitles)
    (define-key l/dired-my-ext-cmds "?" 'dired-get-size)
    (define-key l/dired-my-ext-cmds "B" 'l/change-desktop-background)
    #+end_src

*** Dired defaults

    #+begin_src emacs-lisp
    (setq dired-dwim-target t)
    (setq dired-listing-switches "-alh") ;; add human-readable sizes

    (add-hook 'dired-mode-hook
	      (lambda ()
		(dired-hide-details-mode)
		(dired-omit-mode)))

    ;; This hook seems to be added automatically to my 'custom.el' file and breaks dired. I have to find out where it comes from. It was a part of the `ranger' package, which I have deleted.
    (remove-hook 'dired-mode-hook 'ranger-set-dired-key)
    #+end_src

*** Image dired

    #+begin_src emacs-lisp
      (setq image-dired-thumb-width 250)
      (setq image-dired-thumbs-per-row 4)
      (setq image-dired-external-viewer "sxiv")
    #+end_src

*** Dired keybindings

    Changing some default keybindings

    #+begin_src emacs-lisp
      (eval-after-load "dired"
	'(progn
	   (define-key dired-mode-map "G" 'revert-buffer)
	   (define-key dired-mode-map "g" 'l/dired-nav-map)
	   (define-key dired-mode-map "z" 'dired-omit-mode)
	   (define-key dired-mode-map (kbd "C-x M-.") 'compose-attach-marked-files)
	   (define-key dired-mode-map (kbd "M-<") 'dired-goto-first-file)
	   (define-key dired-mode-map (kbd "M->") 'dired-goto-last-file)))
    #+end_src

*** Evil dired bindings

   Loading the whole evil-collection proved cumbersome for me, there was some trouble with my custom keybindings (eg. I couldn't use 'r' as a prefix key, even when binding it to nil after loading evil-collection). Might be sth that I did wrong, but anyhow...

   #+begin_src emacs-lisp
   ;; this is from evil-collection with some changes
   (eval-after-load "evil"
     '(progn
	(evil-define-key 'normal dired-mode-map
	  ;; basics
	  "q" 'quit-window
	  ;; basic movement
	  "j" 'dired-next-line
	  "k" 'dired-previous-line
	  "h" 'dired-up-directory
	  "l" 'dired-find-file
	  ">" 'dired-next-dirline
	  "<" 'dired-prev-dirline
	  "gg" 'dired-goto-first-file
	  "G" 'dired-goto-last-file
	  ;; basic functions
	  "A" 'dired-do-find-regexp
	  "B" 'dired-do-byte-compile
	  "C" 'dired-do-copy
	  "D" 'dired-do-delete
	  ;; dired-do-chgrp
	  "H" 'dired-do-hardlink
	  "L" 'dired-do-load
	  "M" 'dired-do-chmod
	  "O" 'dired-do-chown
	  "P" 'dired-do-print
	  "Q" 'dired-do-find-regexp-and-replace
	  "R" 'dired-do-rename
	  "S" 'dired-do-symlink
	  "T" 'dired-do-touch
	  "Z" 'dired-do-compress
	  "c" 'dired-do-compress-to
	  "!" 'dired-do-shell-command
	  "&" 'dired-do-async-shell-command
	  "=" 'dired-diff
	  ;; regexp operations
	  "%" nil ;; prefix
	  "%u" 'dired-upcase
	  "%l" 'dired-downcase
	  "%d" 'dired-flag-files-regexp
	  "%g" 'dired-mark-files-containing-regexp
	  "%m" 'dired-mark-files-regexp
	  "%C" 'dired-do-copy-regexp
	  "%H" 'dired-do-hardlink-regexp
	  "%R" 'dired-do-rename-regexp
	  "%S" 'dired-do-symlink-regexp
	  "%&" 'dired-flag-garbage-files
	  ;; marks & flags
	  "U" 'dired-unmark-all-marks
	  "u" 'dired-unmark
	  "m" 'dired-mark
	  (kbd "<SPC>") 'dired-mark
	  (kbd "C-<SPC>") 'l/dired-mark-backwards
	  "t" 'dired-toggle-marks
	  "d" 'dired-flag-file-deletion
	  "x" 'dired-do-flagged-delete
	  (kbd "* <delete>") 'dired-unmark-backward
	  (kbd "<delete>") 'dired-unmark-backward
	  "*" nil ;; prefix
	  "**" 'dired-mark-executables
	  "*/" 'dired-mark-directories
	  "*@" 'dired-mark-symlinks
	  "*%" 'dired-mark-files-regexp
	  "*(" 'dired-mark-sexp
	  "*." 'dired-mark-extension
	  "*O" 'dired-mark-omitted
	  "*c" 'dired-change-marks
	  "*s" 'dired-mark-subdir-files
	  "*?" 'dired-unmark-all-files
	  "*!" 'dired-unmark-all-marks
	  "*f" 'l/dired-narrow-to-marked-files
	  ;; encryption-decryption (epa-dired)
	  ";d" 'epa-dired-do-decrypt
	  ";v" 'epa-dired-do-verify
	  ";s" 'epa-dired-do-sign
	  ";e" 'epa-dired-do-encrypt
	  ;; unsorted
	  "X" 'l/dired-my-ext-cmds
	  "z" 'dired-omit-mode
	  "g" 'l/dired-nav-map
	  "gr" 'revert-buffer
	  "gR" 'dired-do-redisplay
	  "I" 'dired-maybe-insert-subdir
	  "i" 'dired-toggle-read-only
	  "J" 'dired-goto-file
	  "K" 'dired-do-kill-lines
	  "a" 'dired-find-alternate-file
	  "gy" 'dired-show-file-type
	  "Y" 'dired-copy-filename-as-kill
	  "+" 'dired-create-directory
	  (kbd "S-<return>") 'dired-find-file-other-window
	  (kbd "RET") 'dired-find-file
	  (kbd "M-<return>") 'browse-url-of-dired-file
	  ;; sorting
	  "o" nil ;; prefix -- was dired-sort-toggle-or-edit
	  "oo" 'l/dired-sort-by-name
	  "od" 'l/dired-sort-by-date
	  "os" 'l/dired-sort-by-size
	  "ox" 'l/dired-sort-by-ext
	  "o=" 'l/dired-sort-dirs-first
	  "(" 'dired-hide-details-mode
	  "g?" 'dired-summary
	  "?" 'dired-get-size)

	(add-hook 'dired-mode-hook 'evil-normalize-keymaps)))
   #+end_src

*** Dired subtree

    #+begin_src emacs-lisp
    (use-package dired-subtree
      :ensure t
      :after dired evil
      :config
      (evil-define-key 'normal dired-mode-map (kbd "TAB") 'dired-subtree-toggle))
    #+end_src

*** Peep dired

    Peep dired is loaded from [[https://github.com/dakodeon/peep-dired][my fork]].

**** Peepy-fied dired functions

     Some functions for a more consistent peeping experience.
     
     Note: these were left out of my peep-dired fork because they are not part of dired

     #+begin_src emacs-lisp
     (defun l/peep-dired-goto-first-file ()
       "Go to first file line and peep there. Uses `dired-goto-first-file'"
       (interactive)
       (dired-goto-first-file)
       (peep-dired-display-file-other-window))

     (defun l/peep-dired-goto-last-file ()
       "Go to last file line and peep there. Uses `dired-goto-last-file'"
       (interactive)
       (dired-goto-last-file)
       (peep-dired-display-file-other-window))
     #+end_src

**** Load Peep

     This is my fork of peep-dired. clone it from [[https://github.com/dakodeon/peep-dired/tree/luc][github]] and set =:load-path= to point to the correct path.

    #+begin_src emacs-lisp
    (use-package peep-dired
      :load-path "~/.source/peep-dired"
      :delight (peep-dired " ")
      :after dired-x
      :init
      ;; is this that creates an error? -- Yes, do not use it, or fix it
      (setq peep-dired-cleanup-eagerly t)
      (setq peep-dired-ignored-extensions '("mkv" "mp4" "avi" "mov" "mp3" "wav" "iso"))
      :config
      ;; evil integration
      (eval-after-load "evil"
	'(progn
	   (evil-define-key 'normal peep-dired-mode-map
	     (kbd "C-j") 'peep-dired-scroll-page-down
	     (kbd "C-k") 'peep-dired-scroll-page-up
	     (kbd "j") 'peep-dired-next-file
	     (kbd "<down>") 'peep-dired-next-file
	     (kbd "k") 'peep-dired-prev-file
	     (kbd "<up>") 'peep-dired-prev-file
	     (kbd "h") 'peep-dired-up-directory
	     (kbd "<left>") 'peep-dired-up-directory
	     (kbd "l") 'peep-dired-find-file
	     (kbd "<right>") 'peep-dired-find-file
	     (kbd ">") 'peep-dired-next-dirline
	     (kbd "<") 'peep-dired-prev-dirline
	     (kbd "g g") 'l/peep-dired-goto-first-file
	     (kbd "G") 'l/peep-dired-goto-last-file)
	   (evil-define-key 'normal dired-mode-map (kbd "p") 'peep-dired)
	   (add-hook 'peep-dired-hook 'evil-normalize-keymaps)))
      :bind
      (:map dired-mode-map
	    ("p" . 'peep-dired)))
    #+end_src

*** Dired narrow

    Narrow down what is shown in dired by filtering filenames.

    #+begin_src emacs-lisp
    (use-package dired-narrow
      :ensure t
      :delight (dired-narrow-mode " >⋅<")
      :after dired evil
      :init
      (setq dired-narrow-exit-when-one-left t)
      :config
      (evil-define-key 'normal dired-mode-map (kbd "f") 'dired-narrow)
      :bind
      (:map dired-mode-map
	    ("f" . 'dired-narrow)))

    #+end_src

*** Copying and pasting (and bookmarks)

    Three methods of copying and pasting:
    1. Normal: The default dired way, copy and select destination on execution. Works neatly with the =dired-target-dwim= option, but sometimes you want to mark some files to copy and then paste them after some navigation.

    2. Dired-ranger: Ranger-like copying and pasting (also bookmarks, but I have to check those out)

    #+begin_src emacs-lisp
    (use-package dired-ranger
      :ensure t
      :after dired
      :init
      (setq dired-ranger-bookmark-reopen 'always)
      :config
      ;; function to visit previous directory
      (defun l/dired-ranger-bookmark-visit-LRU ()
	"Go to last visited directory."
	(interactive)
	(dired-ranger-bookmark-visit dired-ranger-bookmark-LRU))

      ;; evil integration
      (eval-after-load "evil"
	'(progn
	   (evil-define-key 'normal dired-mode-map
	     "y" nil ;; prefix
	     "yy" 'dired-ranger-copy
	     "yP" 'dired-ranger-move
	     "yp" 'dired-ranger-paste
	     "`" nil ;; prefix
	     "``" 'l/dired-ranger-bookmark-visit-LRU
	     "`v" 'dired-ranger-bookmark-visit
	     "`m" 'dired-ranger-bookmark))))
    #+end_src

    3. Dired-rsync: Really useful for BIG files, as it does not freeze emacs. Also, progress is shown in the modeline! Some other benefits, like copy-pasting from remote, are not yet explored. Works like normal copying.

    #+begin_src emacs-lisp
    (use-package dired-rsync
      :ensure t
      :after dired
      :init
      (setq dired-rsync-unmark-on-completion nil)
      :config
      (eval-after-load "evil"
	'(progn
	   (evil-define-key 'normal dired-mode-map "r" 'dired-rsync))))
    #+end_src

**** TODO Simplify keystrokes:
     All this is really nice, but now I have three different keys related to copy-pasting (C, y, r). Maybe I should fix this somehow? I guess I will decide as I use it.

*** Wdired

**** Renaming functions
     #+begin_src emacs-lisp
     (defun l/evil-wdired-append-to-filename ()
       "Renaming helper for `wdired'. Append to filename before the extension."
       (interactive)
       (move-end-of-line nil)
       (search-backward ".")
       (evil-insert 1))

     (defun l/evil-wdired-change-filename ()
       "Renaming helper for `wdired'. Change the filename but keep the extension."
       (interactive)
       (move-end-of-line nil)
       (search-backward ".")
       (kill-region 1 (point))
       (evil-insert 1))

     (defun l/evil-wdired-change-extension ()
       "Renaming helper for `wdired'. Change file's extension."
       (interactive)
       (move-end-of-line nil)
       (set-mark-command nil)
       (search-backward ".")
       (forward-char)
       (kill-region (point) (mark))
       (evil-insert 1))
     #+end_src

**** Wdired hook

     Just display a message when entering wdired!

     #+begin_src emacs-lisp
     (eval-after-load "evil"
       '(progn
	  (evil-define-key 'normal wdired-mode-map
	    (kbd "C-r w") 'l/evil-wdired-change-filename
	    (kbd "C-r a") 'l/evil-wdired-append-to-filename
	    (kbd "C-r x") 'l/evil-wdired-change-extension)))
     #+end_src

*** Dired rainbow

    Prettier dired. I haven't really tweaked anything, it's just some defaults from their github page.

    #+begin_src emacs-lisp
    (use-package dired-rainbow
      :ensure t
      :config
      (progn
	(dired-rainbow-define-chmod directory "#6cb2eb" "d.*")
	(dired-rainbow-define html "#eb5286" ("css" "less" "sass" "scss" "htm" "html" "jhtm" "mht" "eml" "mustache" "xhtml"))
	(dired-rainbow-define xml "#f2d024" ("xml" "xsd" "xsl" "xslt" "wsdl" "bib" "json" "msg" "pgn" "rss" "yaml" "yml" "rdata"))
	(dired-rainbow-define document "#9561e2" ("docm" "doc" "docx" "odb" "odt" "pdb" "pdf" "ps" "rtf" "djvu" "epub" "odp" "ppt" "pptx"))
	(dired-rainbow-define markdown "#ffed4a" ("org" "etx" "info" "markdown" "md" "mkd" "nfo" "pod" "rst" "tex" "textfile" "txt"))
	(dired-rainbow-define database "#6574cd" ("xlsx" "xls" "csv" "accdb" "db" "mdb" "sqlite" "nc"))
	(dired-rainbow-define media "#de751f" ("mp3" "mp4" "MP3" "MP4" "avi" "mpeg" "mpg" "flv" "ogg" "mov" "mid" "midi" "wav" "aiff" "flac"))
	(dired-rainbow-define image "#f66d9b" ("tiff" "tif" "cdr" "gif" "ico" "jpeg" "jpg" "png" "psd" "eps" "svg"))
	(dired-rainbow-define log "#c17d11" ("log"))
	(dired-rainbow-define shell "#f6993f" ("awk" "bash" "bat" "sed" "sh" "zsh" "vim"))
	(dired-rainbow-define interpreted "#38c172" ("py" "ipynb" "rb" "pl" "t" "msql" "mysql" "pgsql" "sql" "r" "clj" "cljs" "scala" "js"))
	(dired-rainbow-define compiled "#4dc0b5" ("asm" "cl" "lisp" "el" "c" "h" "c++" "h++" "hpp" "hxx" "m" "cc" "cs" "cp" "cpp" "go" "f" "for" "ftn" "f90" "f95" "f03" "f08" "s" "rs" "hi" "hs" "pyc" ".java"))
	(dired-rainbow-define executable "#8cc4ff" ("exe" "msi"))
	(dired-rainbow-define compressed "#51d88a" ("7z" "zip" "bz2" "tgz" "txz" "gz" "xz" "z" "Z" "jar" "war" "ear" "rar" "sar" "xpi" "apk" "xz" "tar"))
	(dired-rainbow-define packaged "#faad63" ("deb" "rpm" "apk" "jad" "jar" "cab" "pak" "pk3" "vdf" "vpk" "bsp"))
	(dired-rainbow-define encrypted "#ffed4a" ("gpg" "pgp" "asc" "bfe" "enc" "signature" "sig" "p12" "pem"))
	(dired-rainbow-define fonts "#6cb2eb" ("afm" "fon" "fnt" "pfb" "pfm" "ttf" "otf"))
	(dired-rainbow-define partition "#e3342f" ("dmg" "iso" "bin" "nrg" "qcow" "toast" "vcd" "vmdk" "bak"))
	(dired-rainbow-define vc "#0074d9" ("git" "gitignore" "gitattributes" "gitmodules"))
	(dired-rainbow-define-chmod executable-unix "#38c172" "-.*x.*")
	))
    #+end_src

*** Dired icons

    Pretty icons for Dired!

    #+begin_src emacs-lisp
    (use-package all-the-icons-dired
      :ensure t
      :delight
      :after dired all-the-icons
      :config
      (add-hook 'dired-mode-hook 'all-the-icons-dired-mode))
    #+end_src

*** Modeline style

    I override the default behaviour of [[file:/usr/share/emacs/26.3/lisp/dired.el.gz::(defun dired-sort-set-mode-line ()][dired-sort-set-mode-line]], as it was not appealing to me. Needs more tweaking for sure, but it works for now.

    #+begin_src emacs-lisp
    (eval-after-load "dired"
      (defun dired-sort-set-mode-line ()
	;; Set mode line display according to dired-actual-switches.
	;; Mode line display of "by name" or "by date" guarantees the user a
	;; match with the corresponding regexps.  Non-matching switches are
	;; shown literally.
	(when (eq major-mode 'dired-mode)
	  (setq mode-name
		(let (case-fold-search)
		  (cond ((string-match-p (concat (regexp-quote "-alh") "\\(\\s-\\|$\\)") dired-actual-switches)
			 "")
			((string-match-p (concat (regexp-quote "-alht") "\\(\\s-\\|$\\)") dired-actual-switches)
			 "⇓D")
			((string-match-p (concat (regexp-quote "-alhS") "\\(\\s-\\|$\\)") dired-actual-switches)
			 "⇓S")
			((string-match-p (concat (regexp-quote "-alhX") "\\(\\s-\\|$\\)") dired-actual-switches)
			 "⇓X")
			(t
			 "⇓?"))))
	  (if (string-match-p (regexp-quote " --group-directories-first") dired-actual-switches)
	      (setq mode-name (concat mode-name "⋮"))
	    (setq mode-name (replace-regexp-in-string "⋮" "" mode-name)))
	  (force-mode-line-update))))

    #+end_src
** PDF TOOLS

   #+begin_src emacs-lisp
   (use-package pdf-tools
     :ensure t
     :pin manual ;; don't reinstall on updates
     :init
     (pdf-tools-install))
   #+end_src

** DIARY AND CALENDAR
*** Default diary file
    #+begin_src emacs-lisp
    (setq diary-file "~/.personal/diary")
    #+end_src
*** Preferred time format
    #+begin_src emacs-lisp
    (calendar-set-date-style 'european)
    #+end_src
*** Start diary
    #+begin_src emacs-lisp
    (diary)
    #+end_src
** ORG-MODE
*** Ensure org-plus-contrib

    #+begin_src emacs-lisp
    (unless (package-installed-p 'org-plus-contrib)
      (package-refresh-contents)
      (package-install 'org-plus-contrib))
    #+end_src

*** Org-mode misc options

    #+begin_src emacs-lisp
    ;; prettify
    (setq org-hide-leading-stars t)

    ;; src options
    (require 'org-tempo)

    (setq org-src-fontify-natively t)
    (setq org-src-tab-acts-natively t)
    (setq org-confirm-babel-evaluate nil)
    (setq org-edit-src-content-indentation 0)

    ;; export options -- for mail html export (fix it locally!)
;;    (setq org-export-with-toc nil)
  ;;  (setq org-export-with-section-numbers nil)

    ;; links
    (setq org-link-search-must-match-exact-headline nil)
    #+end_src

*** Org-mode capture and agenda

    #+begin_src emacs-lisp
    ;; files
    (setq org-directory "~/.personal")
    (setq org-default-notes-file (concat org-directory "/organizer.org"))

    ;; include diary entries in agenda
    (setq org-agenda-include-diary t)

    ;; TODOs
    (setq org-log-done 'time)
    (setq org-log-into-drawer 'LOGBOOK)
    (setq org-clock-into-drawer t)


    ;; bindings
    (global-set-key (kbd "C-c l") 'org-store-link)
    (global-set-key (kbd "C-c a") 'org-agenda)
    (global-set-key (kbd "C-c c") 'org-capture)
    (global-set-key (kbd "C-c C-x C-z") 'org-resolve-clocks)

    ;; some capture functions from Zamansky's configuration
    (defadvice org-capture-finalize
	(after delete-capture-frame activate)
      "Advise capture-finalize to close the frame"
      (if (equal "capture" (frame-parameter nil 'name))
	  (delete-frame)))

    (defadvice org-capture-destroy
	(after delete-capture-frame activate)
      "Advise capture-destroy to close the frame"
      (if (equal "capture" (frame-parameter nil 'name))
	  (delete-frame)))

    (defun make-capture-frame ()
      "Create a new frame and run org-capture."
      (interactive)
      (make-frame '((name . "capture")))
      (select-frame-by-name "capture")
      (delete-other-windows))
    #+end_src

*** Org-capture templates

    #+begin_src emacs-lisp
    (setq org-capture-templates
	  '(("t" "Todo" entry (file+headline "" "Tasks")
	     "* TODO %?\n  %i\n  %a")

	    ("j" "Journal" entry (file+datetree "journal.org")
	     "* %^{entry title}%^G\n%U\n  %?\n")

	    ("p" "Logs for photographic process")

	    ("pd" "Darkroom log" entry (file+datetree "darkroom-log.org")
	     "* %U :darkroom:%^g\n%?" :clock-in t)

	    ;; ("B" "Web purchase" entry (file+headline "web-stuff.org" "Purchases")
	    ;;  "* ORDERED %^{item desc.}\n\n%x\n\nEst. delivery: %?\n\nOrder placed on: %U")

	    ;; ("l" "Link" entry (file+headline "web-stuff.org" "Links")
	    ;;  "* %x %^g\n %?\n%U")

	    ;; ("b" "Bibliography reference" entry (file "bib-references.org")
	    ;;  "* @%^{.bib entry}: %^{description} %^g\n %^{page(s)} %?\n%U")

	    ;; ("c" "Contact" entry (file "contacts.org")
	    ;;  "* %^{nickname}\n:PROPERTIES:\n:NAME: %^{name}\n:EMAIL: [[%^{email}]]\n:END:")
	    ))
    #+end_src

*** Org-contacts

    #+begin_src emacs-lisp
    (use-package org-contacts
      :ensure nil
      :after org mu4e
      :custom (org-contacts-files '("~/.personal/contacts.org"))
      :bind  ("C-x M-." . 'org-contacts-view-send-email))
    #+end_src

*** org-msg
    #+begin_src emacs-lisp
    (use-package org-msg
      :ensure t
      :after org mu4e
      :bind
      (:map mu4e-compose-mode-map ("M-c" . 'org-msg-edit-mode)))
    #+end_src

** LATEX

   #+begin_src emacs-lisp
   (setq TeX-parse-self t)
   (setq-default TeX-master nil)

   ;; === run xelatex on save for latex mode
   (defun latex-save-compile ()
     "Compile file after saving in latex mode. Using Xelatex."
     (when (eq major-mode 'latex-mode)
       (when (memq this-command '(save-buffer))
	 (shell-command-to-string (format "xelatex %s" buffer-file-name)))))

   (add-hook 'after-save-hook #'latex-save-compile)
   #+end_src

** MU4E
*** mu4e basic setup

    #+begin_src emacs-lisp
    (add-to-list 'load-path "/usr/local/share/emacs/site-lisp/mu4e")
    (require 'mu4e)

    (global-set-key (kbd "C-x m") 'mu4e)

    ;; some interface options
    (setq mu4e-confirm-quit nil) ;; do not confirm quitting
    (setq mail-user-agent 'mu4e-user-agent) ;; make mu4e the default for email
    (setq message-kill-buffer-on-exit t) ;; kill message buffer on exit
    (setq mu4e-index-update-in-background t) ;; do not show me the update process
    (setq mu4e-hide-index-messages t)
    (setq mu4e-headers-include-related nil)
    (setq mu4e-compose-dont-reply-to-self nil)
    (setq mu4e-compose-signature-auto-include nil)
    (setq mu4e-sent-messages-behavior 'sent)
    (setq mu4e-change-filenames-when-moving t)
    (setq mu4e-attachment-dir "~/Downloads")
    (setq mu4e-view-show-addresses t)
    ;; this one does not work out of the box. Emacs needs to be compiled with imagemagick support. Will look into this
    (setq mu4e-show-images t)
    (when (fboundp 'imagemagick-register-types)
      (imagemagick-register-types))

    (add-to-list 'mu4e-view-actions '("ViewInBrowser" . mu4e-action-view-in-browser) t)

    (setq mu4e-user-mail-address-list '("loukas.bass@gmx.com"
					"dakodeon@hotmail.com"
					"freehuggs701@gmail.com"))
    #+end_src

*** mu4e (smtp setup)

    #+begin_src emacs-lisp
    (require 'smtpmail)

    (setq message-send-mail-function 'smtpmail-send-it
	  smtpmail-default-smtp-server "mail.gmx.com"
	  smtpmail-smtp-server "mail.gmx.com"
	  smtpmail-smtp-user "loukas.bass@gmx.com"
	  smtpmail-stream-type 'starttls
	  smtpmail-smtp-service 587
	  smtpmail-debug-info t)
    #+end_src

*** mu4e sync mail

    #+begin_src emacs-lisp
    (setq mu4e-get-mail-command "mbsync -a")
    (setq mu4e-html2text-command "w3m -T text/html")
    (setq mu4e-update-interval nil) ;; do not auto-update, this is done with cronjob
    (setq mu4e-headers-auto-update t)
    #+end_src

*** mu4e directories

    #+begin_src emacs-lisp
    (setq mu4e-maildir (expand-file-name "~/.personal/Mail"))

    ;; default directories
    (setq mu4e-drafts-folder "/loukas.bass/Drafts")
    (setq mu4e-sent-folder "/loukas.bass/Sent")
    (setq mu4e-trash-folder "/loukas.bass/Trash")

    ;; maildirs shortcuts
    (setq mu4e-maildir-shortcuts
	  '( ("/Inbox" . ?i)
	     ("/loukas.bass/Inbox" . ?l)
	     ("/loukas.bass/Sent" . ?s)
	     ("/loukas.bass/Trash" . ?t)
	     ("/loukas.bass/Drafts" . ?D)
	     ("/gmail/Inbox" . ?g)
	     ("/dakodeon/Inbox" . ?d)))
    #+end_src

*** mu4e contexts

    #+begin_src emacs-lisp
    (setq mu4e-contexts
	  `( ,(make-mu4e-context
	       :name "loukas.bass"
	       :match-func (lambda (msg)
			     (when msg
			       (mu4e-message-contact-field-matches msg
								   :to "loukas.bass@gmx.com")))
	       :vars '((smtpmail-smtp-user . "loukas.bass@gmx.com")
		       (smtpmail-default-smtp-server . "mail.gmx.com")
		       (smtpmail-smtp-server . "mail.gmx.com")
		       (user-mail-address . "loukas.bass@gmx.com")
		       (user-full-name . "loukas bass")
		       (mu4e-sent-folder . "/loukas.bass/Sent")
		       (mu4e-drafts-folder . "/loukas.bass/Drafts")
		       (mu4e-trash-folder . "/loukas.bass/Trash")))

	     ,(make-mu4e-context
	       :name "gmail"
	       :match-func (lambda (msg)
			     (when msg
			       (mu4e-message-contact-field-matches msg
								   :to "freehuggs701@gmail.com")))
	       :vars '((smtpmail-smtp-user . "freehuggs701@gmail.com")
		       (smtpmail-default-smtp-server . "smtp.gmail.com")
		       (smtpmail-smtp-server . "smtp.gmail.com")
		       (user-mail-address . "freehuggs701@gmail.com")
		       (user-full-name . "freexon")
		       (mu4e-sent-folder . "/gmail/[Gmail]/Sent Mail")
		       (mu4e-drafts-folder . "/gmail/Drafts")
		       (mu4e-trash-folder . "/gmail/Trash")))

	     ,(make-mu4e-context
	       :name "dakodeon"
	       :match-func (lambda (msg)
			     (when msg
			       (mu4e-message-contact-field-matches msg
								   :to "dakodeon@hotmail.com.com")))
	       :vars '((smtpmail-smtp-user . "dakodeon@hotmail.com")
		       (smtpmail-default-smtp-server . "smtp.office365.com")
		       (smtpmail-smtp-server . "smtp.office365.com")
		       (user-mail-address . "dakodeon@hotmail.com")
		       (user-full-name . "loukas b")
		       (mu4e-sent-folder . "/dakodeon/Sent")
		       (mu4e-drafts-folder . "/dakodeon/Drafts")
		       (mu4e-trash-folder . "/dakodeon/Trash")))))

    (setq mu4e-context-policy 'pick-first)
    #+end_src

*** mu4e open in headers of specific account

    #+begin_src emacs-lisp
    (defun mu4e-open-in-headers (account)
      "Open mu4e in account's Inbox"
      (interactive)
      (mu4e~start)
      (if (get-buffer "*mu4e-headers*" )
	  (switch-to-buffer "*mu4e-headers*"))
      (mu4e-headers-search (concat "maildir:/" account "/Inbox")))
    #+end_src

*** mu4e external notifications (for i3blocks)

    #+begin_src emacs-lisp
    (add-hook 'mu4e-index-updated-hook
	      (defun mu4e-signal-i3blocks ()
		(shell-command "pkill -RTMIN+2 i3blocks")))

    (add-hook 'mu4e-view-mode-hook 'mu4e-signal-i3blocks)
    #+end_src

*** Contacts management

Manage contacts with org-contacts

#+begin_src emacs-lisp
(setq mu4e-org-contacts-file "~/.personal/contacts.org")

(add-to-list 'mu4e-headers-actions
	     '("org-contact-add" . mu4e-action-add-org-contact) t)

(add-to-list 'mu4e-view-actions
	     '("org-contact-add" . mu4e-action-add-org-contact) t)
#+end_src

*** Start mu4e

Auto start mu4e on emacs startup

    #+begin_src emacs-lisp
    (mu4e~start)
    (mu4e-update-mail-and-index t)
    #+end_src

** EVIL COLLECTION
   A bunch of evil bindings

   #+begin_src emacs-lisp
   ;;    (use-package evil-collection
   ;;      :after evil
   ;;      :ensure t
   ;;      :config
   ;;      (evil-collection-init))

   #+end_src

** EVIL

   It's good to have vim's normal-state to move around, change words, search etc, but for a true combination of emacs and vim, I replaced insert-state with emacs-state. The best of two worlds!

   -- Note: there's a bunch of bindings in normal-state beause of the visual-line-mode that I use. I have to get rid of that at some point.

   #+begin_src emacs-lisp
   (use-package evil
     :ensure t
     :init
     (setq evil-move-cursor-back nil)
     (setq evil-want-C-u-scroll t)
     (setq evil-want-fine-undo t)
     (setq evil-normal-state-cursor 'box)
     (setq evil-emacs-state-cursor 'bar)
     (setq evil-replace-state-cursor 'hbar)
     (setq evil-want-integration t)
     (setq evil-want-keybinding t)
     (setq evil-find-skip-newlines t)
     :config
     (evil-mode 1)
     (evil-set-initial-state 'Info-mode 'emacs)
     (evil-set-initial-state 'org-capture-mode 'emacs)
     (evil-set-initial-state 'mu4e-compose-mode 'emacs)
     (evil-set-initial-state 'org-msg-mode 'emacs)
     (evil-set-initial-state 'package-menu-mode 'emacs)
     (evil-define-state emacs
       "Emacs used as insert state in evil."
       :tag " <EE> "
       :message "-- EMACS INSERT --"
       :input-method t)
     (defadvice evil-insert-state (around emacs-state-instead-of-insert-state activate) (evil-emacs-state))
     :bind
     (:map evil-normal-state-map
	   ("j" . 'evil-next-visual-line)
	   ("k" . 'evil-previous-visual-line)
	   ("^" . 'evil-beginning-of-visual-line)
	   ("$" . 'evil-end-of-visual-line)
	   ("g ^" . 'evil-beginning-of-line)
	   ("g $" . 'evil-end-of-line)
	   ([down] . 'evil-next-visual-line)
	   ([up] . 'evil-previous-visual-line)
	   ("s" . nil) ;; was evil-subtitute
	   ("s p" . 'mark-paragraph)
	   :map evil-emacs-state-map
	   ([escape] . 'evil-normal-state)))

    #+end_src

** CUSTOM FILE SHORTCUTS

   #+begin_src emacs-lisp
   (defun goto-file-or-dir (f)
     "Find the given file. If file is a directory, do helm-find-file there"
     (if (file-directory-p f)
	 (helm-find-files-1 f)
       (if (file-exists-p f)
	   (find-file f))))

   ;; create a prefix
   (define-prefix-command 'z-map)
   (global-set-key (kbd "C-x g") 'z-map)

   (define-key z-map (kbd "E") (lambda () (interactive) (goto-file-or-dir "~/.emacs.d/init.el")))
   (define-key z-map (kbd "e") (lambda () (interactive) (goto-file-or-dir "~/.emacs.d/my-config.org")))
   (define-key z-map (kbd "i") (lambda () (interactive) (goto-file-or-dir "~/.config/i3/i3.conf")))
   (define-key z-map (kbd "r") (lambda () (interactive) (goto-file-or-dir "~/.config/ranger/rc.conf")))
   (define-key z-map (kbd "x") (lambda () (interactive) (goto-file-or-dir "~/.Xresources")))
   (define-key z-map (kbd "z") (lambda () (interactive) (goto-file-or-dir "~/.zshrc")))
   (define-key z-map (kbd "h") (lambda () (interactive) (goto-file-or-dir "~/")))
   (define-key z-map (kbd "P") (lambda () (interactive) (goto-file-or-dir "~/Pictures/")))
   (define-key z-map (kbd "p") (lambda () (interactive) (goto-file-or-dir "~/.personal/")))
   (define-key z-map (kbd "C") (lambda () (interactive) (goto-file-or-dir "~/.config/")))
   (define-key z-map (kbd "D") (lambda () (interactive) (goto-file-or-dir "~/Downloads/")))
   (define-key z-map (kbd "d") (lambda () (interactive) (goto-file-or-dir "~/Documents/")))
   (define-key z-map (kbd "c") (lambda () (interactive) (goto-file-or-dir "~/dotfiles/")))
   (define-key z-map (kbd "S") (lambda () (interactive) (goto-file-or-dir "~/.config/scripts/")))
   #+end_src

** GAMES 
*** 2048 GAME

    Nice game, here it is with vim bindings

     #+begin_src emacs-lisp
     (use-package 2048-game
       :ensure t
       :config
       (eval-after-load "evil"
	 '(progn
	    (evil-define-key 'normal 2048-mode-map
	      "q" 'quit-window
	      "h" '2048-left
	      "j" '2048-down
	      "k" '2048-up
	      "l" '2048-right))))
     #+end_src
     
*** SNAKE

    #+begin_src emacs-lisp
    (eval-after-load "evil"
      '(progn
	 (evil-set-initial-state 'snake-mode 'normal)
	 (evil-define-key 'normal snake-mode-map
	   "h" 'snake-move-left
	   "j" 'snake-move-down
	   "k" 'snake-move-up
	   "l" 'snake-move-right
	   "p" 'snake-pause-game
	   "q" 'quit-window
	   "N" 'snake-start-game)))
    #+end_src
